<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用构造函数 和 使用 class 实现继承的区别]]></title>
    <url>%2F2019%2F09%2F07%2F%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%92%8C-%E4%BD%BF%E7%94%A8-class-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 使用class 实现继承class Animal1 &#123; constructor(name,age) &#123;// this.name = name this.age = age this.eat = function() &#123; console.log(`$&#123;this.name&#125; eat`) &#125; &#125; walk() &#123; console.log(`$&#123;this.name&#125; walk`) &#125;&#125;class Dog extends Animal1 &#123; constructor(name,age) &#123; super(name,age) this.name = name &#125; bark() &#123; console.log(`$&#123;this.name&#125; bark`) &#125;&#125;var dog = new Dog('dog',4)console.log(dog)// 使用构造函数实现继承function Animal2(name,age) &#123; this.name = name this.age = age this.eat = function() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;Animal2.prototype.walk = function() &#123; console.log(`$&#123;this.name&#125; walk`)&#125;function Cat(name) &#123; this.name = name&#125;Cat.prototype.bark = function () &#123; console.log(`$&#123;this.name&#125; bark`)&#125;Cat.prototype = new Animal2('Animalcat',4)var cat = new Cat('cat')console.log(cat)]]></content>
  </entry>
  <entry>
    <title><![CDATA[谷歌开发者工具使用]]></title>
    <url>%2F2019%2F09%2F06%2F%E8%B0%B7%E6%AD%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1 两个网址 Chrome 开发者工具中文手册 Chrome 开发者工具官网 2 相关博客1 查看 对象属性的可读写性每当控制台输入一个对象，总是发现对象包含内容，如 属性，方法，prototype，__proto__，作用域等，有时候还发现有很多get 和 set 方法 ，如图所示： 2 chrome浏览器中的Timing详情说明https://blog.csdn.net/itpinpai/article/details/52574385?utm_source=blogxgwz2 3 谷歌开发者工具https://blog.csdn.net/m0_37724356/article/details/79884006 https://www.jianshu.com/p/1e290caef2c9]]></content>
  </entry>
  <entry>
    <title><![CDATA[易错代码]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%98%93%E9%94%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[例1：1234567/*HTML代码*/&lt;div class="images" id=images&gt; &lt;img src="./images/1.jpg" alt="图片1" width="100" height="100"&gt; &lt;img src="./images/2.jpg" alt="图片2" width="100" height="100"&gt; &lt;img src="./images/3.jpg" alt="图片3" width="100" height="100"&gt; &lt;img src="./images/4.jpg" alt="图片4" width="100" height="100"&gt;&lt;/div&gt; 12345/*JS代码*/console.log($(`.images &gt; img:nth-child($&#123;n&#125;)`)) //这句代码才是打出指定的imgconsole.log($('.images &gt; img:nth-child(n)'))//这句话会打出所有img]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML标签-table]]></title>
    <url>%2F2019%2F08%2F30%2FHTML%E6%A0%87%E7%AD%BE-table%2F</url>
    <content type="text"><![CDATA[table 标签 用于展示 数据。不太常用。HTML规定table标签只能有三个子元素thead、tbody、tfoot。子元素里面又可以有很多元素。 应用11234567891011121314151617181920212223&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;班级&lt;/th&gt;&lt;th&gt;分数&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt;小明&lt;/td&gt;&lt;td&gt;1班&lt;/td&gt;&lt;td&gt;96&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt;小红&lt;/td&gt;&lt;td&gt;2班&lt;/td&gt;&lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;平均分&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;95&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;总分&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;190&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 2table 的完整用法 1234567891011121314151617181920212223242526272829 &lt;table border=1&gt; &lt;colgroup&gt; &lt;col width=100&gt; &lt;col width=200 bgcolor=red&gt; &lt;col width=100&gt; &lt;col width=70&gt; &lt;/colgroup&gt; &lt;!--colgroup和col列配套使用--&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;班级&lt;/th&gt;&lt;th&gt;分数&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt;小明&lt;/td&gt;&lt;td&gt;1班&lt;/td&gt;&lt;td&gt;96&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt;小红&lt;/td&gt;&lt;td&gt;2班&lt;/td&gt;&lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;平均分&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;95&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;总分&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;190&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 注意当tbody、tfoot、thead、colgroup顺序混乱时，浏览器会自动更正他们的显示顺序依然是thead、tbody、tfoot、colgroup。当你thead、tbody、tfoot这些标签都不写的时候，浏览器会认为你写的都是tbody的内容，此时就会按你写的内容顺序展示给用户。 当你在头head标签加入css样式可以去掉table之间的间隙，如下： 3 去除 table 之间的间隙 123table&#123; border-collapse: collapse;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[table]]></title>
    <url>%2F2019%2F08%2F30%2Ftable%2F</url>
    <content type="text"><![CDATA[前端学习笔记，仅供复习参考使用，若有不足之处请在评论区指出！谢谢！]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML标签-input/button]]></title>
    <url>%2F2019%2F08%2F30%2FHTML%E6%A0%87%E7%AD%BE-input-button%2F</url>
    <content type="text"><![CDATA[学习标签就是重点学标签的语义和属性。标签单词懂了，语义一般就懂了。而标签有什么属性则是需要查文档，然后练习和记忆的，标签常见的属性是必须熟悉熟悉熟悉的。 input 标签input最难记的是type属性值，有很多。input按type值确定功能。input一般是form标签的子元素。 type 属性经常使用的属性值有： text password submit button radio checkbox input 的 其他 type 值 要靠试出来。 name 属性form 标签里面的input若不加 name属性，那么在表单提交时，input 的值就不会出现在请求里，必须要有name属性才能提交数据到服务器，切记 value 属性placeholder 属性​ 占位符 应用1123456&lt;form action="users" method="post" target="与a标签一样用法"&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt; &lt;!--提交按钮--&gt; &lt;input type="button" value="普通按钮"&gt; &lt;!--这只是普通按钮--&gt;&lt;/form&gt; 上面代码中 提交按钮 和 普通按钮 长得一模一样，但是功能不同。 2有个特例，当form表单里只有botton 元素时，button 按钮会自动上升为submit按钮。如下的button就是submit按钮。 12345&lt;form action="users" method="post" target="与a标签一样用法"&gt; &lt;input type="text" name="username" placeholder="请输入用户名"&gt; &lt;input type="password" name="password" placeholder="请输入密码"&gt; &lt;button&gt;提交&lt;/button&gt; &lt;!--普通按钮升级成提交按钮--&gt;&lt;/form&gt; 上面代码中 button 可以发起 post 请求。 3label和input配对使用作为form的子元素，label包围input，当用户在文字上点击就能选中复选框或者输入框，培养用户懒性。 123456&lt;form action="users" method="post" target="_blank"&gt; &lt;label&gt;用户名&lt;input type="text" name="username"&gt;&lt;/label&gt; &lt;label&gt;密码&lt;input type="password" name="password"&gt;&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox"&gt;苹果&lt;/label&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; 4 12345678910111213141516171819202122&lt;form action="users" method="post" target="与a标签一样用法"&gt; 喜欢的水果 &lt;label&gt;&lt;input type="checkbox" name="fruit" value="orange"&gt;橘子&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" name="fruit" value="apple"&gt;苹果&lt;/label&gt; 喜欢我 &lt;label&gt;&lt;input type="radio" name="loveme" value="yes"&gt;YES&lt;/label&gt; &lt;label&gt;&lt;input type="radio" name="loveme" value="no"&gt;NO&lt;/label&gt; &lt;input type="submit" value="submit"&gt; &lt;select name="group" multiple&gt; &lt;option value=""&gt;-&lt;/option&gt; &lt;option value="1"&gt;第一组&lt;/option&gt; &lt;option value="2"&gt;第二组&lt;/option&gt; &lt;option value="3" disabled&gt;第三组&lt;/option&gt; &lt;option value="4" selected&gt;第四组&lt;/option&gt; &lt;/select&gt; &lt;!--多行文本，用css控制宽高--&gt; &lt;textarea name="爱好" style="resize: none;width: 100px;height: 200px"&gt;&lt;/textarea&gt; &lt;/form&gt; button 标签注意 input 和 button 的区别：是否为「空标签」。input没有子元素，button有子元素。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML标签-form]]></title>
    <url>%2F2019%2F08%2F30%2FHTML%E6%A0%87%E7%AD%BE-form%2F</url>
    <content type="text"><![CDATA[学习标签就是重点学标签的语义和属性。标签单词懂了，语义一般就懂了。而标签有什么属性则是需要查文档，然后练习和记忆的，标签常见的属性是必须熟悉熟悉熟悉的。 form标签form 表单 是 发起 post 请求，提交内容 或者 上传 数据到服务器。 action 属性​ 指定请求路径 method 属性​ 指定请求方式，值是post。 target 属性​ 同 a 标签的 target 属性使用方法相同 form 标签 与 a 标签 比较get 是获取这个页面内容，post 是上传数据到服务器。除了form，HTML没有其他标签能上传内容到服务器。a 标签是get，form 是post。get会默认把参数放到查询参数里面，直接出现在地址栏里，post会默认把参数放到 请求的第四部分里面。我们没有办法让get请求有第四部分。总结就是a标签和form标签都是发起一个请求的，只不过a标签是get一个页面，form标签是post一个页面。 应用1 多种表达内的子元素 12345678910111213141516171819202122&lt;form action="users" method="post" target="与a标签一样用法"&gt; 喜欢的水果 &lt;label&gt;&lt;input type="checkbox" name="fruit" value="orange"&gt;橘子&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" name="fruit" value="apple"&gt;苹果&lt;/label&gt; 喜欢我 &lt;label&gt;&lt;input type="radio" name="loveme" value="yes"&gt;YES&lt;/label&gt; &lt;label&gt;&lt;input type="radio" name="loveme" value="no"&gt;NO&lt;/label&gt; &lt;input type="submit" value="submit"&gt; &lt;select name="group" multiple&gt; &lt;option value=""&gt;-&lt;/option&gt; &lt;option value="1"&gt;第一组&lt;/option&gt; &lt;option value="2"&gt;第二组&lt;/option&gt; &lt;option value="3" disabled&gt;第三组&lt;/option&gt; &lt;option value="4" selected&gt;第四组&lt;/option&gt; &lt;/select&gt; &lt;!--多行文本，用css控制宽高--&gt; &lt;textarea name="爱好" style="resize: none;width: 100px;height: 200px"&gt;&lt;/textarea&gt; &lt;/form&gt; 2 12345&lt;form action="users" method="post" target="与a标签一样用法"&gt; &lt;label&gt;用户名：&lt;input type="text" name="username"&gt;&lt;/label&gt; &lt;label&gt;密码：&lt;input type="password" name="password"&gt;&lt;/label&gt; &lt;label&gt;&lt;input type="submit" value="提交"&gt;&lt;/label&gt; &lt;!--只有有了提交按钮才能将数据提交到服务器,submit是唯一能确定这个表单能提交的--&gt;&lt;/form&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML标签-a]]></title>
    <url>%2F2019%2F08%2F30%2FHTML%E6%A0%87%E7%AD%BE-a%2F</url>
    <content type="text"><![CDATA[学习标签就是重点学标签的语义和属性。标签单词懂了，语义一般就懂了。而标签有什么属性则是需要查文档，然后练习和记忆的，标签常见的属性是必须熟悉熟悉熟悉的。 a标签a是anchor锚的缩写， HTML&lt;a&gt;元素(或锚元素)可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他URL的超链接。 常用属性targettarget属性有四个值，分别是单词对应意思。 1234567&lt;a href=&quot;http://qq.com&quot; target=&quot;_blank&quot;&gt;blank_qq&lt;/a&gt; &lt;!--在新开空窗口打开--&gt;&lt;a href=&quot;http://qq.com&quot; target=&quot;_self&quot;&gt;self_qq&lt;/a&gt; &lt;!--在自己这个窗口（2.html）打开--&gt;&lt;a href=&quot;http://qq.com&quot; target=&quot;_parent&quot;&gt;parent_qq&lt;/a&gt; &lt;!--在父亲窗口(这里是index.html)打开和iframe一起使用才有体会--&gt;&lt;a href=&quot;http://qq.com&quot; target=&quot;_top&quot;&gt;top_qq&lt;/a&gt; &lt;!--在顶级窗口打开，在至少有祖孙三代才能体会到--&gt; 效果： 点击第1个qq以后会新开窗口(即不会把爷爷index.html页面覆盖掉)打开点击第2个qq以后在自己的窗口(3.html，不会覆盖掉父亲2.html页面)打开点击第3个qq以后在父窗口(即会把父亲2.html页面覆盖掉)打开点击第4个qq在顶层口打开(即覆盖掉爷爷index.html页面)，可以依次打开其他qq可深刻体会到效果 download强制下载 属性指示浏览器下载URL而不是导航到它，因此将提示用户将其保存为本地文件。如果属性有一个值，那么它将在Save提示符中作为预填充的文件名使用。告诉浏览器我这个网页不是拿来查看的，是用浏览器下载的。 1&lt;a href=&quot;./2.html&quot; download=&quot;&quot;&gt;下载&lt;/a&gt; href该属性是必须写的 属性值有： 网址 无协议绝对地址 1&lt;a href="//qq.com"&gt;QQ&lt;/a&gt; a标签的无协议绝对地址，则当前页面用什么协议用什么协议。还可以写相对路径 ，直接打开了2.html 相对路径 1&lt;a href="./2.html"&gt;click&lt;/a&gt; 页内跳转 1&lt;a href="#"&gt;QQ&lt;/a&gt; 直接写查询字符串#xxx锚点是不发起请求的。?name=linyan发起请求 javascript 伪协议 1&lt;a href="javascript:alert(1);"&gt;QQ&lt;/a&gt; 1&lt;a href="javascript:;"&gt;QQ&lt;/a&gt; 后者是点击以后什么不做，工作以后就会遇见要求用a标签写一个点击以后页面不动]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML标签-iframe]]></title>
    <url>%2F2019%2F08%2F30%2FHTML%E6%A0%87%E7%AD%BE-iframe%2F</url>
    <content type="text"><![CDATA[学习标签就是重点学标签的语义和属性。标签单词懂了，语义一般就懂了。而标签有什么属性则是需要查文档，然后练习和记忆的，标签常见的属性是必须熟悉熟悉熟悉的。 iframe嵌套页面 iframe 标签是在当前页面嵌入一个窗口，这个窗口的内容可以直接显示一个网站内容，或者用a标签间接指向iframe嵌入的窗口，在这个嵌入的窗口内打开a标签跳转的页面。iframe在现在的前端开发中很少用，在五年前一些遗留的项目中还能看到iframe标签的使用。iframe的name属性和a标签结合使用，不结合则name属性没什么用;iframeborder属性是用来消除iframe自带的很丑的边框的，一般都要写；src属性一般是填网址，也支持相对路径。下面举例说明。 例子11&lt;iframe src="https://www.baidu.com" name="xxx"&gt;&lt;/iframe&gt; 示例 例子2a标签和iframe的name属性一起使用，a标签要在name=xxx的窗口中打开。发现用a标签跳转的页面出现在 用iframe在当前页面嵌入的窗口中 例子3用法示例3：iframe支持相对路径。在当前页面嵌入一个窗口，在这个嵌入窗口中打开当前目录下的某文件。注意页面(index.html)文件和“某文件”在同一目录下，效果是 该文件的内容 出现在了 当前页面(index.html)用 iframe 嵌入的窗口里]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP初识]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[WWW 的来历1990万维网（World Wide Web）出生。Tim Berners-Lee发明了用网址就能访问网页的办法,一个能适用于全世界的网络。他发明了第一个网页、第一个浏览器和第一个服务器。WWW简称Web,分为Web客户端和Web服务器程序。WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面,是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而用户通过点击链接来获得资源。（–内容来自百度百科） HTML + URL + HTTPwww包含三个概念：URL，俗称网址。HTTP，两个电脑之间传输内容要严格遵守的协议。HTML，超级文本，主要用来做页面跳转。URL 的作用是能让你访问一个页面，HTTP 的作用是让你能下载这个页面，HTML的作用是让你能看懂这个页面。 HTMLHTML(HyperText Markup Language),”超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”（Head）、和“主体”（Body）两部分，其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。世界上第一个网页：http://info.cern.ch URLURI 唯一统一资源标识符（Uniform Resource Identifier，或URI)是用于给互联网上的任一个资源作标记的字符串,每个资源都有一个唯一代号。这样标识后允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。`URL（Uniform Resource Locator，统一资源定位符）和URN（Uniform Resource Name，统一资源名称）是URI的子集。 URN​ 统一资源名（URN）如同一个人的名称 URL 唯一​ 统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法,更常用。URL是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。​ HTTP超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。 HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。 通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs来标识。 DNSDNS(Domain Name System),是互联网的一项服务。它将域名和IP地址相互映射成一个分布式数据库，简单说就是输入域名,输出对应IP地址。在gitbash命令行输入nslookup baidu.com或ping baidu.com,你就能看到你的路由器IP(中间商、代理)和你要访问的网站服务器IP（这才是我们的目标） curl命令在命令行用curl创造一个请求，并得到响应 请求命令 1curl -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot; 1curl -X POST -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot; 1curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot; 请求与响应 Server + Client + HTTP服务器与浏览器的交互 请求的格式1 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.034 要上传的数据 对请求格式的说明 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\n）（用来区分第二和第四部分） 动词有 GET（获取） POST（新增或上传数据） PUT（整体更新） PATCH（局部更新） DELETE（删除） HEAD OPTIONS 等 这里的路径包括「查询参数」，但不包括「锚点」,锚点是浏览器看的,服务器不看 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 响应的格式1 协议/版本号 状态码 状态说明文本2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 对请求格式的说明状态码要背，是服务器对浏览器说的话（状态代码由三位数字组成，第一个数字定义了响应的类别，12345） 1xx 不常用 （信息类状态码） 2xx 表示成功 （成功状态码，表示服务器已成功接收到请求并进行处理） 3xx 表示滚吧 （重定向状态码，表示服务器要求客户端重定向） 4xx 表示你丫错了（客户端错了） 5xx 表示好吧，我错了（服务器错了） 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式，遵循 MIME 规范 响应的第四部分内容可以很长很长 GET 请求和 POST 请求对应的响应可以一样，也可以不一样 使用Chrome发请求和查看响应用 Chrome 发请求1 打开 Network （打开浏览器页面-右键-检查）2 地址栏输入网址3 点击 Network，查看 headers，点击「view source」可以看到请求的前三部分了4 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到 用 Chrome 查看响应1 打开 Network2 输入网址3 选中第一个响应4 查看 Response Headers，点击「view source」你会看到响应的前两部分 5 查看 Response 或者 Preview，你会看到响应的第 4 部分 普通URL详解例如这个普通的URL(俗称网址）:http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分： 协议该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的 //为分隔符 域名该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。其中com是一级域名,aspxfans是二级域名，www是三级域名 端口 可选跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80 虚拟目录 可选从域名后的第一个/开始到最后一个/为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是 /news/ 文件名 可选 从域名后的最后一个“/”开始到“？”为止，是文件名部分 /———-？ 如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分 /——-# 如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。 /-end 文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 参数 可选参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 ?——-# 本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。 锚 可选 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 参考博文来自：https://blog.csdn.net/ergouge/article/details/8185219 URL用法举例:https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#5 就是一个 URL，通过 URL 你可以确定一个「唯一的」地址（网址）。 HTML简述当响应的第二部分有 Content-Type: text/html 而且响应的第四部分是 HTML 文本时，我们就可以在浏览器看到网页了。李发明的HTML,延续至今的标签有 title a p h1~h6 dl ul。HTML一开始的意图只是用来写文章和页面跳转，没想到现在的开发者已经用 HTML 做一切东西了。以下软件都在使用 HTML 做界面,手机微信、手机QQ、PC微信、PC QQ、钉钉、淘宝、支付宝、美团……所有 App 都会内置一个浏览器（WebView）用来展示 HTML，而 HTML 都是通过 HTTP 下载的，而如果你要使用 HTTP 一般都会用到URL。这是一个简单而完美的系统。CSS 的发明,李爵士在欧洲核子研究中（CERN）时，他的同事发明了 CSS，主要用来给 HTML 添加样式。当时JavaScript还没有出生。]]></content>
  </entry>
  <entry>
    <title><![CDATA[项目：画皮卡丘]]></title>
    <url>%2F2019%2F08%2F30%2F%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%94%BB%E7%9A%AE%E5%8D%A1%E4%B8%98%2F</url>
    <content type="text"><![CDATA[前端学习笔记，仅供复习参考使用，若有不足之处请在评论区指出！谢谢！ 主要使用的APIdocument.querySelector(&#39;#id&#39;) setTimeout(fn,time) string.substring(0,n) element.innerHTML element.scrollTop element.scrollHeight 立即执行函数 pre标签 jQuery 代码分析]]></content>
  </entry>
  <entry>
    <title><![CDATA[项目：搭建在线简历网站]]></title>
    <url>%2F2019%2F08%2F30%2F%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BF%E7%AE%80%E5%8E%86%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[HTML 页面分析你看到的这个页面，由哪些部分（标签组成），写html的时候不用考虑样式切记。比如这个简历，上半拉由 图片logo&lt;img&gt;，导航栏&lt;nav&gt;组成，图片的地址暂时不知道用#代替，导航栏中的若干词条其实又是链接（内外跳转），用&lt;a&gt;分别包含各个词条，各个词条之间的关系又是 无序链表 ，所以用&lt;ul&gt;&lt;li&gt;（unorderred list）将整个词条包起来。这就是上半部分的语义化。你看代码就能看出表达什么。通过这个在线的简历，我们发现&lt;img&gt; 和 导航栏 又是被划分 到一块了，所以用&lt;div&gt;将两个整体标起来，而&lt;div&gt;标签往往用一个class属性值对来区分,因为我们知道div标签是没有语义的，所以必须用class来标记它是属于哪一块，同时这样你的代码质量也更高（以后我们知道这是为了添加样式、定位更方便）。黑色banner意为广告横幅，在html里面就是一个 背景图片，而背景图片不用&lt;img&gt;标签，单独用&lt;div&gt;标签划分一个块。接着 我们看到页面最中间的位置，是我们简历最主要的部分，在html中最主要的部分用&lt;main&gt;标签框起来。然后在&lt;main&gt;标签里面写代码,首先我们要分析这个主要的部分里面的结构，是上下还是左右，我们的例子里是上下结构，上 又是一个左右结构，上左是一个图片，上右 是问候语，名字，职称，链表。我们用class命名的时候，命名的规范是告诉它是什么，而不是长什么样。用&lt;div&gt;分上下块，分别在上&lt;div&gt;块中再使用&lt;div&gt;分左右块，左 picture，右 text。左边同上，右边 问候语是没有专门的标签，用 &lt;span&gt; 包起问候语。你的名字,你的职称你要是觉得它是标题二就用h2，看你自己的分析。是水平分隔线，要学会分析网页。接着我们看到一个名称一个值，我们应该用描述链表&lt;dl&gt;，description list，描述链表。通常是如下用，&lt;dl&gt; &lt;dt&gt;年龄&lt;/dt&gt;&lt;dd&gt;18&lt;/dd&gt; &lt;dt&gt;所在城市&lt;/dt&gt;&lt;dd&gt;北京&lt;/dd&gt; &lt;dt&gt;邮箱&lt;/dt&gt;&lt;dd&gt;123@gmail.com&lt;/dd&gt; &lt;/dl&gt;,&lt;dt&gt;是description term,&lt;dd&gt;是 description definition。回忆之前的无序链表&lt;ul&gt; &lt;li&gt;词条1&lt;/li&gt; &lt;li&gt;词条2&lt;/li&gt; &lt;li&gt;词条3&lt;/li&gt; &lt;ul&gt;。好了回到最开始的下块，像个页脚，用&lt;footer&gt;整个包起来。这个页脚是一个由七个图片组成的无序链表，每个图片又是一个链接,所以用&lt;a&gt;标签包含每个图片&lt;img&gt;标签。这样写 &lt;footer class=&quot;media&quot;&gt; a[href=#]*7 &gt; img[src=....] &lt;/footer&gt; 。到此main的部分也完成了。接下来下面有个长得像按钮的，点一下可以下载我们的简历，实际上虽然它长得像按钮，实际上点了以后会跳到另外一个页面去下载，点一下跳转到另一个页面的一定就是我们的&lt;a&gt;标签了，不要被外表迷惑，点一下出来一个窗口的才是&lt;button&gt;。拖动在线简历发现这个“按钮”也是main的一部分，所以再用&lt;div&gt;进行划分。然后下面那一大段话也是main这个主要部分里面的。 CSS 样式JS 逻辑没办法用CSS控制滚动条，只能用JS控制滚动条。如果1s内有24帧,人眼睛看起来就像在动。 setInterval（code，delay）; JS调试： console.log()调试大法。 tween.js 在github上。当我们用一个代码时，先看示例，然后在jsbin上做成功后，再加入到我们的代码里。 https://cdnjs.com/ 去这个网站找js代码引入。 解决一个问题的关键是先着手解决这个问题 学会在不懂的情况下搞定这个问题 找到能用的代码，试着改一改，每次先小改，再大改。 写代码的时候，在关键的地方打log，能确保你的代码按你想的去做。 不要将两个动作用一个状态表示，容易出Bug. 动画能用CSS做，也能用JS做。JS更多是用来加删active,来切换用CSS写的动画（静态）状态。 初级JS永远都在找元素、给元素加class JS animatian transition 浏览器给你提供的东西 就叫API.API看mdn的更好。MDN上的API最全面，学得更深入。阮一峰更多的是教你怎么用。 加数据库事出有因数据是存在服务器端才能实现跨设备使用数据。我们没有学服务器，但是要存数据就要有一个服务器，但是上阿里云看了买一个服务器又太贵了。所以我们使用免费的。https://leancloud.cn 。 LeanCloud 介绍一个自带数据库和增删改查（CRUD）功能的后台系统。 拥有： 登录注册、手机验证码功能（收费） 存储任意信息 读取任意信息 搜索任意信息 删除任意信息 更新任意信息 等功能。 把LeanCloud集成到我们的简历 给简历添加留言思路：将用户提交的留言保存到数据库，将数据库中的留言展示出来。 留言板功能： 用户可以新增留言 没有其他功能 使用LeanCloud遇到没有见过的知识时，使用 Copy-Run-Modify 套路即可。 注册leancloud账号 创建一个应用resume-2019-1 点击你刚创建的应用-点击右边的帮助-点击入门指导 引入 av-min.js，得到 window.AV 初始化 AV 对象（代码直接拷） 新建一条数据（代码直接拷） 这样我们就有了一个免费的数据库，还不需要服务器。 使用这个数据库需要我们懂：JS,promise,Http 封装成一个 ModelModel 就是一个操作数据的对象而已 注意，不允许上传 node_modules 到 github ！ 如果你把 node_modules 目录上传到 github，那么你的项目将变得非常大 请在每个项目里创建 .gitignore 文件，在文件里写上一行 /node_modules/ ，即可防止 node_modules 目录被提交 如果你已经手贱把 node_modules 提交到了 github，那么请这样来撤销： touch .gitignore echo /node_modules/ &gt;&gt; .gitignore git rm -r --cached node_modules git add . -A git commit -m &quot;remove node_modules&quot; git push npm install 或者 yarn install]]></content>
  </entry>
  <entry>
    <title><![CDATA[单行&多行文本省略]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%8D%95%E8%A1%8C-%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E7%9C%81%E7%95%A5%2F</url>
    <content type="text"><![CDATA[单行文本溢出显示省略号必须给父元素设置下面四个属性，缺一不可。 123456.box &#123; width: 120px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; demo demo2 多行文本溢出显示省略号还没遇到这样的需求，待补充]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS属性-元素的宽度和高度]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E5%B1%9E%E6%80%A7-%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%BD%E5%BA%A6%E5%92%8C%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[本文对象 当然是块级元素 width max-width min-width1 最大最小值宽度使用类似，在最大最小值宽度满足之前，width属性生效，根据width属性值计算元素的宽度。 2 若持续拖动放大屏幕，使得元素根据width属性计算出来的宽度值大于等于最大宽度值，则width属性失效，元素宽度始终保持最大宽度值, 此时设置 margin: 0 auto; 可以使得该元素在父元素中居中。这也是 水平居中的方法之一 3 若持续缩小屏幕，使得元素根据width属性计算出来的宽度值小于等于设置的最小宽度，则width属性失效，元素宽度始终保持最小宽度值，直到屏幕缩小不足元素的最小宽度值，屏幕就会出现滚动条。 当不合理时， 1 如若 min-width &gt; max-width ,则 max-width 会覆盖掉 max-width，max-width失效。 2 若 min-width &gt; width 时，min-width会覆盖掉 width，width 失效 3 若 max-width &lt; width 时，max-width会覆盖掉 width，width 失效 也可以说是，min-width 强于 max-width 强于 width demo height max-height min-height原理估计类似]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS属性-animation]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E5%B1%9E%E6%80%A7-animation%2F</url>
    <content type="text"><![CDATA[前端学习笔记，仅供复习参考使用，若有不足之处请在评论区指出！谢谢！]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS属性-background]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E5%B1%9E%E6%80%A7-background%2F</url>
    <content type="text"><![CDATA[前端学习笔记，仅供复习参考使用，若有不足之处请在评论区指出！谢谢！]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS响应式]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E5%93%8D%E5%BA%94%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前端学习笔记，仅供复习参考使用，若有不足之处请在评论区指出！谢谢！]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS媒体查询]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[前端学习笔记，仅供复习参考使用，若有不足之处请在评论区指出！谢谢！]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS自适应]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[前端学习笔记，仅供复习参考使用，若有不足之处请在评论区指出！谢谢！]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS居中]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[居中肯定是针对子元素来说的，子元素才能居中 父容器建议都使用块级元素，不要用内联元素做包裹器。 水平居中相对简单，但是垂直居中的方法千奇百怪。 水平居中。水平居中在布局中经常使用。要考虑：子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。下面进行分析： child是块级元素child宽度不确定 .child{margin:0 20px;} demo1 demo2 显然块级子元素的宽度就会自适应 child 宽度固定 .child{margin:0 auto;} demo1 demo2 child是inline元素给父元素加 .parent{text-align:center;} demo 垂直居中(7种方法) 垂直居中的要点就是一定不要给父元素加 固定死高度，加了固定高度又要想实现里面内容垂直居中就是给自己找麻烦。不给父元素加固定高度，实现里面内容垂直居中很容易。Good idea是先把里面child元素的内容和样式加好，再用padding撑起你要想要的父元素的高度，这样一来就实现了自然的垂直居中。因为不管child元素的高度是否固定，通过给父元素加上下相等的padding，就能实现child元素垂直居中。 实现子元素垂直居中，父元素默认为 块级元素。包裹器嘛自然是块级。 不固定死父容器高度时： 需求：多个 计算高度不相等 的 行内元素(inline)且需要一行显示的(文字设置了不同字体大小导致计算出来的高度不一样，或者 img设置了宽高属性，内联元素是不能设置宽高的，所以内联元素的宽高是最后计算出来的)， 方法：要实现它们都在父容器中垂直居中，分别给 行内元素身上加 vertical-align: middle；则它们都会在父容器中垂直居中，注意当 span （通常span内是文字）和 img 共存时，只需要设置 图片 vertical-align: middle。 纯文字 demo1 demo2 文字+图片 demo3 这种情况下，父容器的高度是被行内元素撑开的，可以通过增加上下padding来增加父容器的总高度。 demo3 中，右边的 图片 和 span 在一个 div 内，因为右浮，显示同 inline-block 元素一样，而 在div内，图片居左，文字居右的布局，是因为 span 设置了 最小宽度 和 text-align: right;，只要 span内 文字长度 不超出 span 的 min-width，则 div 布局始终都是 图片左对齐，文字右对齐。 需求：多个块级元素高度不同（不是写死高度，是计算出来的高度），需要同一行显示，并且在父容器中垂直居中。 多个块级元素同一行显示需要给子元素添加浮动。实现在父容器中垂直居中建议的方法是给这些块级子元素加padding，让块级子元素一样高（这个的前提是这些块级子元素都没有写死高度），显然这时块级子元素就已经垂直居中了。原理是元素的盒模型是border-box时，元素的上下padding也算作高度的一部分。 demo1 demo2 demo2开发中经常遇见 固定死父容器高度时： 工作中一定要避免这种情况发生。先固定外容器，再实现内居中，这不是好的idea，通常要用更多的代码解决这个麻烦。 解决办法有： IE浏览器 用 table/div(table)，代码兼容性强；Chrome浏览器 和 手机 使用flex布局实现垂直居中，代码简单。flex布局是通用布局。 需求：父元素高度确定，子元素为单行内联文本，实现所有子元素居中 解决办法：设置父元素的height等于行高line-height，甚至在设置了父容器的line-height后，可以去掉父容器的高度。 demo1 demo2 需求：父容器高度确定，子元素为多行内联文本，实现所有元素居中。 解决办法：设置父元素的display:table-cell或inline-block，再设置vertical-align:middle; demo 待补充！ 相关链接： 博客 博客 阮一峰的博客——flex语法]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用http-server]]></title>
    <url>%2F2019%2F08%2F29%2F%E4%BD%BF%E7%94%A8http-server%2F</url>
    <content type="text"><![CDATA[http-server在此补充一个一直遇到的问题，我一直都是用file://打开我的html文件，以至于根本没有http请求和响应。因为file:协议是不可以的。然后回顾 node.js server 的课程有提到有个人做了个 http-server 可以直接在命令行做测试还是免费的，之前不是很理解，然后上网上找了份详细的教程看，有点理解了。按照教程（6. Node.js Server）做了。 进入项目文件夹下 ，该文件夹下有 xxx.html http-server . -c-1 开服务器 google的地址栏里直接输入 http://localhost:8080/xxx.html就能预览我的 xxx.html文件了 默认是打开index.html 注意这时是用http:协议而不是file:协议，我就能查看http请求和http响应了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[给内联元素设置padding很危险]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%BB%99%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E8%AE%BE%E7%BD%AEpadding%E5%BE%88%E5%8D%B1%E9%99%A9%2F</url>
    <content type="text"><![CDATA[内联元素设置左右margin是无效的，虽然设置内联元素的padding是有效的，但是设置内联元素的上下padding效果是不符合预期的，在其外加一个父容器(块级或者内联)，给内联元素设置上下padding，当padding大于一定值，内联元素的上下padding就会超出父容器，用开发者工具调式能看见，此时发现内联元素的内容也不垂直居中显示了。 demo demo demo3 上面演示的3个demo都是父子都是span,将 父span 改成 父div 也是一样的。 总之，给内联元素加上下padding是很危险的，不知道什么时候就超出父容器了，内部内容也不垂直居中显示了。 内联元素内部文本默认就是水平垂直居中显示的，不要设置 内联元素的上下 padding 和 上下 margin。可以使用内联元素的左右 margin 和 左右 padding 。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS开发经验与总结]]></title>
    <url>%2F2019%2F08%2F29%2FCSS%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[开发中常用CSS总结 行内元素必须设置 display: inline-block,才能设置宽高，包括 高宽，最大高宽 和 最小高宽 html 标签 和 body 标签 默认高度为 0 ，因为是块级标签，因此 默认宽度是屏幕宽度。但是 给 html 标签 或者 body 标签 设置 背景色，背景色会填充 整个屏幕。demo demo2 。若同时 给 html 和 body 设置背景色，则 html 背景色 会覆盖 body 背景色。demo3。 给 html 标签 设置 height: 100% / 100vh; ，则 html 标签 和 屏幕一样高 ，body 不会继承 html 的高度。demo 。此时继续给 body设置 height: 100% / 100vh;，那么 body 也和 屏幕 一样高。demo。或者 单独给 body设置 height:100vh;，body 也和 屏幕 一样高。demo demo2 首页内容居中 demo div, span 标签没有默认的样式，其他的标签都有默认的样式。我们可以用开发者工具来查看某标签的默认样式,在浏览器界面-右键-检查-Elements。 浏览器默认字体大小是16px。 用开发者工具调试.html文件，直接改直接就能看到结果！ 当你不知道一个 [CSS属性]的取值时，就去查MDN, google [关键词 MDN]，上面还有很多例子供你学习，但是作为一个工程师，还是直接练出来比较适合我们。所以CSS3根本不用背。我们只要能实现我们的功能就可以了，会英文和工具最好，记太多也记不住，半查半蒙。 不同系统渲染出来的字体颜色是有差别的。 css样式优先级：用户写的样式 &gt; 浏览器的默认样式 &gt; 标签自己默认的颜色样式 样式继承：当子元素有相同样式的时候，我们 把这些样式写在 父亲或者爷爷 元素上，那么 子元素 就会继承 长辈的样式，从而简化CSS代码，注意不是所有样式都能继承。 浏览器会把标签之间的所有的空格换行都归结为一个空格。例如我们为了好看总是给标签换行，因此两个span标签之间是有空格的，只不我们肉眼看不见，只需要把两个span标签挨在一块写，就能消除空格。但是如果你是不需要空格那么大的距离，而两个字之间有需要保持一定的像素，可以通过加margin-right实现。 选择器过于简单，可能会影响后面的样式 每个标签都有一个盒子模型，可打开开发者工具查看 内联元素的高度不可测。给内联元素设置宽高会默认失效，设置line-height也会失效。设置padding生效。设置左右margin生效，设置上下margin不生效。设置边框、背景、文字颜色都生效。值得注意的是内联元素内的直接文本应该是上下左右都是居中的，也就是在开发过程中，不存在设置内联元素里的直接文本居中需求。建议不要span内包裹文字同时又包裹一个span，不利于写样式。 当要实现左右两行字的中心线平齐的时候，我们只需要左右两边的字 高度相等，文字处于中间，就这两个话就很值得去亲身实践一下，第一高度相等，意味者 左右两边的祖先标签盒子模型（这个需要判断）的高度是相等的，也就是上下的padding、border、margin再加上里面元素的高度（它的所有后代）才是这个祖宗标签盒子的高度，将光标移到对应的祖宗标签处就能看到浏览器自动计算出来的高度，而左右两边的祖宗必须是同一级的，比如都是爷爷或者他们只有body这个父亲形如这种。第二，文字处于中间，那么**最里层的孙子标签的上下padding、border、margin若有值则必须相等，字方可处于中间，否则偏上偏下，偏左偏右也是同理。有了这两步，左右两部分的中心线就出在同一水平线上了。 介绍一种手法，写CSS样式的时候，从内到外写，先写里面，看最后宽度和高度差多少，最后用padding撑起来，从而保持了整个盒子的宽度和高度。 CSS改bug的时候是环环相扣的，你修复了一个问题，就可能引发另一个问题。修改bug的时候要冷静。 新手容易犯的错误，在实际开发中，不到迫不得已，width和height能不写就不写，写了就很容易出bug。因为只要需求一变，你一改就是bug，所以我们最好采取一种通用的容错率比较高的方法，比如子元素超出父元素。 加阴影box-shadow，元素看起来更立体google:css shadow generator,调样式，复制现成的样式代码。 加动画transition: all 0.3s;给所有变化 transform加入过渡动画和过渡时间。 加鼠标悬停手指点击形状。cursor: pointer; border 调试大法。加border进行调试，不然看不来标签在哪里。或者 background 加背景颜色调试大法 配套使用。当设置display: inline-block;需要加上vertical-align: top;来去除底层多出的空间。？？？？ 设置背景图片：background-image: url(../img/girl.jpg) 设置背景图片水平垂直居中：background-position: center center; 设置背景图片按比例缩放：background-size: cover 渐变色，调元素的线性渐变色，google:css linear-gradient generator,调样式，复制现成的样式代码。 工具 线性渐变代码生成器 ,写CSS就是会很多工具，不然有时候=代码都自己写就很麻烦。 伪元素 不是元素，可以看做一个span。伪元素默认是inline元素。常常使用 selector::before selector::after 伪元素的用法1： 使用 selector::after 伪元素清除浮动 demo 伪元素的用法2： 给 元素 之前 或者 之后 加内容。demo 伪元素用法3： before 和 after伪元素都可以代替 div ，通过设置 伪元素 display: block，此时伪元素就可以当一个块级元素看待，独占一行。局限是伪元素里不能再有伪元素。 伪类是一个分号，如:hover :nth-child,它是不存在的，表示标签的某种状态。伪元素是两个分号，如： ::before ::after,伪元素是真实存在的，但是不是一个元素，它可以替代一个元素的作用。 添加动画。 创建动画序列，需要使用animation属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes规则实现。 CSS有很多杂碎的东西，要多去试就能学到更多的东西。 对页面某一块，先实现内容，再加CSS样式，即先html，后CSS。 从里往外写CSS样式，最后加padding,margin撑起来。 CSS样式复用 选择器,选择器{CSS样式} id是唯一标识一个标签的，class是一个大类。 状态机，js切换左中右三种状态, css 负责样式 display:inline-block; vertical-align: top;是配套使用的，设置了inline-block，就要同时设置后者。inlne-block可以让标签宽度等于文档流元素，另起一行。 CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的在父容器内的垂直对齐方式。不能使用它垂直对齐块级元素。注意是给 子行内元素设置 vertical-align 属性 vertical-align属性可被用于两种环境： 元素盒模型与其行内元素容器垂直对齐。 例如，用于垂直对齐一行文本的内的图片，通常 垂直对齐表格单元内容 不怎么接触表格以后接触到再展开]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F28%2F%E5%AE%9E%E6%88%98%EF%BC%9Acnode%E7%A4%BE%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[title: cnode社区实战comments: truedate: 2019-08-28 10:27:28updated:tags: 项目achives: cnode社区 项目主要是依赖cnode社区提供的API实现的。 使用vue 开发项目，就是写一个个组件，将组件”堆在一起”。就是应用了。 1 cnode社区的基本构架该项目包括组件： Header 头部 PostList 列表 Article 文章的详情页 发两个请求，分别获取 文章详情 和 文章作者信息 UserInfo 用户个人信息 Psgination 分页组件 2 开始实战2.1 Header组件 HTML ： img ul li div CSS样式 和 布局 ：浮动布局&amp;清除浮动 | padding垂直居中 | max-width+margin：0 auto 水平居中 JS ： 无 2.2 PostList组件 ES6 : Promise 的串联调用，首页，在页面挂载之前，获取主题列表，同时根据 每个主题文章 id 再次发起请求，获取文章最新评论者头像。感觉开销有点大，后期想想怎么优化 vue技术 axios API接口：https://cnodejs.org/api/v1/topics 获取帖子列表可以加参数 limit page拿到的参数分析 res.data[i].xxx 头像：author.avatar_url 回复量/浏览量 ：reply_count/visit_count 帖子的标题：title 需要对时间使用过滤器： 时间：last_reply_at 帖子分类： top: 代表是否置顶，绿色强调 good: 代表是否精华，绿色强调 tab 参数是表示除了置顶和精华之外的其余分区 –­tab = ‘share’ 分享 ­–ask 问答 ­–job 招聘 – dev 客户端测试 注： 帖子分类只能有一个 2.3 Article组件主题详情 页 API https://cnodejs.org/api/v1/topic/ + 帖子ID 卡壳1渲染 主题详情页内容 用 v-html 指令 当编辑器使用的是markdown时，我们前端接收到的数据是类似这种的： 图 由于 内容是 markdown 语法，即使使用了 v-html 指令，图片还是会超出页面，因此 要引入 markdown 的 css 引入外部样式 必须 去掉 style 标签 上的 scoped 1234&lt;style&gt;/* 引入外部 css 样式文件 */@import url('../assets/markdown-github.css');&lt;/style&gt; 上面代码中 url 中的 是 外部 css 样式文件路径。 或者 npm 下载 1&lt;p class="markdown-body" v-html="reply.content"&gt;&lt;/p&gt; 1&lt;main class=&quot;markdown-body&quot; v-html=&quot;art.content&quot;&gt;&lt;/main&gt; 卡壳2首页 loading 动画居中， 参考 固定高度父容器 实现子元素水平垂直居中 卡壳3不熟悉 v-router 只要是点击 要 跳转的 都用 router-link 包裹，router-link 会被渲染成一个a 标签 路由 可以传递参数。 在 路由文件里 定义路由 通过 router-link 的 to 属性值 里 的 name 选项值 找到 对应的 路由，然后跳转到该路由设置的组件。 卡壳4v-for(value, key) 拿索引 2.4 USerinfo组件API https://cnodejs.org/api/v1/user/ + loginname 用户详情页 细节： 路由跳转问题描述 http://localhost:8081/#/userinfo/aojiaotage–用户列表页 =》》》不同路由跳转 http://localhost:8081/#/topic/5afe26730a36e5312d6ed257&amp;author=aojiaotage 上面代码中很明显发生了路由跳转， 由 /userinfo/aojiaotage 跳转到 /topic/5afe26730a36e5312d6ed257&amp;author=aojiaotage，这显然是两个 不同的 路由（path 不同），vue.js 可以检测到。 但是 在同一个路由跳转，vue 就检测不到了。如下面的例子： http://localhost:8081/#/topic/5afe26730a36e5312d6ed257&amp;author=aojiaotage a 页面 —­》》》 同一路由跳转 http://localhost:8081/#/topic/57ff46f5fdf3bd3d651185bf&amp;author=aojiaotage b 页面 上面代码中 ，在 a 页面 点击 链接 ，不能跳转到 b 页面，原因是 a 页面 和 b 页面 实际上走的是同一个路由 { name: post_content, path: &#39;/topic/:id &amp; author=:name &#39;}，可以看到 两个 页面 的 path 是相同的，只是 给路由传递的 id 参数 不同。 解决办法vue.js 给我们提供了专门检测路由变化的方法。需要使用到 watch 选项。 123456watch: &#123; // 检测到 $route 发生变化，就执行函数。 '$route': function (to,from) &#123; this.getArticle() &#125;&#125; 上面的 $route 就是 this.$route，当前 实例的路由。也就是说，监测到了当前路由发生变化，就会重新执行获取文章的方法this.getArticle(), 此时axios 的 get路径 就会变成 与 要跳转的路由 对应的路径。 但是 页面组件 里 使用的组件 依旧不会渲染，传给组件的值变化了，但是组件自己监听不到。解决办法是 在 该复用组件里 也加一个watch 监听，如 1234567props: ["title", "lists"],watch: &#123; 'lists': function() &#123; console.log('变化') this.limitLists(); &#125; &#125;, 当传进来组件的lists变化时， 再次执行一次limitLists方法，该方法中使用了 lists数据，因此重新计算，重新渲染组件页面中的使用的数据。 2.4 Panel 组件SlideBar 可以看作 是 组件复用 插槽具名插槽 路由命名路由 命名视图 及 嵌套 2.5 分页组件使用浮动 清除行内元素间隙 https://blog.csdn.net/kouwoo/article/details/41743669 注意清除 button 默认样式 123button:focus &#123; outline: none;&#125; 2.5 项目包括页面通过路由，分为以下几个页面： 首页 API接口：https://cnodejs.org/api/v1/topics 获取帖子列表 文章详情页 API接口 https://cnodejs.org/api/v1/topic/ + 帖子ID 用户详情页 API接口 https://cnodejs.org/api/v1/user/ + loginname 3 项目中易错点3.1 动态绑定属性123456789101112&lt;ul&gt; &lt;li v-for="list in lists"&gt; &lt;img :src="list.author.avatar_url" /&gt; &lt;span&gt; &lt;span class="reply_count"&gt;&#123;&#123;list.reply_count&#125;&#125;&lt;/span&gt; /&#123;&#123; list.visit_count &#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;list.title&#125;&#125;&lt;/span&gt; &lt;img src="list.author.avatar_url" /&gt; &lt;!-- &lt;span&gt;&#123;&#123;last_reply_at|formatTime&#125;&#125;&lt;/span&gt; --&gt; &lt;/li&gt;&lt;/ul&gt; 上面代码中动态绑定img标签的src属性，要加v-bind指令 3.2 处理时间戳： —分钟前 –天前时间戳显示为多少分钟前，多少天前的JS处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** 时间戳显示为多少分钟前，多少天前的处理** eg.** console.log(dateDiff(1411111111111)); // 2014年09月19日** console.log(dateDiff(1481111111111)); // 9月前** console.log(dateDiff(1499911111111)); // 2月前** console.log(dateDiff(1503211111111)); // 3周前** console.log(dateDiff(1505283100802)); // 1分钟前*/var dateDiff = function (timestamp) &#123; // 补全为13位 var arrTimestamp = (timestamp + '').split(''); for (var start = 0; start &lt; 13; start++) &#123; if (!arrTimestamp[start]) &#123; arrTimestamp[start] = '0'; &#125; &#125; timestamp = arrTimestamp.join('') * 1; var minute = 1000 * 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var now = new Date().getTime(); var diffValue = now - timestamp; // 如果本地时间反而小于变量时间 if (diffValue &lt; 0) &#123; return '不久前'; &#125; // 计算差异时间的量级 var monthC = diffValue / month; var weekC = diffValue / (7 * day); var dayC = diffValue / day; var hourC = diffValue / hour; var minC = diffValue / minute; // 数值补0方法 var zero = function (value) &#123; if (value &lt; 10) &#123; return '0' + value; &#125; return value; &#125;; // 使用 if (monthC &gt; 12) &#123; // 超过1年，直接显示年月日 return (function () &#123; var date = new Date(timestamp); return date.getFullYear() + '年' + zero(date.getMonth() + 1) + '月' + zero(date.getDate()) + '日'; &#125;)(); &#125; else if (monthC &gt;= 1) &#123; return parseInt(monthC) + "月前"; &#125; else if (weekC &gt;= 1) &#123; return parseInt(weekC) + "周前"; &#125; else if (dayC &gt;= 1) &#123; return parseInt(dayC) + "天前"; &#125; else if (hourC &gt;= 1) &#123; return parseInt(hourC) + "小时前"; &#125; else if (minC &gt;= 1) &#123; return parseInt(minC) + "分钟前"; &#125; return '刚刚';&#125;; 上面摘自博客，改造成如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263formateReplyTime(timestamp) &#123; console.log("formateReplyTime过滤器执行"); // 单位 ms let second = 1000; let minute = 1000 * 60; let hour = minute * 60; let day = hour * 24; let halfamonth = day * 15; let month = day * 30; let now = Date.now(); timestamp = new Date(timestamp); let diffValue = now - timestamp; // 如果本地时间反而小于变量时间 if (diffValue &lt; 0) &#123; return "刚刚"; &#125; // 计算差异时间的量级 let monthC = diffValue / month; let weekC = diffValue / (7 * day); let dayC = diffValue / day; let hourC = diffValue / hour; let minC = diffValue / minute; let secondC = diffValue / second; // 数值补0方法 let zero = function(value) &#123; if (value &lt; 10) &#123; return "0" + value; &#125; return value; &#125;; // 使用 if (monthC &gt; 12) &#123; // 超过1年，直接显示年月日 let date = new Date(timestamp); return ( date.getFullYear() + "年" + zero(date.getMonth() + 1) + "月" + zero(date.getDate()) + "日" ); &#125; else if (monthC &gt;= 1) &#123; return parseInt(monthC) + "月前"; &#125; else if (weekC &gt;= 1) &#123; return parseInt(weekC) + "周前"; &#125; else if (dayC &gt;= 1) &#123; return parseInt(dayC) + "天前"; &#125; else if (hourC &gt;= 1) &#123; return parseInt(hourC) + "小时前"; &#125; else if (minC &gt;= 1) &#123; return parseInt(minC) + "分钟前"; &#125; else if (secondC &gt;= 1) &#123; return parseInt(secondC) + "秒前"; &#125; else &#123; return "刚刚"; &#125; &#125; 3.3 需求： 给计算属性传参 方法：使用闭包3.3.1先演示错误方法12345678910111213141516171819202122232425262728&lt;template&gt; &lt;!-- 其他代码 --&gt;&lt;span :style=&quot;&#123; background: bg(list) &#125;&quot; &gt;&#123;&#123; topbarItemText(list) &#125;&#125;&lt;/span&gt;&lt;/template&gt; export default &#123; data() &#123; return &#123; msg: &apos;我是组件啊，不是你给计算属性传的值&apos; &#125; &#125;, computed: &#123; bg(list) &#123; console.log(list.msg); // &quot;我是组件啊，不是你给计算属性传的值&quot; if (list.top || list.good) &#123; return &quot;#80bd01&quot;; &#125; else if (list.tab === &quot;share&quot; || list.tab === &quot;ask&quot;) &#123; return &quot;#e5e5e5&quot;; &#125; else &#123; this.topbarItemIsShow = false; &#125; &#125;&#125; 上面代码中 bg是计算属性，我们需要给计算属性 bg 传 参数，bg(list) 这样写 是不会报错的。关键在 计算属性的写法， computed 选项里的 计算属性函数 的 第一个参数 默认是 computed 选项 所在的 vue 实例，而不是 你以为的向 计算属性函数里传递的参数。因此 计算属性 bg 里的 list 实际上 是 vue实例。从而 你想对 传入参数 对的一切操作都没用，甚至可能报错。 computed 选项里的 计算属性函数 并不能得到 你以为传入的参数，不管你传几个。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;!-- 其他代码 --&gt;&lt;span :style=&quot;&#123; background: bg(list, msg) &#125;&quot; &gt;&#123;&#123; topbarItemText(list) &#125;&#125;&lt;/span&gt;&lt;/template&gt; export default &#123; data() &#123; return &#123; msg: &apos;我是组件啊，不是你给计算属性传的值&apos; &#125; &#125;, computed: &#123; bg(list, m) &#123; console.log(m); // undefined if (list.top || list.good) &#123; return &quot;#80bd01&quot;; &#125; else if (list.tab === &quot;share&quot; || list.tab === &quot;ask&quot;) &#123; return &quot;#e5e5e5&quot;; &#125; else &#123; this.topbarItemIsShow = false; &#125; &#125;&#125; 上面代码中 我们可以看到 msg 还是没有传入 计算属性bg，计算属性函数 bg 第二个参数 在控制台输出 undefined。实际上我们可以打出 计算属性函数 bg 里的 arguments 对象，发现 始终都 只传入了第一个并且是唯一一个参数，就是当前vue实例。 3.3.2使用闭包传参1234567891011121314151617181920212223242526&lt;template&gt; &lt;!-- 正确传值操作 --&gt;&lt;span :style=&quot;&#123; background: bg(list) &#125;&quot; &gt;&#123;&#123; topbarItemText(list) &#125;&#125;&lt;/span&gt;&lt;/template&gt; export default &#123; computed: &#123; bg() &#123; return function(list) &#123; // list 就是 给计算属性传进来的参数，因此下面的操作得以执行 if (list.top || list.good) &#123; return &quot;#80bd01&quot;; &#125; else if (list.tab === &quot;share&quot; || list.tab === &quot;ask&quot;) &#123; return &quot;#e5e5e5&quot;; &#125; else &#123; this.topbarItemIsShow = false; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243computed: &#123; bg() &#123; console.log("bg计算属性执行了"); return function(list) &#123; console.log('是我执行了') if (list.top || list.good) &#123; return "#80bd01"; &#125; else if (list.tab === "share" || list.tab === "ask") &#123; return "#e5e5e5"; &#125; else &#123; this.topbarItemIsShow = false; &#125; &#125;; &#125;, color() &#123; console.log("color计算属性执行了"); return function(list) &#123; if (list.top || list.good) &#123; return "#fff"; &#125; else if (list.tab === "share" || list.tab === "ask") &#123; return "#999"; &#125; else &#123; this.topbarItemIsShow = false; &#125; &#125;; &#125;, topbarItemText() &#123; console.log("topbarItemText计算属性执行了"); return function(list) &#123; if (list.top) &#123; return "置顶"; &#125; else if (list.good) &#123; return "精华"; &#125; else if (list.tab === "share") &#123; return "分享"; &#125; else if (list.tab === "ask") &#123; return "问答"; &#125; else &#123; return ""; &#125; &#125;; &#125; &#125; 上面是 cnode 项目中 使用 闭包 给 计算属性 传参 的应用。 使用闭包给 计算属性 传参 关键是 计算属性函数的 写法 1234567computed: &#123; bg() &#123; return function(list) &#123; // list 是成功传入的参数 &#125; &#125;&#125; 3.4 该用 方法 代替 计算属性将一个函数定义为 方法 和 计算属性 ，两种方式的最终结果是完全相同的。区别是 是否使用了缓存。 在本项目中 bg 和 color 函数里的操作 就是 判断值 ，开销很小，不需要缓存技术，因此使用 将函数定义为 方法就行。 3.5 避免没有数据就显示解析问题描述及分析在 beforeMount 钩子函数里 就发出请求 获取页面数据，由于请求是异步的，有时候时间过长，数据还没有请求回来，vue实例已经挂载到 DOM 上，即 mounted 钩子函数已经执行了，然后就会用 data选项 中的初始数据 渲染页面，以及按顺序执行页面中的计算属性、方法、过滤器，而页面中的数据 有一些依赖于请求返回的数据，此时请求还未返回，就会报错，报 xxx 找不到。等 请求返回数据后，将会 用拿到的数据再次渲染页面。 这个过程很快，虽然用户感觉不到，但是 控制台确实报错。 解决办法在获取完页面所需数据之前 先用 v-if 移除页面，或者说不显示页面，等获取完数据后，再用 v-if 显示页面，此时渲染页面用的就都是返回的数据，就不会报错了。 123456789101112131415161718192021222324252627282930&lt;script&gt;export default &#123; data() &#123; return &#123; getArticleIsFinish: false // 默认移除页面 &#125;; &#125;, methods: &#123; getArticle() &#123; this.$http .get("https://cnodejs.org/api/v1/topic/5d5a723ed53e9171e98a92db") .then(res =&gt; &#123; this.art = res.data.data; console.log("获取数据结束"); this.getArticleIsFinish = true; // 数据获取结束后 再显示页面 &#125;) .catch(err =&gt; &#123; alert(err); &#125;); &#125; &#125;, beforeMount() &#123; console.log("beforeMount"); this.getArticle(); // 调用获取数据的方法 &#125;, mounted() &#123; console.log("mounted"); &#125;&#125;;&lt;/script&gt; 上面代码中，同步操作才是 按 beforeMount mounted 钩子执行顺序，钩子中的异步操作会加到事件队列中。 细节更完善 –添加loading 动画当网速很慢的时候，发请求获取数据就需要一段时间，这时候我们总不能让页面空着吧，因此 可以用 一个 布尔变量 控制 请求数据时 移除 页面 并显示 loading 动画，当请求数据成功后，移除loading 动画，显示页面。 使用了v-if v-else 指令 PostList 组件 1234567891011&lt;template&gt; &lt;div class=&quot;post-list&quot;&gt; &lt;!-- 当列表还没有加载出来显示的loadign动画 --&gt; &lt;div class=&quot;loading&quot; v-if=&quot;isShowLoading&quot;&gt; &lt;img src=&quot;../assets/loading.gif&quot; /&gt; &lt;/div&gt; &lt;main v-else&gt; &lt;!-- 以下是页面内容 --&gt; &lt;/main&gt; &lt;/div&gt;&lt;/template&gt; Article 组件 12345678910&lt;template&gt; &lt;div class=&quot;Article&quot; :class=&quot;&#123; &apos;showLoading&apos;: isShowLoading &#125;&quot;&gt; &lt;div class=&quot;loading&quot; v-if=&quot;isShowLoading&quot;&gt; &lt;img src=&quot;../assets/loading.gif&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;main&quot; v-else&gt; &lt;!-- 以下是页面内容 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js 代码 123456789101112131415161718192021222324252627282930&lt;script&gt;export default &#123; data() &#123; return &#123; isShowLoading: true // 默认移除页面，加载动画 &#125;; &#125;, methods: &#123; getArticle() &#123; this.$http .get("https://cnodejs.org/api/v1/topic/5d5a723ed53e9171e98a92db") .then(res =&gt; &#123; this.art = res.data.data; console.log("获取数据结束"); this.isShowLoading = false; // 数据获取结束后 移除动画，显示页面 &#125;) .catch(err =&gt; &#123; alert(err); &#125;); &#125; &#125;, beforeMount() &#123; console.log("beforeMount"); this.getArticle(); // 调用获取数据的方法 &#125;, mounted() &#123; console.log("mounted"); &#125;&#125;;&lt;/script&gt; 3.6 路径拼接没有考虑到12345678910111213getArticle() &#123; this.$http .get(`https://cnodejs.org/api/v1/topic/$&#123;this.$route.params.id&#125;`) .then(res =&gt; &#123; console.log(res.data.data); this.art = res.data.data; console.log("获取数据结束"); this.isShowLoading = false; &#125;) .catch(err =&gt; &#123; alert(err); &#125;); &#125; Article 组件里，get 方法参数 是 获取主题详情页的url ，通过 文章 id 拿到 3.7 router-link 上添加点击事件失效 给router-link 标签添加事件@click 、@mouseover等无效的情况 解决办法是： 根据Vue2.0官方文档关于父子组件通讯的原则，父组件通过prop传递数据给子组件，子组件触发事件给父组件。但父组件想在子组件上监听自己的click的话，需要加上native修饰符。 所以如果在想要在router-link上添加事件的话需要`@click.native`这样写 https://www.cnblogs.com/xianhuiwang/p/6726688.html 4 工具分析页面返回的JSON数据：工具 5 性能优化5.1 图片优化使用 loading.svg 代替 loading.gif ，由 52.7KB 降为 504 Byte(字节)，src文件由 105KB 降为53.6KB。通过开发者工具查看该图片资源加载事件，时间由 47.26 ms 降低为 0.27ms，竟然缩短了 约175倍。 组件复用Loading.vue 异步数据加载回来显示的动画 定义全局方法 博客 不用下面这个，改成 定义在单独的文件内，再导入。 将多个页面使用到的方法定义为全局函数，方法是： 1 定义全局变量模块，全局模块里是全局通用函数 和 全局状态，导出全局模块。 2 在 main.js 导入模块 ，并将 通用函数 挂载到 vue 实例上，使得它成为 该项目所有 vue 实例 都有 的 方法 。通过 this.xxx访问。 src/components/Global.vue 12345678&lt;script&gt;export default &#123; methods: &#123; formatTime(timestamp) &#123; // code &#125; &#125;;&lt;/script&gt; src/main.js 1234567891011121314151617181920// 在 main.js 中，全局引入axiosimport Vue from 'vue'import App from './App'import router from './router/index'import axios from 'axios'import global from "./components/Global"; //引用全局模块进来Vue.config.productionTip = false// 将页面都要用到的方法挂载到 vue 实例，成为全局方法Vue.prototype.$http = axiosVue.prototype.formatTime = global.methods.formatTimenew Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 有个疑惑： 为什么是 global.methods.formatTime 而不是 global.formatTime 用v-for循环 实现 导航栏的点击切换样式 CSS代码优化https://segmentfault.com/q/1010000003741434 https://www.cnblogs.com/dangjian/p/4299325.html 懒加载 https://www.jianshu.com/p/e86c61468285 没有解决的问题router-link 有自带一点内 padding样式，导致 上下相同padding 并不居中。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2019%2F08%2F27%2Fvuex%2F</url>
    <content type="text"><![CDATA[如果不用 Vuex ，也能完成项目，说明可能不需要用到 Vuex， 大型项目才有必要使用Vuex Vuex 的用法管理状态，共享数据 vuex 的 store 用法我们之前学过 父子组件之间通信，非父子组件之间通信，但是项目中组件太多，不可能建很多父组件 因此 store 就是为了让 各个组件之间 互通数据。 在所有页面中都可以拿到 store 中的数据。store 中的数据 是全局数据。 vuex的相关操作和核心用法创建状态仓库传入的对象中的选项有传入对象里的选项 最后会成为 store实例 的选项(属性)，也就是说以下全是store对象的属性 – state 选项对象中定义的是全局数据和状态 – mutations 选项里 定义的是状态改变函数。mutation 改变、变化。状态改变函数中直接传入 state 参数，可以直接对全局状态操作。在状态改变函数中使用： state.xxx – actions 选项对象里 定义一些方法。这些方法传入的是 context 上下文对象，只能对mutations 里的状态改变函数直接操作。 在actions方法中： context.commit(‘fnName’) – getters 选项对象 里定义一些方法。这些方法通常对全局状态做一些处理。比如做减法时，减到0就不再继续ji 最后在methods方法调用 state 里的全局状态：this.$store.state.xxx 最后在methods方法调用 mutations 的状态改变函数： this.$store.commit(&#39;状态改变函数名&#39;) 最后在methods方法调用 actions 中的方法： this.$store.dispatch(&#39;方法名&#39;) 最后在computed方法调用 getters中的方法： this.$store.getters.函数名 明确 mutations 和 actions 的 两者中的方法一些区别 传入的参数 操作的对象 调用函数的方法不同 mutations 中只能有同步操作。actions 中只能有异步操作。 vuex状态管理的流程view———­&gt;actions———–&gt;mutations—–&gt;state————­&gt;view 其中 view 是视图，actions 不是必须的，但若需要异步操作则是必须的。其中直接操作全局状态的是mutations里的方法。当全局状态改变以后就更新视图。 总结vuex 和 vue-router 这两个插件是vue中最重要的插件，学习时需要多注意 开发时要注意 组件化 和 模块化。例如 router 和 store 应单独建立目录，目录下 有 index.js。 index.js 文件中将代码输出为一个模块，则在其他文件中就可以引入该模块。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2019%2F08%2F27%2Fvue-router%2F</url>
    <content type="text"><![CDATA[路由 vue-router的基本用法index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;title&gt;vueapp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt; main.js 12345678910111213141516171819202122232425262728// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from 'vue-router'import helloWorld from './components/HelloWorld'console.log('main.js执行')Vue.config.productionTip = falseVue.use(router)// 配置vue-routervar rt = new router(&#123; routes: [&#123; path: '/hello', component: helloWorld &#125;]&#125;)/* eslint-disable no-new */// 生成Vue实例new Vue(&#123; el: '#app', router: rt, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) App.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;ap&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view&gt;123&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;App&apos;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 路由的跳转实例上路由就相当于超链接 通过路由给组件传递参数1.必须在配置路由时，在路由内加入路由对象的name属性，并且 path属性值变为：路径后加/: +传递的参数，如 /xxx/:msg msg 是用来接收参数的。 –router —-index.js 文件内 123456789101112131415// 省略一些代码export default new router(&#123; routes: [ &#123; name: 'helloworld', path: '/helloworld/:worldmsg', component: HelloWorld &#125;, &#123; name: 'helloearth', path: '/helloearth/:earthmsg', component: HellloEarth &#125; ]&#125;) 2.使用路由传递参数代码 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;list&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link :to=&quot;&#123;name: &apos;helloearth&apos;, params: &#123;earthmsg: &apos;地球你好&apos;&#125;&#125;&quot;&gt;HellloEarth&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link :to=&quot;&#123;name: &apos;helloworld&apos;, params: &#123;worldmsg: &apos;世界你好&apos;&#125;&#125;&quot;&gt;HelloWorld&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;list&quot;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 上面代码中值得注意的是，router-link 的 to 属性前要加 :，to 属性值不再是将要跳转的路径，而是一个对象，对象的name属性 与 路由对象 的name属性对应，params 属性 就是路由要传递的 参数对象。 3.在对应组件内使用 $route.params.xxx 接收参数 HelloEarth.vue 文件 123456789101112131415&lt;template&gt; &lt;div class=&quot;earth&quot;&gt; &lt;h1&gt;Hello Earth&lt;/h1&gt; &lt;span&gt;路由传递的参数：&#123;&#123; $route.params.earthmsg &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;HelloEarth&quot;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; HelloWorld.vue 文件 12345678910111213141516&lt;template&gt; &lt;div class=&quot;world&quot;&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;span&gt;路由传递的参数：&#123;&#123; $route.params.worldmsg &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;HelloWorld&quot;&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 其实上面这种方式就相当于：localhost:8080/helloworld/你好世界 Axios 的 get 请求详解get 方法返回的是一个 promise 对象 get 方法第一个参数是 网址，第二个参数是对象 Axios 的 post 请求详解待补充]]></content>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习JavaScript有感]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%AD%A6%E4%B9%A0JavaScript%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[学了一段时间JS，有时候一直处于混论中。理论跟应用我总觉得是有一个明确的联系的，这个联系越发清晰了。以下是根据阮一峰的 JavaScript 教程 和 MDN 来谈的。 首先看 JavaScript 教程 怎么读呢，入门篇、数据类型、运算符、语法专题 这前 4 章 是一定得细看并且弄懂的，可以说是最最最基础的，里面的例子特别地特别地通俗易懂。看的过程自己必须手动敲一下，感受 JS 这门弱类型语言。也要做笔记，脑袋也要尽量去记，虽然很基础基础，但是以后写代码报错很大可能就是因为它们，同时也说明你犯了很低级的错误。 接下来的 3 章呢，可以算是使用JS编程的基础了，注意前 4 章 是 JS 的基础。建议的阅读顺序是，异步操作、面向对象编程、标准库。为什么这么推荐呢，因为 异步操作 这章 首先短，而且里面知识太重要了！！所以这3章一定要理解，并且结合代码理解，一定动手敲，有模糊的地方或者想要更进一步就要看MDN 了。 异步操作 这章 讲了 JS 的单线程、多线程、事件处理机制、异步任务和同步任务。这对你读代码和写代码是非常有用的。尤其是JS 事件循环 能让你知道 哪些 语句先执行，哪些后执行，从而如何书写同步代码 和 异步代码。 面向对象 这张讲了 new 命令、构造函数、实例对象、this值、对象的继承、原型链怎么回事，以后编程天天见，知道多重要了 吧。面向对象编程 是 以后写漂亮代码基础。 标准库 就是 JS这门语言提供 各个原生对象。大部分原生对象可以当构造函数使用。原生对象有 静态方法、实例方法、继承的方法。 这些方法要背下来！太多了，想哭啊！主要搞懂方法的入口参数、返回值，方法原理。因为以后我们编程写的对象就是它们的实例，这些实例对象继承了它们的方法。！这些方法可以看作是 JS这门语言 原生提供给我们处理数据的方法。 其中 String、Array、Object、Function 的方法高频使用。 看完这三章以后，就有 JS中一切都是对象的概念了。原生对象、函数也是对象、接口也是对象、函数运行环境也是对象、接口也是对象，以后我们处理的很多数据也是对象。你也要把数据包装成一个对象。你总是在写对象、解析处理对象、返回对象。对象里面可能就是JS的简单数据类型了，也就是前四章的内容。 学前面 7 章 的内容，可以说只是在学 JS 这门语言的数据类型、处理数据的方法 和 编程。跟网页没有关系。这只是一门语言。接下来的 DOM、事件、浏览器模型 则是 用JS 操作网页的基础。也就是说 JS这门语言终于 跟 网页有关系了。 DOM 是 JS 脚本语言 操作网页的接口。DOM的作用是将网页转为一个 JavaScript 对象。有点映射的感觉，网页经过 DOM 变成 JS对象，对象 就是 JS的数据类型啊，前面我们学了那么多原生JS方法 就能拿来处理数据，比如：增删改查。也就是说，有了DOM以后，网页元素 === JS对象，操作对象 === 操作网页。不过这种网页元素对象有很多属性 ，静态属性 和 事件监听属性。 事件 是 通信方式。待补充。 浏览器模型 待补充。 这部分内容更进一步，也得看 MDN ，更全面。阮一峰的 JavaScript 教程 应该是结合了个人的理解，他的解读还是很通俗易懂的，可以参考。 以上就是原生JS基础了，找工作时，我们通常可以看到 JD 上写着 要 熟悉JS ，其中字符串、数组方法、对象方法、函数方法问得最多，很显然啊你要处理数据啊肯定要掌握方法，然后JS核心知识 面向对象编程、继承、Promise，为了要写漂亮代码（易读、可维护、独立性）。前面只是考察JS语言掌握程度，实际编程我们除了处理后端给的数据，也要处理处理网页元素对象，这就涉及了DOM、AJAX、JSON。 总结：不难推断出面试重点考察 下面这些知识点： 数组字符串对象函数方法 面向对象编程 继承 原型链 Promise对象 DOM AJAX JSON 以上要很扎实，要多看MDN，多用多敲demo。]]></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-JSON对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-JSON%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-RegExp对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-RegExp%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-Date对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-Date%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Date 对象Date对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。 目录 作为普通函数的用法 构造函数的用法 日期的运算 静态方法 Date.now() Date.parse() Date.UTC() 实例方法 Date.prototype.valueOf() to 类方法 以to开头的方法 get 类方法 以get开头的方法 set 类方法 以set开头的方法 普通函数的用法Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。 1234567Date()// "Fri Aug 30 2019 09:07:30 GMT+0800 (中国标准时间)"typeof Date() // "string"new Date()// Fri Aug 30 2019 09:07:39 GMT+0800 (中国标准时间)typeof new Date() // "object" 注意，即使带有参数，Date作为普通函数使用时，返回的还是当前时间。 12Date(2000, 1, 1)// "Fri Aug 30 2019 09:14:57 GMT+0800 (中国标准时间)" 上面代码说明，无论有没有参数，直接调用Date总是返回当前时间。 总结： 直接调用Date 函数 只会返回 表示当前时间 的字符串。 作为构造函数的用法Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。 1234var today = new Date();dir(tody)//Fri Aug 30 2019 09:09:46 GMT+0800 (中国标准时间)// __proto__: Object Date实例直接求值Date实例有一个独特的地方。其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。 12345678var today = new Date();today// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"// 等同于today.toString()// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)" 上面代码中，today是Date的实例，直接求值等同于调用toString方法。 Date 构造函数 的 参数 及 取值范围作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间 实例对象。 123456789101112// 参数为从 时间零点开始 往后计算的毫秒数new Date(1378218728000)// Tue Sep 03 2013 22:32:08 GMT+0800 (中国标准时间)// 参数为日期字符串 月 日，年new Date('January 6, 2013');// Sun Jan 06 2013 00:00:00 GMT+0800 (中国标准时间)// 参数为多个整数，至少需要 年 月// 代表年、月、日、小时、分钟、秒、毫秒new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (中国标准时间) 关于Date构造函数的参数，有几点说明。 第一点，参数可以是负整数，代表时间零点之前的时间。 12new Date(-1378218728000)// Fri Apr 30 1926 17:27:52 GMT+0800 (CST) 第二点，只要是能被Date.parse()方法解析的字符串，都可以当作参数。 1234567891011new Date('2013-2-15')new Date('2013/2/15')new Date('02/15/2013')new Date('2013-FEB-15')new Date('FEB, 15, 2013')new Date('FEB 15, 2013')new Date('February, 15, 2013')new Date('February 15, 2013')new Date('15 Feb 2013')new Date('15, February, 2013')// Fri Feb 15 2013 00:00:00 GMT+0800 (中国标准时间) 上面多种日期字符串的写法，返回的都是同一个时间。 第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。 12new Date(2013)// Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间) 上面代码中，2013被解释为毫秒数，而不是年份。 12345678new Date(2013, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST) 上面代码中，不管有几个参数，返回的都是2013年1月1日零点。 最后，各个参数的取值范围如下。 年：使用四位数年份，比如2000。如果写成两位数或个位数，则会自动加上1900，即10代表1910年。如果是负数，表示公元前。 月：0表示一月，依次类推，11表示12月。 日：1到31。 小时：0到23。 分钟：0到59。 秒：0到59 毫秒：0到999。 注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。年 和 月 是必须的。 这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。 1234new Date(2013, 15)// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)new Date(2013, 0, 0)// Mon Dec 31 2012 00:00:00 GMT+0800 (CST) 上面代码的第二个例子，日期设为0，就代表上个月的最后一天。 参数还可以使用负数，表示扣去的时间。 123456new Date(2013, -1)// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)new Date(2013, 0, 0)// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)new Date(2013, 0, -1)// Sun Dec 30 2012 00:00:00 GMT+0800 (CST) 上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间。 日期实例对象的运算加法运算减法运算类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。 1234567var d1 = new Date(2000, 2, 1);var d2 = new Date(2000, 3, 1);d2 - d1// 2678400000d2 + d1// "Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 上面代码中，减法运算 预期 是 两个数值运算，因此 两个日期实例对象 会被自动类型转化为 数值，调用的是 实例的 valueOf 方法，返回是以时间零点为基准 对应的毫秒数。加法运算 是 字符串拼接，因此 两个日期实例对象 会被自动类型转化为 字符串，调用的是 实例的 toString 方法，返回对应的日期字符串。 12345678var t1 = new Date()t1 // Fri Aug 30 2019 10:22:24 GMT+0800 (中国标准时间)// 相当于t1.toString() // "Fri Aug 30 2019 10:22:24 GMT+0800 (中国标准时间)"// valueOf 可以将 日期对象 转化为对应的毫秒数t1.valueOf() // 1567131744047 静态方法Date.now() 无参Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。 1Date.now() // 1364026285194 Date.parse()Date.parse方法用来解析日期字符串，返回该时间距离时间零点的毫秒数。该方法参数为字符串，解析成功返回一个数字，解析失败，返回NaN。返回值是 number类型。 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析，请看下面的例子。 123456Date.parse('Aug 9, 1995')Date.parse('January 26, 2011 13:51:50')Date.parse('Mon, 25 Dec 1995 13:30:00 GMT')Date.parse('Mon, 25 Dec 1995 13:30:00 +0430')Date.parse('2011-10-10')Date.parse('2011-10-10T14:48:00') 上面的日期字符串都可以解析。 如果解析失败，返回NaN。 1Date.parse('xxx') // NaN Date.UTC()Date.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点的毫秒数。 123456// 格式Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])// 用法Date.UTC(2011, 0, 1, 2, 3, 4, 567)// 1293847384567 该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。 总结三个静态方法 都是返回 时间毫秒数，日期实例对象的 valueOf 方法 也可以返回时间毫秒数。Date 构造函数返回的是日期字符串，是统一格式的。 实例方法Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。 to类：从Date对象返回一个字符串，表示指定的时间。重点在 时间 的 格式 get类：获取Date对象的日期和时间。 set类：设置Date对象的日期和时间。 Date.prototype.valueOf()valueOf方法返回实例对象距离时间零点对应的毫秒数，该方法等同于getTime方法。 1234var d = new Date();d.valueOf() // 1362790014817d.getTime() // 1362790014817 预期为数值的场合，Date实例会自动调用该方法，所以可以用下面的方法计算时间的间隔。 1234var start = new Date();// ...var end = new Date();var elapsed = end - start; 小结： 直接调用Date日期实例对象，就会默认调用 日期实例的 toString() 方法，但预期为数值 的 地方，会自动调用 日期实例 的 valueOf 方法。 to 类方法 返回一个字符串（1）Date.prototype.toString() toString方法返回一个完整的日期字符串。 123456var d = new Date(2013, 0, 1);d.toString()// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"d// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)" 因为toString是默认的调用方法，所以如果直接读取Date实例，就相当于调用这个方法。 （2）Date.prototype.toUTCString() toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。 1234var t2 = new Date()t2 // Fri Aug 30 2019 11:23:22 GMT+0800 (中国标准时间)t2.toUTCString() // "Fri, 30 Aug 2019 03:23:22 GMT" （3）Date.prototype.toISOString() toISOString方法返回对应时间的 ISO8601 写法。 1234var d = new Date(2013, 0, 1);d.toISOString()// &quot;2012-12-31T16:00:00.000Z&quot; 注意，toISOString方法返回的总是 UTC 时区的时间。 （4）Date.prototype.toJSON() toJSON方法返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同。 1234var d = new Date(2013, 0, 1);d.toJSON()// &quot;2012-12-31T16:00:00.000Z&quot; （5）Date.prototype.toDateString() toDateString方法返回日期字符串（不含小时、分和秒）。 12var d = new Date(2013, 0, 1);d.toDateString() // "Tue Jan 01 2013" （6）Date.prototype.toTimeString() toTimeString方法返回时间字符串（不含年月日）。 12var d = new Date(2013, 0, 1);d.toTimeString() // "00:00:00 GMT+0800 (CST)" （7）本地时间 以下三种方法，可以将 Date 实例转为表示本地时间的字符串。 Date.prototype.toLocaleString()：完整的本地时间。 Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。 Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。 下面是用法实例。 12345678910111213var d = new Date(2013, 0, 1);d.toLocaleString()// 中文版浏览器为"2013年1月1日 上午12:00:00"// 英文版浏览器为"1/1/2013 12:00:00 AM"d.toLocaleDateString()// 中文版浏览器为"2013年1月1日"// 英文版浏览器为"1/1/2013"d.toLocaleTimeString()// 中文版浏览器为"上午12:00:00"// 英文版浏览器为"12:00:00 AM" 这三个方法都有两个可选的参数。 123dateObj.toLocaleString([locales[, options]])dateObj.toLocaleDateString([locales[, options]])dateObj.toLocaleTimeString([locales[, options]]) 这两个参数中，locales是一个指定所用语言的字符串，options是一个配置对象。下面是locales的例子。 12345678910var d = new Date(2013, 0, 1);d.toLocaleString('en-US') // "1/1/2013, 12:00:00 AM"d.toLocaleString('zh-CN') // "2013/1/1 上午12:00:00"d.toLocaleDateString('en-US') // "1/1/2013"d.toLocaleDateString('zh-CN') // "2013/1/1"d.toLocaleTimeString('en-US') // "12:00:00 AM"d.toLocaleTimeString('zh-CN') // "上午12:00:00" 下面是options的例子。 1234567891011121314151617181920212223242526272829303132333435var d = new Date(2013, 0, 1);// 时间格式// 下面的设置是，星期和月份为完整文字，年份和日期为数字d.toLocaleDateString('en-US', &#123; weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'&#125;)// "Tuesday, January 1, 2013"// 指定时区d.toLocaleTimeString('en-US', &#123; timeZone: 'UTC', timeZoneName: 'short'&#125;)// "4:00:00 PM UTC"d.toLocaleTimeString('en-US', &#123; timeZone: 'Asia/Shanghai', timeZoneName: 'long'&#125;)// "12:00:00 AM China Standard Time"// 小时周期为12还是24d.toLocaleTimeString('en-US', &#123; hour12: false&#125;)// "00:00:00"d.toLocaleTimeString('en-US', &#123; hour12: true&#125;)// "12:00:00 AM" get 类方法Date对象提供了一系列get*方法，用来获取日期实例对象某个方面的值。 获取当前时区时间的某个部分 getTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。 getDate()：返回实例对象对应每个月的几号（从1开始）。 getDay()：返回星期几，星期日为0，星期一为1，以此类推。 getFullYear()：返回四位的年份。 getMonth()：返回月份（0表示1月，11表示12月）。 getHours()：返回小时（0-23）。 getMilliseconds()：返回毫秒（0-999）。 getMinutes()：返回分钟（0-59）。 getSeconds()：返回秒（0-59）。 getTimezoneOffset()：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。 所有这些get*方法返回的都是整数，不同方法返回值的范围不一样。 分钟和秒：0 到 59 小时：0 到 23 星期：0（星期天）到 6（星期六） 日期：1 到 31 月份：0（一月）到 11（十二月） 123456var d = new Date('January 6, 2013');d.getDate() // 6d.getMonth() // 0d.getFullYear() // 2013d.getTimezoneOffset() // -480 上面代码中，最后一行返回-480，即 UTC 时间减去当前时间，单位是分钟。-480表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时。 下面是一个例子，计算本年度还剩下多少天。 123456function leftDays() &#123; var today = new Date(); var endYear = new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999); var msPerDay = 24 * 60 * 60 * 1000; // 一天对应的毫秒数 return Math.round((endYear.getTime() - today.getTime()) / msPerDay);&#125; 上面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。 获取UTC 时间 的一部分 getUTCDate() getUTCFullYear() getUTCMonth() getUTCDay() getUTCHours() getUTCMinutes() getUTCSeconds() getUTCMilliseconds() 1234var d = new Date('January 6, 2013');d.getDate() // 6d.getUTCDate() // 5 上面代码中，实例对象d表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以getDate方法返回6，对于 UTC 时区来说是1月5日，所以getUTCDate方法返回5。 set 类方法Date对象提供了一系列set*方法，用来设置日期实例对象的各个方面。 设置当前时区时间 setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。 setFullYear(year [, month, date])：设置四位年份。 setHours(hour [, min, sec, ms])：设置小时（0-23）。 setMilliseconds()：设置毫秒（0-999）。 setMinutes(min [, sec, ms])：设置分钟（0-59）。 setMonth(month [, date])：设置月份（0-11）。 setSeconds(sec [, ms])：设置秒（0-59）。 setTime(milliseconds)：设置毫秒时间戳。 这些方法基本是跟get*方法一一对应的，但是没有setDay方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即0是1月，11是12月。 12345var d = new Date ('January 6, 2013');d // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)d.setDate(9) // 1357660800000d // Wed Jan 09 2013 00:00:00 GMT+0800 (CST) **set*方法的参数都会自动折算。**以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。 123456789var d1 = new Date('January 6, 2013');d1.setDate(32) // 1359648000000d1 // Fri Feb 01 2013 00:00:00 GMT+0800 (CST)var d2 = new Date ('January 6, 2013');d.setDate(-1) // 1356796800000d // Sun Dec 30 2012 00:00:00 GMT+0800 (CST) set类方法和get类方法，可以结合使用，得到相对时间。 12345678var d = new Date();// 将日期向后推1000天d.setDate(d.getDate() + 1000);// 将时间设为6小时后d.setHours(d.getHours() + 6);// 将年份设为去年d.setFullYear(d.getFullYear() - 1); set*系列方法除了setTime()，都有对应的 UTC 版本 设置 UTC 时区的时间 setUTCDate() setUTCFullYear() setUTCHours() setUTCMilliseconds() setUTCMinutes() setUTCMonth() setUTCSeconds() 1234var d = new Date('January 6, 2013');d.getUTCHours() // 16d.setUTCHours(22) // 1357423200000d // Sun Jan 06 2013 06:00:00 GMT+0800 (CST) 上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点。 学习心得Date 对象 还是挺好的，方法 作用看名字就能猜出来了，平时开发中用来处理时间。 参考本文大部分内容来自 阮一峰文档，若有侵权，请联系我删除。]]></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-Math对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-Math%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Math 对象Math是 JavaScript 的原生对象，其方法提供了一些数学操作。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。 目录 静态属性 静态方法 Math.abs() Math.max()，Math.min() Math.floor()，Math.ceil() Math.round() Math.pow() Math.sqrt() Math.log() Math.exp() Math.random() 三角函数方法 静态属性 8 个Math对象的静态属性，提供以下一些数学常数。 Math.E：常数e。 Math.LN2：2 的自然对数。 Math.LN10：10 的自然对数。 Math.LOG2E：以 2 为底的e的对数。 Math.LOG10E：以 10 为底的e的对数。 Math.PI：常数π。 Math.SQRT1_2：0.5 的平方根。 Math.SQRT2：2 的平方根。 12345678Math.E // 2.718281828459045Math.LN2 // 0.6931471805599453Math.LN10 // 2.302585092994046Math.LOG2E // 1.4426950408889634Math.LOG10E // 0.4342944819032518Math.PI // 3.141592653589793Math.SQRT1_2 // 0.7071067811865476Math.SQRT2 // 1.4142135623730951 这些属性都是只读的，不能修改。 静态方法Math对象提供以下一些静态方法。 Math.abs()：绝对值 Math.ceil()：向上取整 Math.floor()：向下取整 Math.max()：最大值 Math.min()：最小值 Math.pow()：指数运算 Math.sqrt()：平方根 Math.log()：自然对数 Math.exp()：e的指数 Math.round()：四舍五入 Math.random()：随机数 Math.abs()Math.abs方法返回参数值的绝对值。 12Math.abs(1) // 1Math.abs(-1) // 1 Math.max()，Math.min()Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。 1234Math.max(2, -1, 5) // 5Math.min(2, -1, 5) // -1Math.min() // InfinityMath.max() // -Infinity Math.floor()，Math.ceil()Math.floor方法返回小于参数值的最大整数（地板值）。跟四舍五入没关系，也不是舍弃小数这么简单。 12Math.floor(3.2) // 3Math.floor(-3.2) // -4 Math.ceil方法返回大于参数值的最小整数（天花板值）。跟四舍五入没关系，也不是舍弃小数这么简单。 12Math.ceil(3.2) // 4Math.ceil(-3.2) // -3 应用这两个方法可以结合起来，实现一个总是返回数值的整数部分的函数。舍弃数值小数的函数。 1234567891011function ToInteger(x) &#123; x = Number(x); return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;ToInteger(3.2) // 3ToInteger(3.5) // 3ToInteger(3.8) // 3ToInteger(-3.2) // -3ToInteger(-3.5) // -3ToInteger(-3.8) // -3 上面代码中，不管正数或负数，ToInteger函数总是返回一个数值的整数部分。 Math.round() 四舍五入Math.round方法用于四舍五入。 123456Math.round(0.1) // 0Math.round(0.5) // 1Math.round(0.6) // 1// 等同于Math.floor(x + 0.5) 注意，它对负数的处理（主要是对0.5的处理）。 1234Math.round(-0.5) // -0Math.round(-1.1) // -1Math.round(-1.5) // -1Math.round(-1.6) // -2 Math.pow()Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。 12// 等同于 2 ** 3Math.pow(2, 3) // 8 应用下面是计算圆面积的方法。 12var radius = 20;var area = Math.PI * Math.pow(radius, 2); Math.sqrt()Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。 123Math.sqrt(4) // 2Math.sqrt(-4) // NaNMath.sqrt() // NaN Math.log()Math.log方法返回以e为底的自然对数值。 12Math.log(Math.E) // 1Math.log(10) // 2.302585092994046 使用转换如果要计算以10为底的对数，可以先用Math.log求出自然对数，然后除以Math.LN10；求以2为底的对数，可以除以Math.LN2。 12Math.log(100)/Math.LN10 // 2Math.log(8)/Math.LN2 // 3 Math.exp()Math.exp方法返回常数e的参数次方。 12Math.exp(1) // 2.718281828459045Math.exp(3) // 20.085536923187668 Math.random()Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 返回数值范围0 &lt;= Math.random() &lt; 1 1Math.random() // 0.7151307314634323 应用生成任意范围的随机数 的函数 123456function getRandomArbitrary(min, max) &#123; return Math.random() * (max - min) + min;&#125;getRandomArbitrary(1.5, 6.5)// 2.4942810038223864 生成 任意范围 的 随机整数 的 函数 12345function getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;getRandomInt(1, 6) // 5 返回随机字符的例子如下。 12345678910111213function random_str(length) &#123; var ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; ALPHABET += 'abcdefghijklmnopqrstuvwxyz'; ALPHABET += '0123456789-_'; var str = ''; for (var i = 0; i &lt; length; ++i) &#123; var rand = Math.floor(Math.random() * ALPHABET.length); str += ALPHABET.substring(rand, rand + 1); &#125; return str;&#125;random_str(6) // "NdQKOr" 上面代码中，random_str函数接受一个整数作为参数，返回变量ALPHABET内的随机字符所组成的指定长度的字符串。 三角函数方法Math对象还提供一系列三角函数方法。 Math.sin()：返回参数的正弦（参数为弧度值） Math.cos()：返回参数的余弦（参数为弧度值） Math.tan()：返回参数的正切（参数为弧度值） Math.asin()：返回参数的反正弦（返回值为弧度值） Math.acos()：返回参数的反余弦（返回值为弧度值） Math.atan()：返回参数的反正切（返回值为弧度值） 123456789Math.sin(0) // 0Math.cos(0) // 1Math.tan(0) // 0Math.sin(Math.PI / 2) // 1Math.asin(1) // 1.5707963267948966Math.acos(1) // 0Math.atan(1) // 0.7853981633974483 参考本文大部分内容来自 阮一峰文档，若有侵权，请联系我删除。]]></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-String对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-String%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-Number对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-Number%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-Boolean对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-Boolean%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-包装对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-Array]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-Array%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Array目录 构造函数 静态方法 Array.isArray() 实例方法 valueOf()，toString() push()，pop() shift()，unshift() join() concat() reverse() slice() splice() sort() map() forEach() filter() some()，every() reduce()，reduceRight() indexOf()，lastIndexOf() 链式使用 构造函数 Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。注意数组成员可以是任意类型的数据。 123var arr = new Array(2);arr.length // 2arr // [ empty x 2 ] 上面代码中，Array构造函数的参数2，表示生成一个两个成员的数组，每个位置都是空值。 如果没有使用new，运行结果也是一样的。 123var arr = new Array(2);// 等同于var arr = Array(2); Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。 参数为空时，返回一个空数组 单个参数时，正整数参数为返回的新数组的长度，非正整数参数（小数、负数）会报错；非数值参数为返回的新数组的成员。 多参数时，所有参数都是返回的新数组的成员 1234567891011121314151617181920212223// 1. 无参数时，返回一个空数组new Array() // []// 2.1 参数为 单个正整数 时，表示返回的新数组的长度new Array(1) // [ empty ]new Array(2) // [ empty x 2 ]// 2.2 非正整数的数值作为参数，会报错new Array(3.2) // RangeError: Invalid array lengthnew Array(-3) // RangeError: Invalid array length// 3. 单个非数值（比如null、undefined、布尔值、字符串、对象等）作为参数，则该参数是返回的新数组的成员new Array(null) // [null]new Array(undefined) // [undefined]new Array(true) // [true]new Array('abc') // ['abc']new Array([1]) // [Array[1]]new Array(function fn() &#123;&#125;) // [ƒ]new Array(&#123;&#125;) // [&#123;…&#125;]// 4. 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array('a', 'b', 'c') // ['a', 'b', 'c'] 注意，如果参数是单个正整数，返回数组的成员都是空位。虽然读取数组成员的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。 123456789101112var a = new Array(3);var b = [undefined, undefined, undefined];a.length // 3b.length // 3a[0] // undefinedb[0] // undefined// 取不到键名0 in a // false0 in b // true 上面代码中，a是一个长度为3的空数组，b是一个三个成员都是undefined的数组。读取键值的时候，a和b都返回undefined，但是a的键位都是空的，b的键位是有值的。 可以看到，Array作为构造函数，行为很不一致。因此，不建议使用Array构造函数生成新数组，直接使用数组字面量是更好的做法。 12345// badvar arr = new Array(1, 2);// goodvar arr = [1, 2]; Array原生对象静态方法Array.isArray() Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。 1234567891011var arr = [1, 2, 3]var obj = &#123;&#125;typeof arr // "object"typeof obj // "object"Array.isArray(arr) // trueArray.isArray(obj) // falsearr instanceof Array // trueobj instanceof Array // false 上面代码中，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。 鲜为人知的事实：其实 Array.prototype 也是一个数组。 1Array.isArray(Array.prototype) 比较instanceof 运算符 和 Array.isArray()方法，参考MDN 当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes 假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。 12345if (!Array.isArray) &#123; Array.isArray = function (arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]' &#125;&#125; 实例方法valueOf()，toString() valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。 不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。 12var arr = [1, 2, 3];arr.valueOf() // [1, 2, 3] toString方法也是一个所有对象都拥有的方法，返回对象的字符串形式 不同对象的toString方法不尽一致。数组的toString方法返回一个表示指定的数组及其元素的字符串。 Array对象覆盖了Object的 toString 方法。对于数组对象，toString 方法连接数组并返回一个字符串，其中包含用逗号分隔的每个数组元素。 当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法。 12345678var arr = [1, 2, 3];arr.toString() // "1,2,3"var arr = [1, 2, 3, [4, 5, 6]];arr.toString() // "1,2,3,4,5,6"[null, undefined, , true, 1, 'abc', function fn() &#123;&#125;, [2,3,4], &#123;a: 1&#125;].toString()// ",,,true,1,abc,function fn() &#123;&#125;,2,3,4,[object Object]" push()，pop() push方法用于在数组的末端添加一个或多个元素，并返回该数组的新长度。注意，该方法会改变原数组。 语法：arr.push(element1, ..., elementN)，参数可以是任意类型的数据，返回值是 该数组的新长度 123456var arr = [];arr.push(1) // 1arr.push('a') // 2arr.push(true, &#123;&#125;) // 4arr // [1, 'a', true, &#123;&#125;] 上面代码使用push方法，往数组中添加了四个成员。 push 方法有意设计成通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。 123456789101112131415161718// 1. 合并数组var arr1 = [1, 2, 3]var arr2 = [4, 5, 6]Array.prototype.push.apply(arr1, arr2) //6arr1 // [1, 2, 3, 4, 5, 6]// 2. 数组方法应用到类数组对象上var obj = &#123; length: 0, addElem: function addElem (elem) &#123; [].push.call(this, elem) &#125;&#125;// 为对象增加空对象属性值obj.addElem(&#123;&#125;);obj.addElem(&#123;&#125;);obj // &#123;0: &#123;…&#125;, 1: &#123;…&#125;, length: 2, addElem: ƒ&#125; 上面代码中Array.prototype.push 方法可以应用在一个类数组对象上。 注意，我们没有创建一个数组来存储对象的集合。 相反，我们将该集合存储在对象本身上。 在Array.prototype.push 上使用 call 来调用该方法，使其认为我们正在处理数组，而它只是像平常一样运作，这要感谢 JavaScript 允许我们建立任意的执行上下文(绑定this)。尽管 obj 不是数组，但是 push 方法成功地使 obj 的 length 属性增长了，就像我们处理一个实际的数组一样。 唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。 pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 语法：arr.pop()，无参数，返回值为从数组中删除的元素(当数组为空时返回undefined)。 12345var arr = ['a', 'b', 'c'];arr.pop() // 'c'arr // ['a', 'b'][].pop() // undefined pop 方法有意被设计为具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。pop方法根据 length属性来确定最后一个元素的位置。如果不包含length属性或length属性不能被转成一个数值，会将length置为0，并返回undefined。 push和pop两个方法结合使用，就构成了“后进先出”的栈结构（stack）。 1234567var arr = [];arr.push(1, 2) // 2 数组长度arr // [1, 2]arr.push(3) // 3 数组长度arr // [1, 2, 3]arr.pop() // 3arr // [1, 2] 上面代码中，3是最后进入数组的，但是最早离开数组。 shift()，unshift() 改变原数组 shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 语法：arr.shift()，无参数，返回值为从数组中删除的元素(当数组为空时返回undefined)。 12345var a = ['a', 'b', 'c'];a.shift() // 'a'a // ['b', 'c'][].shift() 上面代码中，使用shift()方法以后，原数组就变了。 shift 方法并不局限于数组：这个方法能够通过 call 或 apply 方法作用于类似数组的对象上。但是对于没有 length 属性（从0开始的一系列连续的数字属性的最后一个）的对象，调用该方法可能没有任何意义。 shift()方法可以遍历并清空一个数组。 12345678var list = [1, 2, 3, 4];var item;while (item = list.shift()) &#123; console.log(item);&#125;list // [] 上面代码通过list.shift()方法每次取出一个元素，从而遍历数组。它的前提是数组元素不能是0或任何布尔值等于false的元素，因此这样的遍历不是很可靠。 push()和shift()结合使用，就构成了“先进先出”的队列结构（queue）。 unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 1234var a = ['a', 'b', 'c'];a.unshift('x'); // 4a // ['x', 'a', 'b', 'c'] unshift()方法可以接受多个参数，这些参数都会添加到目标数组头部。 123var arr = [ 'c', 'd' ];arr.unshift('a', 'b') // 4arr // [ 'a', 'b', 'c', 'd' ] join() 把数组变成字符串 join()方法以指定参数作为分隔符，将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果不提供参数，默认用逗号分隔。如果数组只有一个项目，那么将返回该项目而不使用分隔符。如果 arr.length 为0，则返回空字符串。 123456var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join(' | ') // "1 | 2 | 3 | 4"a.join() // "1,2,3,4"[1].join() // "1" 如果数组成员是undefined或null或空位，会被转成空字符串。 1234[undefined, ,null].join('') // ""['a',, 'b'].join('-') // 'a--b'[undefined, ,null, true, 1, 'abc', function fn() &#123;&#125;, [1,2,3], &#123;&#125;].join() // ",,,true,1,abc,function fn() &#123;&#125;,1,2,3,[object Object]" 通过call方法，这个方法也可以用于字符串或类似数组的对象。 123456Array.prototype.join.call('hello', '-')// "h-e-l-l-o"var obj = &#123; 0: 'a', 1: 'b', length: 2 &#125;;Array.prototype.join.call(obj, '-')// 'a-b' concat() 浅拷贝concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 语法：var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])，将数组和/或值连接成新数组。返回一个新数组实例。 数组成员为简单类型时 参数为数组，添加到目标数组尾部 123456789101112['hello'].concat(['world'], ['!']) // ["hello", "world", "!"][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;) // [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;) // [2, &#123;a: 1&#125;]var array1 = ['a', 'b', 'c'];var array2 = ['d', 'e', 'f'];console.log(array1.concat(array2));// ["a", "b", "c", "d", "e", "f"]array1 // ["a", "b", "c"]array2 // ["d", "e", "f"] 参数为多个单值，添加到目标数组尾部。 12[1, 2, 3].concat(4, 5, 6)// [1, 2, 3, 4, 5, 6] 如果数组成员包括对象，concat方法返回当前数组们的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。 1234567var obj = &#123; a: 1 &#125;;var oldArray = [obj];var newArray = oldArray.concat();obj.a = 2;newArray[0].a // 2 上面代码中，原数组包含一个对象，concat方法生成的新数组拷贝的是这个对象的引用，也就是说，新数组成员和老数组成员都指向同一个内存地址。所以，改变原（新）对象以后，新（原）数组跟着改变。 reverse() 改变原数组reverse方法用于颠倒排列数组元素，返回改变后数组的引用。注意，该方法将改变原数组。 12345var a = ['a', 'b', 'c'];var reverseA = a.reverse() // ["c", "b", "a"]a // ["c", "b", "a"]reverseA === a // true 上面代码说明reverseA和 a指向的是同一内存地址。 slice() 根据 区间 提取数组一部分；浅拷贝slice() 方法返回一个新的数组，新数组是一个由 begin 和 end 决定的浅拷贝 目标数组的一部分（包括 begin，不包括`end`）。原始数组不会被改变。 语法 1arr.slice([begin[, end]]) 参数 begin （可选）：提取起始处的索引，从该索引开始提取原数组元素，默认为 0。如果省略 begin，则 从索引 0 开始提取。 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 如果 begin 大于 原数组的长度，则会返回空数组[]。比如[1].slice(3) // [] end（可选）：提取终止处的索引，在该索引处结束提取原数组元素，默认为 0。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。如果 end 被省略，则slice 会一直提取到原数组末尾。 slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end 大于 数组的长度，slice 也会一直提取到原数组末尾。 1234567var a = ['a', 'b', 'c'];a.slice(0) // ["a", "b", "c"]a.slice(1) // ["b", "c"]a.slice(1, 2) // ["b"]a.slice(2, 6) // ["c"]a.slice() // ["a", "b", "c"] 上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的浅拷贝。 返回值：一个 含有被提取元素的 新数组。注意是新数组是浅拷贝了部分原数组。若没有参数，返回一个原数组的浅拷贝 如果 end 大于 begin，则返回空数组。 1['a', 'b', 'c'].slice(2, 1) // [] slice方法的一个重要应用，是将类似数组（Array-like）的对象转为真正的数组。 12345678Array.prototype.slice.call(&#123; 0: 'a', 1: 'b', length: 2 &#125;) // ['a', 'b']Array.prototype.slice.call(document.querySelectorAll("div"))Array.prototype.slice.call(arguments)// 简写[].slice.call(&#123; 0: 'a', 1: 'b', length: 2 &#125;) // ['a', 'b'][].slice.call(document.querySelectorAll("div"))[].slice.call(arguments) 上面代码的参数都不是数组，但是通过call方法指定任意的上下文，可以在它们上面调用slice方法，就可以把它们转为真正的数组。 上面代码还可使用 bind 来简化该过程 1234var arrArg = Array.prototype.slice.call(arguments)// 使用bind简化var slice = Function.prototype.call.bind(Array.prototype.slice)var arrArg = slice(arguments) splice() 改变原数组；根据 长度 增删数组元素splice() 方法通过删除或替换部分数组元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 语法 1array.splice(start[, deleteCount[, item1[, item2[, ...]]]]) 参数 start (必须有) 指定修改的开始位置（从0计数）。 如果大于数组的长度，则从数组末尾开始添加内容 。 如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。 deleteCount 可选 整数，表示要移除的数组元素的个数。 如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除（含第 start 位）。 如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。 item1, item2, *...* 可选 要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。 返回值 返回一个数组，由被删除的元素组成。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 示例 123var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2) // ["e", "f"]a // ["a", "b", "c", "d"] 上面代码从原数组4号位置，删除了两个数组成员。 123var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(4, 2, 1, 2) // ["e", "f"]a // ["a", "b", "c", "d", 1, 2] 上面代码除了删除成员，还插入了两个新成员。 12var a = ['a', 'b', 'c', 'd', 'e', 'f'];a.splice(-4, 2) // ["c", "d"] 上面代码表示，从倒数第四个位置c开始删除两个成员。 1234var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1] 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 123var a = [1, 2, 3, 4, 5, 6];a.splice(2) // [3, 4, 5, 6]a // [1, 2] 12[1, 2, 3].splice(5, 1, 4, 5) // []// [1, 2, 3, 4, 5] sort() 改变原数组 sort方法用原地算法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。默认排序顺序是在将元素转换为字符串，然后比较各个字符的Unicode位点进行排序。由于它取决于具体实现，因此无法保证时空复杂度。 1234567891011['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11][10111, 1101, 111].sort()// [10111, 1101, 111] 上面代码的最后两个例子，需要特殊注意。sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。sort的参数函数本身接受两个参数，表示进行比较的两个数组成员(两两传入)。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面（第一个元素 &gt; 第二个元素 ）；其他情况下，都是第一个元素排在第二个元素前面。 下面是是一个按照数值从小到大排序的例子 1234567[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111]// 箭头函数[10111, 1101, 111].sort((a, b) =&gt; a - b) 123456789101112[ &#123; name: "张三", age: 28 &#125;, &#123; name: "李四", age: 24 &#125;, &#123; name: "王五", age: 30 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: "李四", age: 24 &#125;,// &#123; name: "王五", age: 28 &#125;,// &#123; name: "张三", age: 30 &#125;// ] 上面是一个按照各对象属性值排序的例子。 map()map方法将数组的所有成员依次传入参数函数，然后把每一次参数函数的返回结果 组成一个新数组返回。该方法不改变原数组 123456789var numbers = [1, 2, 3];numbers.map(function (value, key ,array) &#123; return value * key;&#125;);// [0, 2, 6]numbers// [1, 2, 3] 上面代码中，numbers数组的所有成员依次执行参数函数，参数函数执行了3次，运行结果组成一个新数组返回，原数组没有变化。map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组（[1, 2, 3]）。 语法 123var new_array = arr.map(function callback(currentValue[, currentIndex[, arr]]) &#123; // Return element for new_array &#125;[, thisArg]) 参数 第一个参数 callback：生成新数组元素的函数，使用三个参数： currentValue 必须 callback 中正在处理的数组元素。 index可选 callback 中正在处理的数组元素的索引。 array可选 map 方法正在操作的数组。 第二个参数 thisArg可选 绑定回调函数内部的this 变量。若不明确指定thisArg，则this指向顶层对象 返回值 一个新数组，每个元素都是回调函数返回的结果。 使用说明 map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值（包括undefined、null）的索引上被调用；那些从来没被赋过值（空位）或者使用 delete 删除的索引则不会被调用。 callback 函数被调用时会被自动传入三个参数：数组元素，元素索引，原数组本身。 如果 thisArg 参数有值，则每次 callback 函数被调用的时候，回调函数内部this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg参数，或者赋值为 null 或 undefined，则 this 指向全局对象 。 map不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。 使用示例 123456var arr = ['a', 'b', 'c'];[1, 2].map(function (e) &#123; return this[e];&#125;, arr)// ['b', 'c'] 上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。 12345var f = function (n) &#123; return 'a' &#125;;[1, undefined, 2].map(f) // ["a", "a", "a"][1, null, 2].map(f) // ["a", "a", "a"][1, , 2].map(f) // ["a", , "a"] 上面代码中，map方法不会跳过undefined和null，但是会跳过数组空位。 在一个 String 上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组 12var a = Array.prototype.map.call('hello world',(x) =&gt; x.charCodeAt(0))// [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100] 去遍历用 querySelectorAll得到的动态对象集合。在这里，我们获得了文档里所有选中的选项，并将其打印： 12var elements = document.querySelector('select option:checked')var values = Array.prototype.map.call(elements, (obj) =&gt; obj.value) 一个容易犯的错误 通常情况下，map 方法中的 callback 函数只需要接受一个参数既可以，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。 12345[1,2,3].map(function (value) &#123; console.log(arguments) &#125;)// Arguments(3) [1, 0, Array(3), callee: ƒ, Symbol(Symbol.iterator): ƒ]// Arguments(3) [2, 1, Array(3), callee: ƒ, Symbol(Symbol.iterator): ƒ]// Arguments(3) [3, 2, Array(3), callee: ƒ, Symbol(Symbol.iterator): ƒ] 上面的代码，回调函数只接受了一个参数value。看上去似乎map只给回调函数传了一个参数，但是实际上，每次调用回调函数时，回调函数都会自动被传入三个参数，只是回调函数不一定用完。我们可以打出回调函数内部的arguments对象，可以发现的确给回调函数传入了三个参数。 因此当这样使用map方法时，就有可能犯错： [1,2,3].map(callbackName)，因为我们不能显式的知道回调函数到底使用了几个传入的参数。 12345678910111213141516171819202122232425// 下面的语句返回什么呢:["1", "2", "3"].map(parseInt); // [1, NaN, NaN]// 你可能觉的会是[1, 2, 3]// 但实际的结果是 [1, NaN, NaN]// 通常使用parseInt时,只需要传递一个参数.// 但实际上,parseInt可以有两个参数.第二个参数是进制数.可以通过语句"alert(parseInt.length)===2"来验证.// map方法在调用callback函数时,会主动给它传递三个参数:当前正在遍历的元素, 元素索引, 原数组本身.// 第三个参数parseInt会忽视, 但第二个参数不会,也就是说,parseInt把传过来的索引值当成进制数来使用.从而返回了NaN.function returnInt(element) &#123; return parseInt(element, 10);// 或 return parseInt(element）&#125;// 1. 意料之中的结果['1', '2', '3'].map(returnInt); // [1, 2, 3]// 2. 也可以使用简单的箭头函数，结果同上['1', '2', '3'].map( str =&gt; parseInt(str) );// 3. 一个更简单的方式:['1', '2', '3'].map(Number); // [1, 2, 3]// 与`parseInt` 不同，下面的结果会返回浮点数或指数:['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300] forEach()forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。 语法 123arr.forEach(function callback(currentValue[, currentIndex[, arr]]) &#123; // no return&#125;[, thisArg]) 参数 第一个参数 callback：为数组中每个元素执行的函数，该函数接收三个参数： currentValue 数组中正在处理的当前元素。 index可选 数组中正在处理的当前元素的索引。 array可选 forEach() 方法正在操作的数组。 第二个参数 thisArg可选 当执行回调函数时，用作回调函数内部 this 的值(参考对象)。 返回值 undefined 使用说明 forEach 方法按升序为数组中含有效值（包括null、undefined，跳过空位）的每一项执行一次callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。 callback 函数调用时，会被依次传入三个参数：数组当前项的值、数组当前项的索引、数组对象本身 如果 thisArg 参数有值，则每次 callback 函数被调用的时候，回调函数内this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象。 forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach遍历到他们那一刻的值。已删除的项不会被遍历到。如果已经被访问的元素在后面forEach遍历其它元素时被删除了（例如使用 shift()），则所有元素移动，之后的某个元素将被跳过 - 参见下面的示例。 forEach() 为每个数组元素执行callback函数；不像 map() 或者 reduce()，它总是返回 undefined 值，并且不可链式调用。典型用例是在一个链的最后执行副作用。 forEach() 被调用时，不会改变原数组（即调用它的数组），但是原数组可能被回调函数改变。 注意： 没有办法中止或者跳出 forEach() 循环，除了抛出一个异常。如果你需要这样，使用 forEach() 方法是错误的。 若希望符合某种条件，就提前终止循环，你可以使用： 简单循环for for…of 循环 Array.prototype.every() Array.prototype.some() Array.prototype.find() Array.prototype.findIndex() 后4种数组方法可以对数组元素判断，以便确定是否需要继续遍历 译者注：若条件允许，也可以使用 filter() 提前过滤出需要遍历的部分，再用 forEach() 处理。 基本使用示例 12345678function log(element, index, array) &#123; console.log(`[$&#123;index&#125;] = $&#123;element&#125;`)&#125;[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [2] = 9 上面代码中，forEach遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用map方法。 1234567var out = [];[1, 2, 3].forEach(function(elem) &#123; this.push(elem * elem);&#125;, out);out // [1, 4, 9] 上面代码中，空数组out是forEach方法的第二个参数，结果，回调函数内部的this关键字就指向out。 1234567var arr = [1, 2, 3];for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === 2) break; console.log(arr[i]);&#125;// 1 上面代码中，执行到数组的第二个成员时，就会中断执行。forEach方法做不到这一点。 1234567891011121314151617var log = function (n) &#123; console.log(n + 1);&#125;;[1, undefined, 2].forEach(log)// 2// NaN// 3[1, null, 2].forEach(log)// 2// 1// 3[1, , 2].forEach(log)// 2// 3 上面代码中，forEach方法不会跳过undefined和null，但会跳过空位。 应用示例 forEach代替for 循环 传复制对象副本 - 浅复制。深复制要每一层复制 123456789101112131415function copy(obj) &#123; var copy = Object.create(Object.getPrototypeOf(obj)); var propNames = Object.getOwnPropertyNames(obj); propNames.forEach(function(name) &#123; var desc = Object.getOwnPropertyDescriptor(obj, name); Object.defineProperty(copy, name, desc); &#125;); return copy;&#125;var obj1 = &#123; a: 1, b: 2 &#125;;var obj2 = copy(obj1); // obj2 looks like obj1 nowobj1 === obj2 上面代码可复制原来对象继承的非原生JS属性。 若已被访问过的数组元素在forEach访问数组后面元素时被删除了，则某个元素会被跳过。 12345678910var words = ['one', 'two', 'three', 'four'];words.forEach(function(word) &#123; console.log(word); if (word === 'two') &#123; words.shift(); &#125;&#125;);// one// two// four 下面的例子会输出”one”, “two”, “four”。当到达包含值”two”的项时，整个数组的第一个项被移除了，这导致所有剩下的项前移一个位置。因为元素 “four”现在在数组更前的位置，”three”会被跳过。 forEach()不会在迭代之前创建数组的副本。 filter()filter方法返回一个新数组。用于过滤数组成员，由满足条件的成员组成一个新数组。该方法不会改变原数组。 它的参数是一个函数，所有数组成员依次执行该函数，回调函数返回值为true的成员组成一个新数组返回。 1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5] 上面代码将大于3的数组成员，作为一个新数组返回。 1234var arr = [0, 1, 'a', false];arr.filter(Boolean)// [1, "a"] 上面代码中，filter方法返回数组arr里面所有布尔值为true的成员。 filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。 1234[1, 2, 3, 4, 5].filter(function (elem, index, arr) &#123; return index % 2 === 0;&#125;);// [1, 3, 5] 上面代码返回偶数位置的成员组成的新数组。 filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 1234567var obj = &#123; MAX: 3 &#125;;var myFilter = function (item) &#123; if (item &gt; this.MAX) return true;&#125;;var arr = [2, 8, 3, 4, 1, 3, 2, 9];arr.filter(myFilter, obj) // [8, 4, 9] 上面代码中，过滤器myFilter内部有this变量，它可以被filter方法的第二个参数obj绑定，返回大于3的成员。 map 、forEach、filter 三个方法的回调函数都接受value、index、array some()，every() 不完全遍历数组这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。some()方法是只要至少有一个数组成员符合条件，就立即返回true，every() 方法是必须所有数组成员都符合条件，才立即返回true。这两种方法都不一定遍历完整个数组。 它们接受一个函数作为参数，所有数组成员依次执行该函数。该回调函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。 some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。 123456789var arr = [1, 2, 3, 4, 5];arr.some(function (elem, index, arr) &#123; console.log(elem) return elem &gt;= 3;&#125;)// 1// 2// 3// true 上面代码中，如果数组arr有一个成员大于等于3，some方法就返回true。不完全遍历数组 every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。 1234567var arr = [1, 2, 3, 4, 5];arr.every(function (elem, index, arr) &#123; console.log(elem) return elem &gt;= 3;&#125;)// 1// false 上面代码中，数组arr并非所有成员大于等于3，所以返回false。不完全遍历数组 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。 1234function isEven(x) &#123; return x % 2 === 0 &#125;[].some(isEven) // false[].every(isEven) // true some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 reduce()，reduceRight() 累计功能；遍历数组 reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 123456789[1, 2, 3, 4, 5].reduce(function (a, b, index) &#123; console.log(a, b, index); return a + b;&#125;)// 1 2 1// 3 3 2// 6 4 3// 10 5 4// 15 上面代码中，reduce方法求出数组所有成员的和。第一次执行，a是数组的第一个成员1，b是数组的第二个成员2。第二次执行，a为上一轮的返回值3，b为第三个成员3。第三次执行，a为上一轮的返回值6，b为第四个成员4。第四次执行，a为上一轮返回值10，b为第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。 reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。 累积变量，默认为数组的第一个成员 必须 ，从第二轮开始为上一轮的返回值 当前变量，默认为数组的第二个成员 必须 ，之后依次为数组元素 当前变量的索引（从0开始）可选 原数组 可选 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。注意这时当前变量从数组第一个成员开始。 1234[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10);// 25 上面代码指定参数a的初值为10，所以数组从10开始累加，最终结果为25。注意，这时b是从数组的第一个成员开始遍历。 上面的第二个参数相当于设定了默认值，处理空数组时尤其有用。 12345678function add(prev, cur) &#123; return prev + cur;&#125;[].reduce(add)// TypeError: Reduce of empty array with no initial value[].reduce(add, 1)// 1 上面代码中，由于空数组取不到初始值，reduce方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。 下面是一个reduceRight方法的例子。 123456function subtract(prev, cur) &#123; return prev - cur;&#125;[3, 2, 1].reduce(subtract) // 0[3, 2, 1].reduceRight(subtract) // -4 上面代码中，reduce方法相当于3减去2再减去1，reduceRight方法相当于1减去2再减去3。 由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。 1234567function findLongest(entries) &#123; return entries.reduce(function (longest, entry) &#123; return entry.length &gt; longest.length ? entry : longest; &#125;, '');&#125;findLongest(['aaa', 'bb', 'c']) // "aaa" 上面代码中，reduce的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。 indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 第一个参数，需要搜索的数组元素 1234var a = ['a', 'b', 'c'];a.indexOf('b') // 1a.indexOf('y') // -1 indexOf方法还可以接受第二个参数，表示搜索的开始位置。 1['a', 'b', 'c'].indexOf('a', 1) // -1 上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。 lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 123var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1 注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。 12[NaN].indexOf(NaN) // -1[NaN].lastIndexOf(NaN) // -1 这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。 1NaN === NaN // false 链式使用上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。 12345678910111213141516var users = [ &#123;name: 'tom', email: 'tom@example.com'&#125;, &#123;name: 'peter', email: 'peter@example.com'&#125;];users.map(function (user) &#123; return user.email;&#125;).filter(function (email) &#123; return /^t/.test(email);&#125;).forEach(function (email) &#123; console.log(email);&#125;);// "tom@example.com" 上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以t开头的 Email 地址，最后将它打印出来。 map 操作+取值 -&gt; fliter过滤 + 正则 -&gt; forEach输出]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>标准库</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准库-属性描述对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[属性描述对象目录 概述 Object.getOwnPropertyDescriptor() Object.getOwnPropertyNames() Object.defineProperty()，Object.defineProperties() Object.prototype.propertyIsEnumerable() 元属性 value writable enumerable configurable 存取器 对象的拷贝 控制对象状态 Object.preventExtensions() Object.isExtensible() Object.seal() Object.isSealed() Object.freeze() Object.isFrozen() 局限性 概述JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。 下面是属性描述对象的一个例子。下面都是默认值 12345678&#123; value: undefined, writable: true, enumerable: true, configurable: true, get: undefined, set: undefined&#125; 属性描述对象提供6个元属性。 （1）value value是该属性的属性值，默认为undefined。 （2）writable writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。 （3）enumerable enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 （4）configurable configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 （5）get get是一个函数，表示该属性的取值函数（getter），默认为undefined。取值函数的返回值 就是 该属性的属性值。 （6）set set是一个函数，表示该属性的存值函数（setter），默认为undefined。 Object 的静态方法，实例对象是没有的。 Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptor()方法可以获取对象的属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，目标对象的某个属性名。 123456789var obj = &#123; p: 'a' &#125;;Object.getOwnPropertyDescriptor(obj, 'p')// &#123;value: 123, writable: true, enumerable: true, configurable: true&#125;// configurable: true// enumerable: true// value: 123// writable: true// __proto__: Object 上面代码中，Object.getOwnPropertyDescriptor()方法获取obj.p的属性描述对象。 注意，Object.getOwnPropertyDescriptor()方法只能用于对象自身的属性，不能用于继承的属性。 1234var obj = &#123; p: 'a' &#125;;Object.getOwnPropertyDescriptor(obj, 'toString')// undefined 上面代码中，toString是obj对象继承的属性，Object.getOwnPropertyDescriptor()无法获取。 Object.getOwnPropertyNames() Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 1234567var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 1, enumerable: true &#125;, p2: &#123; value: 2, enumerable: false &#125;&#125;);Object.getOwnPropertyNames(obj)// ["p1", "p2"] 上面代码中，obj.p1是可遍历的，obj.p2是不可遍历的。Object.getOwnPropertyNames会将它们都返回。 这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。 123456Object.keys([]) // []Object.getOwnPropertyNames([]) // [ 'length' ]Object.keys(Object.prototype) // []Object.getOwnPropertyNames(Object.prototype)//["constructor", "__defineGetter__", "__defineSetter__", "hasOwnProperty", "__lookupGetter__", "__lookupSetter__", "isPrototypeOf", "propertyIsEnumerable", "toString", "valueOf", "__proto__", "toLocaleString"] 上面代码中，数组自身的length属性是不可遍历的，Object.keys不会返回该属性。第二个例子的Object.prototype也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的，不过有点奇怪可以遍历到Object.prototype的__proto__属性，但是遍历不到get __proto__、 set __proto__。 Object.defineProperty()，Object.defineProperties() Object.defineProperty()方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。 1Object.defineProperty(object, propertyName, attributesObject) Object.defineProperty方法接受三个参数，依次如下。 object：属性所在的对象 propertyName：字符串，表示属性名 attributesObject：属性描述对象 举例来说，定义obj.p可以写成下面这样。 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 上面代码中，Object.defineProperty()方法定义了obj.p属性。由于属性描述对象的writable属性为false，所以 obj.p属性不可写。注意，这里的Object.defineProperty方法的第一个参数是{}（一个新建的空对象），p属性直接定义在这个空对象上面，然后返回这个对象，这是Object.defineProperty()的常见用法。 如果属性已经存在，Object.defineProperty()方法相当于更新该属性的属性描述对象。 如果一次性定义或修改多个属性，可以使用Object.defineProperties()方法。 123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;，&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc" 上面代码中，Object.defineProperties()同时定义了obj对象的三个属性。其中，p3属性定义了取值函数get，即每次读取该属性，都会调用这个取值函数。 注意， 一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，否则会报错 一旦定义了取值函数get（或存值函数set），就不能同时定义value属性，否则会报错。 123456789101112131415var obj = &#123;&#125;;Object.defineProperty(obj, 'p', &#123; value: 123, get: function() &#123; return 456; &#125;&#125;);// TypeError: Invalid property.// A property cannot both have accessors and be writable or have a valueObject.defineProperty(obj, 'p', &#123; writable: true, get: function() &#123; return 456; &#125;&#125;);// TypeError: Invalid property descriptor.// Cannot both specify accessors and a value or writable attribute 上面代码中，同时定义了get属性和value属性，以及将writable属性设为true，就会报错。 注意：Object.defineProperty()和Object.defineProperties()参数里面的属性描述对象，writable、configurable、enumerable这三个元属性的默认值都为false。 123456789var obj = &#123;&#125;;Object.defineProperty(obj, 'foo', &#123;&#125;);Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: undefined,// writable: false,// enumerable: false,// configurable: false// &#125; 上面代码中，定义obj.foo时用了一个空的属性描述对象，就可以看到各个元属性的默认值。 Object.prototype.propertyIsEnumerable()实例对象的propertyIsEnumerable()方法返回一个布尔值，用来判断对象的某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回false。 12345var obj = &#123;&#125;;obj.p = 123;obj.propertyIsEnumerable('p') // trueobj.propertyIsEnumerable('toString') // false 上面代码中，obj.p是可遍历的，而obj.toString是继承的属性。 元属性属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。 valuevalue属性是目标属性的值。 12345678var obj = &#123;&#125;;obj.p = 123;Object.getOwnPropertyDescriptor(obj, 'p').value// 123Object.defineProperty(obj, 'p', &#123; value: 246 &#125;);obj.p // 246 上面代码是通过value属性，读取或改写obj.p的例子。 writable1. writable属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。 12345678910var obj = &#123;&#125;;Object.defineProperty(obj, 'a', &#123; value: 37, writable: false&#125;);obj.a // 37obj.a = 25;obj.a // 37 上面代码中，obj.a的writable属性是false。然后，改变obj.a的值，不会有任何效果。 注意，正常模式下，对writable为false的属性 直接赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对a属性重新赋予一个同样的值。 下面代码中，obj.p的writable为false，对obj.p直接赋值不会生效。 123456789// 正常模式下var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 1, writable: false, configurable: false&#125;);obj.p = 2;obj.p // 1 12345678910'use strict';var obj = &#123;&#125;;Object.defineProperty(obj, 'a', &#123; value: 37, writable: false&#125;);obj.a = 37;// Uncaught TypeError: Cannot assign to read only property 'a' of object 上面代码是严格模式，对obj.a任何赋值行为都会报错。 如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。 123456789var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);obj.foo = 'b';obj.foo // 'a' 上面代码中，proto是原型对象，它的foo属性不可写。obj对象继承proto，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。 但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。 123456789101112var proto = Object.defineProperty(&#123;&#125;, 'foo', &#123; value: 'a', writable: false&#125;);var obj = Object.create(proto);Object.defineProperty(obj, 'foo', &#123; value: 'b'&#125;);obj.foo // "b"Object.getOwnPropertyDescriptor(obj, 'foo') // &#123;value: "b", writable: false, enumerable: false, configurable: false&#125; 上面代码相当于给 obj自身添加了 foo属性，而对象自身属性覆盖对象继承属性。 enumerable 设置秘密属性 enumerable（可遍历性）返回一个布尔值，表示目标属性是否可遍历。 JavaScript 的早期版本，for...in循环是基于in运算符的。我们知道，in运算符不管某个属性是对象自身的还是继承的，都会返回true。 12var obj = &#123;&#125;;'toString' in obj // true 上面代码中，toString不是obj对象自身的属性，但是in运算符也返回true，这导致了toString属性也会被for...in循环遍历。 这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被for...in循环遍历，同时还规定toString这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了for...in循环的可用性。 对象的属性分为可遍历属性 和 不可遍历属性。可遍历属性 是 属性描述对象的enumerable属性值为 true的属性，可以是自身属性 和 继承的非原生JS属性；而不可遍历属性 是 属性描述对象的enumerable属性值为 false的属性，可以是自身属性 和 继承的非原生JS属性，继承的原生JS属性。总之，对象继承的原生JS属性一定是不会被遍历到的。 目前还未发现可以操作（遍历 或 其他操作） 对象继承的原生JS属性 的方法，对象继承的原生JS属性一定都是不可遍历的。 遍历对象的方法： for..in循环 可以遍历到对象自身的可遍历属性 和 继承的非原生JS 可遍历属性 Object.keys方法 可以遍历到对象自身的可遍历属性，不可遍历对象的继承属性。 JSON.stringify方法 可以遍历到对象自身的可遍历属性，不可遍历对象的继承属性。 Object.getOwnPropertyNames方法可获取对象自身的所有属性，不管属性是否可遍历。但不可遍历继承属性。 1234567891011121314151617181920212223242526// 遍历继承属性var o1 = &#123;a: 1, b: 2&#125;var o2 = Object.create(o1)for (let key in o2) &#123; console.log(key)&#125;// 'a'// 'b'Object.keys(o2) // []JSON.stringify(o2) // "&#123;&#125;"Object.getOwnPropertyNames(o2) // []// 遍历对象自身属性Object.getOwnPropertyNames([1, 2 ,3]) // ["0", "1", "2", "length"]for (let key in [1, 2, 3]) &#123; console.log(key)&#125;// '1'// '2'// '3'Object.keys([1, 2, 3]) // ["0", "1", "2"]JSON.stringify([1, 2, 3]) // "[1,2,3]" 因此，enumerable可以用来设置“秘密”属性。 12345678910111213141516var obj = &#123;&#125;;Object.defineProperty(obj, 'x', &#123; value: 123, enumerable: false&#125;);obj.x // 123for (var key in obj) &#123; console.log(key);&#125;// undefinedObject.keys(obj) // []JSON.stringify(obj) // "&#123;&#125;" 上面代码中，obj.x属性的enumerable为false，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。 另外，JSON.stringify方法会排除enumerable为false的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的enumerable设为false。 configurable configurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。也就是说，configurable为false时，value、writable、enumerable和configurable都不能被修改了。 123456789101112131415161718var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 1, writable: false, enumerable: false, configurable: false&#125;);Object.defineProperty(obj, 'p', &#123;value: 2&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, 'p', &#123;writable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, 'p', &#123;enumerable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, 'p', &#123;configurable: true&#125;)// TypeError: Cannot redefine property: p 上面代码中，obj.p的configurable为false。然后，改动value、writable、enumerable、configurable，结果都报错。正常模式下，重定义属性描述对象为原来的值不报错，看下面代码： 123456789101112131415var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 1, writable: false, enumerable: false, configurable: false&#125;);// 下面四句都不报错Object.defineProperty(obj, 'p', &#123;value: 1&#125;)Object.defineProperty(obj, 'p', &#123;writable: false&#125;)Object.defineProperty(obj, 'p', &#123;enumerable: false&#125;)Object.defineProperty(obj, 'p', &#123;configurable: false&#125;) 注意，当configurable为false时，writable只有在false改为true会报错，true改为false是允许的。 1234567var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; writable: true, configurable: false&#125;);Object.defineProperty(obj, 'p', &#123;writable: false&#125;)// 修改成功 注意，当configurable为false时，enumerable在false改为true，true改为false都会报错。只有当configurable为true时，enumerable才可修改。 至于value，只要writable和configurable有一个为true，就允许改动。 1234567891011121314151617var o1 = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 1, writable: true, configurable: false&#125;);Object.defineProperty(o1, 'p', &#123;value: 2&#125;)// 修改成功var o2 = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 1, writable: false, configurable: true&#125;);Object.defineProperty(o2, 'p', &#123;value: 2&#125;)// 修改成功 可配置性configurable决定了目标属性是否可以被删除（delete）。只有configurable为true时，对象的属性才可以删除。 12345678910var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 1, configurable: true &#125;, p2: &#123; value: 2, configurable: false &#125;&#125;);delete obj.p1 // truedelete obj.p2 // falseobj.p1 // undefinedobj.p2 // 2 上面代码中，obj.p1的configurable是true，所以可以被删除，obj.p2就无法删除。 存取器 accessor 包括 存值函数 和 取值函数 除了直接定义对象属性以外，对象的属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。 一旦对目标属性定义了存取器，那么每次读目标属性时，都会执行取值函数，取值函数的返回值就是该属性的值；每次给目标属性赋值时，都会执行存值函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。？？ 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; get: function () &#123; return 'getter'; &#125;, set: function (value) &#123; console.log('setter: ' + value); &#125;&#125;);obj.p // "getter"obj.p = 123 // "setter: 123" 上面代码中，obj.p定义了get和set属性。obj.p取值时，就会调用get；赋值时，就会调用set。 JavaScript 还提供了存取器的另一种写法。 12345678var obj = &#123; get p() &#123; return 'getter'; &#125;, set p(value) &#123; console.log('setter: ' + value); &#125;&#125;; 上面的写法与定义属性描述对象是等价的，而且使用更广泛。()前面是属性名。 注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。 存取器应用：对象某个属性的值 依赖 对象内部数据的场合。 12345678910111213141516171819202122232425var obj =&#123; $n : 5, get next() &#123; return this.$n++ &#125;, set next(n) &#123; if (n &gt;= this.$n) this.$n = n; else throw new Error('新的值必须大于当前值'); &#125;&#125;;// 每次读对象的属性，就会执行存值函数obj.next // 5// 每次读对象的属性，就会执行存值函数obj //&#123;$n: 6&#125;// $n: 6// next: (...)// get next: ƒ next()// set next: ƒ next(n)// __proto__: Objectobj.next = 10;obj.next // 10obj.next = 5;// Uncaught Error: 新的值必须大于当前值 上面代码中，next属性的存值函数和取值函数，都依赖于内部属性$n。 对象的拷贝 有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。 1234567891011var extend = function (to, from) &#123; for (var property in from) &#123; to[property] = from[property]; &#125; return to;&#125;extend(&#123;&#125;, &#123; a: 1&#125;)// &#123;a: 1&#125; 上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝属性值，属性描述对象不一致。 123456789var o1 = &#123; get a() &#123; return 1 &#125;&#125;var o2 = extend(&#123;&#125;, o1)o2 // &#123;a: 1&#125;o1 === o2 //falseObject.getOwnPropertyDescriptor(o1,'a') // &#123;get: ƒ, set: undefined, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(o2, 'a') // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125; 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。先获取属性描述对象，再用属性描述对象去定义新对象的属性。 123456789101112131415var extend = function (to, from) &#123; for (var property in from) &#123; if (!from.hasOwnProperty(property)) continue; Object.defineProperty( to, property, Object.getOwnPropertyDescriptor(from, property) ); &#125; return to;&#125;extend(&#123;&#125;, &#123; get a()&#123; return 1 &#125; &#125;)// &#123; get a()&#123; return 1 &#125; &#125;) 上面代码中，hasOwnProperty那一行用来过滤掉继承的属性(非原生)，否则可能会报错，因为Object.getOwnPropertyDescriptor读不到继承属性的属性描述对象。 控制对象状态 有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。 Object.preventExtensions()Object.preventExtensions方法 只是使得一个对象无法再添加新的属性，该方法参数为对象，返回值也是该对象。 1234567891011121314151617181920212223var obj = &#123;a: 1&#125;;Object.preventExtensions(obj);// 1. 为对象新增属性会报错Object.defineProperty(obj, 'p', &#123; value: 'hello'&#125;);// TypeError: Cannot define property:p, object is not extensible.// 2. 直接给属性赋值不报错，会默默失效obj.p = 1;obj.p // undefined// 3. 'a'属性描述对象 不变Object.getOwnPropertyDescriptor(obj, 'a') // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;// 4. 修改属性值 生效obj.a = 2obj //&#123;a: 2&#125;// 5. 删除对象属性 成功delete obj.a // trueobj // &#123;&#125; 上面代码中，obj对象经过Object.preventExtensions以后，就无法添加新属性了。 Object.isExtensible()Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为对象添加新属性。方法参数为对象，返回一个布尔值。 12345var obj = new Object();Object.isExtensible(obj) // trueObject.preventExtensions(obj);Object.isExtensible(obj) // false 上面代码中，对obj对象使用Object.preventExtensions方法以后，再使用Object.isExtensible方法，返回false，表示已经不能添加新属性了。 Object.seal() Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。 12345678var obj = &#123; p: 'hello' &#125;;Object.seal(obj) // &#123;p: "hello"&#125;delete obj.p // falseobj.p // "hello"obj.x = 'world';obj.x // undefined 上面代码中，obj对象执行Object.seal方法以后，就无法添加新属性和删除旧属性了。 Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。使用Object.defineProperty 定义新属性会报错，而直接给未定义的对象属性赋值，不报错但是会默默失效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var obj = &#123; p: 'a'&#125;;// seal方法之前Object.getOwnPropertyDescriptor(obj, 'p')// Object &#123;// value: "a",// writable: true,// enumerable: true,// configurable: true// &#125;Object.seal(obj);// 1. 使用seal方法之后，属性描述对象改变Object.getOwnPropertyDescriptor(obj, 'p')// Object &#123;// value: "a",// writable: true,// enumerable: true,// configurable: false// &#125;// 2. 修改属性描述对象Object.defineProperty(obj, 'p', &#123; enumerable: false&#125;)// Uncaught TypeError: Cannot redefine property: p// 修改属性描述对象的value属性 成功Object.defineProperty(obj, 'p', &#123; value: 'b'&#125;)// &#123;p: "b"&#125;obj.p = 'c'obj // &#123;p: "c"&#125;// 3. 新增属性 失败且报错Object.defineProperty(obj, 'b', &#123; enumerable: false&#125;)// Uncaught TypeError: Cannot define property b, object is not extensible// 直接对对象属性赋值 不报错，但是会默默失效obj // &#123;p: "c"&#125;obj.b = 'd'obj // &#123;p: "c"&#125;// 4. 删除属性 失败delete obj.p // falseobj // &#123;p: "c"&#125; 上面代码中，使用Object.seal方法之后，属性描述对象的configurable属性就变成了false，然后改变enumerable属性就会报错。但是因为writable为true，所以该属性值可改。 Object.isSealed() Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。参数为对象，返回值为true/false 1234var obj = &#123; p: 'a' &#125;;Object.seal(obj);Object.isSealed(obj) // true 这时，Object.isExtensible方法也返回false。 12345var obj = &#123; p: 'a' &#125;;Object.seal(obj)Object.isSealed(obj) // falseObject.isExtensible(obj) // false Object.freeze()Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 1234567891011121314151617var obj = &#123; p: 'hello'&#125;;Object.freeze(obj);// 1. 修改属性值 失败obj.p = 'world';obj.p // "hello"// 2. 新增属性obj.t = 'hello';obj.t // undefined// 3. 删除属性失败delete obj.p // falseobj.p // "hello" 上面代码中，对obj对象进行Object.freeze()以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。 Object.isFrozen() Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。 123456var obj = &#123; p: &apos;hello&apos;&#125;;Object.freeze(obj);Object.isFrozen(obj) // true 使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。 123456789var obj = &#123; p: 'hello'&#125;;Object.freeze(obj);Object.isSealed(obj) // trueObject.isExtensible(obj) // falseObject.isFrozen(obj) // true Object.isFrozen的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。 123456789var obj = &#123; p: 'hello'&#125;;Object.freeze(obj);if (!Object.isFrozen(obj)) &#123; obj.p = 'world';&#125; 上面代码中，确认obj没有被冻结后，再对它的属性赋值，就不会报错了。 局限性 局限性一：上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。 1234567var obj = new Object();Object.preventExtensions(obj);var proto = Object.getPrototypeOf(obj);proto.t = 'hello';obj.t// hello 上面代码中，对象obj本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在obj上读到。 一种解决方案是，把obj的原型也冻结住。 123456789var obj = new Object();Object.preventExtensions(obj);var proto = Object.getPrototypeOf(obj);//等价于 var proto = obj.__proto__Object.preventExtensions(proto);proto.t = 'hello';obj.t // undefined 局限二是，如果属性值是对象，上面这些方法只能冻结改属性指向的对象不变，而不能冻结指向对象本身的内容。用对象的引用地址就好理解。若属性值是一个对象，则该属性值保存的是这个对象的内存地址，冻结后只能保证属性值指向的内存地址 不变，而地址里面保存的内容可变。 12345678var obj = &#123; foo: 1, bar: ['a', 'b']&#125;;Object.freeze(obj);obj.bar.push('c');obj.bar // ["a", "b", "c"] 上面代码中，obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[标准库-Object对象]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%A0%87%E5%87%86%E5%BA%93-Object%2F</url>
    <content type="text"><![CDATA[Object 对象目录 [隐藏] 概述 Object() Object 构造函数 Object 的静态方法 Object.keys()，Object.getOwnPropertyNames() 其他方法 Object 的实例方法 Object.prototype.valueOf() Object.prototype.toString() toString() 的应用：判断数据类型 Object.prototype.toLocaleString() Object.prototype.hasOwnProperty() 参考链接 概述 JavaScript 原生提供Object对象（注意起首的O是大写），本章介绍Object对象各种原生方法。 JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。 Object对象的原生方法分成两类：Object自身的方法与Object的实例方法。定义在Object上和Object.prototype上的方法总和。 （1）Object 自身的方法 === Object 静态方法 所谓“本身的方法”就是直接定义在Object对象的方法。 1Object.print = function (o) &#123; console.log(o) &#125;; 上面代码中，print方法就是直接定义在Object对象上。 （2）Object的实例方法 所谓实例方法就是定义在Object构造函数的原型对象Object.prototype上的方法。它可以被Object实例直接使用。 123456Object.prototype.print = function () &#123; console.log(this);&#125;;var obj = new Object();obj.print() // obj实例 上面代码中，Object.prototype定义了一个print方法，然后生成一个Object的实例obj。obj直接继承了Object.prototype的属性和方法，可以直接使用obj.print调用print方法。也就是说，obj实例对象的print方法实质上就是调用Object.prototype.print方法。 关于原型对象object.prototype的详细解释，参见《面向对象编程》章节。这里只要知道，凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享就可以了。凡是定义在构造函数的原型对象上的方法，都可以被其实例对象所共享。 总结： 总的来说，Object 对象包括 自身属性、原生方法（自身方法、实例方法）、继承的属性和方法（__proto__）、作用域 ( [[Scopes]] ) 。 以下先介绍Object作为函数的用法，然后再介绍Object对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分。 Object() 工具函数Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。Object() 方法常用于保证某个值一定是对象。 如果参数为空（或者为undefined和null），Object()返回一个空对象。 123456var obj = Object();// 等同于var obj = Object(undefined);var obj = Object(null);obj instanceof Object // true 上面代码的含义，是将undefined和null转为对象，结果得到了一个空对象obj。 instanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例。 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）。 12345678910111213141516171819var obj = Object(1);obj instanceof Object // trueobj instanceof Number // true//相当于var obj = new Number(1)---------------------------------------------------------------------------------------------------var obj = Object('foo');obj instanceof Object // trueobj instanceof String // true//相当于var obj = new String('foo')---------------------------------------------------------------------------------------------------var obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true//相当于var obj = new Boolean(true) 上面代码中，Object函数的参数是各种原始类型的值，转换成的对象 就是 原始类型值对应的包装对象 的 实例。 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。返回对应的内存地址 1234567891011var arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true 利用这一点，可以写一个判断变量是否为对象的函数。不能区分函数、狭义对象、数组 123456function isObject(value) &#123; return value === Object(value);&#125;isObject([]) // trueisObject(true) // false Object 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 Object构造函数的首要用途，是直接通过它来生成新对象。 123var obj = new Object();// 与下面等价var obj = &#123;&#125; 注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。或者说，后者只是前者的一种简便写法。 Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）。 123456var o1 = &#123;a: 1&#125;;var o2 = new Object(o1);o1 === o2 // truevar obj = new Object(123);obj instanceof Number // true 1234var obj = Object(123)var obj = new Object(123)// 都等价于var obj = new Number(123) Object作构造函数与工具函数的区别是 两者的语义不同。Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。 Object 的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。 Object.keys()，Object.getOwnPropertyNames() -&gt; 遍历对象的属性 Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。 Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）、并且可枚举的所有属性名。 123456var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj) // ["p1", "p2"] Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。 123456var obj = &#123; p1: 123, p2: 456&#125;;Object.getOwnPropertyNames(obj) // ["p1", "p2"] Object.getOwnPropertyNames方法与Object.keys唯一的区别就是能否遍历到 对象的不可枚举属性。对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames方法还返回不可枚举的属性名。 1234var a = ['Hello', 'World'];Object.keys(a) // ["0", "1"]Object.getOwnPropertyNames(a) // ["0", "1", "length"] 上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中。 计算对象属性个数。由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。 1234567var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj).length // 2Object.getOwnPropertyNames(obj).length // 2 一般情况下，几乎总是使用Object.keys方法，遍历对象的属性。 其他方法除了上面提到的两个方法，Object还有不少其他静态方法，将在后文逐一详细介绍。除了下面列举的还有其他的方法。 （1）对象属性模型的相关方法 Object.getOwnPropertyDescriptor()：获取某个 属性描述对象。 Object.defineProperty()：通过描述对象，定义某个属性。 Object.defineProperties()：通过描述对象，定义多个属性。 （2）控制对象状态的方法 Object.preventExtensions()：防止对象扩展。 Object.isExtensible()：判断对象是否可扩展。 Object.seal()：禁止对象配置。 Object.isSealed()：判断一个对象是否可配置。 Object.freeze()：冻结一个对象。 Object.isFrozen()：判断一个对象是否被冻结。 （3）原型链相关方法 Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。 Object.getPrototypeOf()：获取对象的Prototype对象。 Object 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object的实例方法，主要有以下六个。 Object.prototype.valueOf()：返回当前对象对应的值。 Object.prototype.toString()：返回当前对象对应的字符串形式。 Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 本节介绍前四个方法，另外两个方法将在后文相关章节介绍。 Object.prototype.valueOf() 自动类型转换 valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。 12var obj = new Object();obj.valueOf() === obj // true 上面代码比较obj.valueOf()与obj本身，两者是一样的。 valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法（详见《数据类型转换》一章）。 自动类型转换的是隐式的类型转换。强制类型转换的是显式的类型转换 12var obj = new Object();1 + obj // "1[object Object]" 上面代码将对象obj与数字1相加，这时 JavaScript 就会默认调用valueOf()方法，求出obj的值再与1相加。所以，如果自定义valueOf方法，就可以得到想要的结果。 123456var obj = new Object();obj.valueOf = function () &#123; return 2;&#125;;1 + obj // 3 上面代码自定义了obj对象的valueOf方法，于是1 + obj就得到了3。这种方法就相当于用自定义的obj.valueOf，覆盖Object.prototype.valueOf。 Object.prototype.toString() 判断数据类型 toString方法的作用是返回一个对象的字符串形式，默认情况下返回对象的类型字符串。 12345var o1 = new Object();o1.toString() // "[object Object]"var o2 = &#123;a:1&#125;;o2.toString() // "[object Object]" 上面代码表示，对于一个对象调用toString方法，会返回字符串[object Object]，该字符串说明对象的类型。 字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。 1234567var obj = new Object();obj.toString = function () &#123; return 'hello';&#125;;obj + ' ' + 'world' // "hello world" 上面代码表示，当对象用于字符串加法时，会自动调用toString方法。由于自定义了toString方法，所以返回字符串hello world。 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。 12345678910111213[1, 2, 3].toString() // "1,2,3"'123'.toString() // "123"(function () &#123; return 123;&#125;).toString()// "function () &#123;// return 123;// &#125;"(new Date()).toString()// "Tue May 10 2016 09:11:31 GMT+0800 (CST)" 上面代码中，数组、字符串、函数、Date 对象调用toString方法，并不会返回[object Object]，因为它们都自定义了toString方法，覆盖原始方法。 toString() 的应用：判断数据类型 Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。 12var obj = &#123;&#125;;obj.toString() // "[object Object]" 上面代码调用空对象的toString方法，结果返回一个字符串object Object，其中第二个Object表示该值的构造函数。这是一个十分有用的判断数据类型的方法。 由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法 结合 函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。 语法： 1Object.prototype.toString.call(value) 上面代码表示对value这个值调用Object.prototype.toString方法。 不同数据类型的值的Object.prototype.toString方法返回值如下。 数值：返回[object Number]。 字符串：返回[object String]。 布尔值：返回[object Boolean]。 undefined：返回[object Undefined]。 null：返回[object Null]。 数组：返回[object Array]。 arguments 对象：返回[object Arguments]。 函数：返回[object Function]。 Error 对象：返回[object Error]。 Date 对象：返回[object Date]。 RegExp 对象：返回[object RegExp]。 Promise 对象 ：返回 [ object Promise] 其他对象：返回[object Object]。 这就是说，Object.prototype.toString可以看出一个值到底是什么类型。 123456789Object.prototype.toString.call(2) // "[object Number]"Object.prototype.toString.call('') // "[object String]"Object.prototype.toString.call(true) // "[object Boolean]"Object.prototype.toString.call(undefined) // "[object Undefined]"Object.prototype.toString.call(null) // "[object Null]"Object.prototype.toString.call(Math) // "[object Math]"Object.prototype.toString.call(&#123;&#125;) // "[object Object]"Object.prototype.toString.call([]) // "[object Array]"Object.prototype.toString.call(new Promise(() =&gt; &#123;&#125;)) // "[object Promise]" 利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。 123456789101112var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;type(&#123;&#125;); // "object"type([]); // "array"type(5); // "number"type(null); // "null"type(); // "undefined"type(/abcd/); // "regex"type(new Date()); // "date" 在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。 123456789101112131415161718192021222324var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;// 定义 type 的一些子方法['Null', 'Undefined', 'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'RegExp'].forEach(function (t) &#123; type['is' + t] = function (o) &#123; return type(o) === t.toLowerCase(); &#125;;&#125;);type.isObject(&#123;&#125;) // truetype.isNumber(NaN) // truetype.isRegExp(/abc/) // true 上面代码中，type既是函数，也可看作一个对象，可以自定义属性和方法。 Object.prototype.toLocaleString() 特地留出的接口 Object.prototype.toLocaleString方法与toString的返回结果相同，也是返回一个对象类型字符串。 123var obj = &#123;&#125;;obj.toString(obj) // "[object Object]"obj.toLocaleString(obj) // "[object Object]" 这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。 1234567891011var person = &#123; toString: function () &#123; return 'Henry Norman Bethune'; &#125;, toLocaleString: function () &#123; return '白求恩'; &#125;&#125;;person.toString() // Henry Norman Bethuneperson.toLocaleString() // 白求恩 上面代码中，toString()方法返回对象的一般字符串形式，toLocaleString()方法返回本地的字符串形式。 目前，主要有三个对象自定义了toLocaleString方法。 Array.prototype.toLocaleString() Number.prototype.toLocaleString() Date.prototype.toLocaleString() 举例来说，日期的实例对象的toString和toLocaleString返回值就不一样，而且toLocaleString的返回值跟用户设定的所在地域相关。 123var date = new Date();date.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"date.toLocaleString() // "1/01/2018, 12:01:33 PM" Object.prototype.hasOwnProperty()Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。 12345678910var obj = &#123; p: 123&#125;;obj.hasOwnProperty('p') // trueobj.hasOwnProperty('toString') // false// 等价于Object.prototype.hasOwnProperty.call(obj = &#123; p: 123 &#125;, 'p')Object.prototype.hasOwnProperty.call(obj = &#123; p: 123 &#125;, 'toString') 上面代码中，对象obj自身具有p属性，所以返回true。toString属性是继承的，所以返回false。]]></content>
  </entry>
  <entry>
    <title><![CDATA[异步操作-Promise对象]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C-Promise%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Promise 对象目录 [隐藏] 概述 Promise 对象的状态 Promise 构造函数 Promise.prototype.then() then() 用法辨析 实例：图片加载 小结 微任务 参考链接 概述 -&gt; 理解思想Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。嵌套回调函数也是为了让异步操作写起来 像 写同步操作 一样。 注意，本章只是 Promise 对象的简单介绍。为了避免与后续教程的重复，更完整的介绍请看《ES6 标准入门》的《Promise 对象》一章。 首先，Promise 是一个对象，也是一个构造函数。Promise 构造函数接受一个回调函数作为参数。回调函数里面是异步操作的代码。 12345function f1(resolve, reject) &#123; // 异步代码...&#125;var p1 = new Promise(f1); 上面代码中，Promise构造函数接受一个回调函数f1作为参数，回调函数f1里面是异步操作的代码。然后，返回的p1就是一个 Promise 对象实例。 Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。也就是先执行 Promise 构造函数里的回调函数 f1 ，再执行 then 方法里的回调函数。Promise使得传统的多层回调函数嵌套 变为 链式操作 。 12var p1 = new Promise(f1);p1.then(f2); 上面代码中，f1的异步操作执行完成，就会执行f2。 传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。 12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); 从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的Promise实例的生成格式，做了简化，真正的语法请参照下文。 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。 Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。 以下内容为真！Promise 对象的状态 -&gt; 控制异步操作 一定要理解 Promise 对象通过自身的状态，来控制异步操作。Promise 实例对象具有三种状态。 异步操作未完成（pending） 即将发生的 异步操作成功（fulfilled） 异步操作失败（rejected） 上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。 Promise实例的三种的状态的变化途径只有两种。 从“未完成”到“成功” pending -&gt; fulfilled 从“未完成”到“失败” pending -&gt; rejected 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺生效，就不得再改变了。这也意味着，Promise 实例的状态变化只会发生一次。 因此，Promise 的最终结果只有两种。 异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。 异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。 Promise 构造函数 JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。 123456789var promise = new Promise(function (resolve, reject) &#123; // ... if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; /* 异步操作失败 */ reject(new Error()); &#125;&#125;); 上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve函数和reject函数。resolve函数和reject函数，由 JavaScript 引擎提供，不用自己实现，直接用就行。 resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为函数参数传递出去。简单说，resolve函数的作用是 改变实例状态，调用函数自己，传递异步结果。 reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为函数参数传递出去。简单说，rejected函数的作用是 改变实例状态，调用函数自己，传递异步错误。 下面是一个例子。 1234567function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, &apos;done&apos;); //参数依次为回调函数名字，延迟时间，传入回调函数的参数 &#125;);&#125;timeout(100) 上面代码中，timeout(100)返回一个 Promise 实例，此时实例的状态是 pending。100毫秒以后，该实例的状态会变为fulfilled。这个根据new的原理不难理解，new命令对构造函数的操作，首先是在构造函数内部创造了实例对象，再去执行构造函数内部其他代码。应用在Promise上，则是先在 Promise 构造函数内部 生成 Promise 实例，再执行回调函数，而回调函数内部 是 异步操作。又因为Promise 通过 Promise 实例 的状态 控制异步操作，因此 Promise 构造函数 刚生成 Promise 实例对象时，Promise 实例对象 的状态是 pending。直到回调函数执行后，Promise 实例对象 的状态开始改变，一旦状态改变就凝固了（resolved）。若回调函数内部的异步操作成功，则Promise 实例对象 的状态是 fulfilled；若回调函数内部的异步操作失败，则Promise 实例对象 的状态是 rejected。 经过上面这个分析以后，再看下面的代码： 123456789101112131415161718function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done') // 'done' 就是 resolve 传出去的值 &#125;)&#125;var t2 = timeout(4000)// 马上输出 t2Promise &#123;&lt;pending&gt;&#125; __proto__: Promise [[PromiseStatus]]: "resolved" [[PromiseValue]]: "done" // &gt; 4s 后 输出 t2Promise &#123;&lt;resolved&gt;: "done"&#125; __proto__: Promise [[PromiseStatus]]: "resolved" [[PromiseValue]]: "done" 上面代码中，&#39;done&#39; 就是回调函数中异步操作成功后，由 resolve函数 传出的异步操作结果。在控制台查看 t2 这个 Promise实例，会发现 由 resolve函数 传出的异步操作结果以 [[PromiseValue]]: 5 这种形式 保存在 Promise实例 中。 改写一个看得更清楚。 123456789101112131415161718function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, '成功的异步操作结果'); &#125;);&#125;var t8 = timeout(4000)// 马上输出 t8Promise &#123;&lt;pending&gt;&#125; __proto__: Promise [[PromiseStatus]]: "resolved" [[PromiseValue]]: "成功的异步操作结果" // &gt; 4s 后 输出 t8Promise &#123;&lt;resolved&gt;: "成功的异步操作结果"&#125; __proto__: Promise [[PromiseStatus]]: "resolved" [[PromiseValue]]: "成功的异步操作结果" 若将setTimeout(resolve, ms, &#39;成功的异步操作结果&#39;);语句 改为setTimeout(resolve(&#39;成功的异步操作结果&#39;), ms);语句就看不到t8实例的 pending 状态了。这是为什么呢？ 因为 resolve(&#39;成功的异步操作结果&#39;)这是直接就调用了resolve函数，根本不会等 ms 时间以后才调用 resolve，也就是 setTimeout定时函数失去了意义。因为一定要注意 传入 setTimeout定时函数的第一个参数 应该是 回调函数名。莫因为语法犯错。 Promise.prototype.then() Promise 实例的then方法，用来添加回调函数，回调函数用来处理异步操作结果。 语法 12345678function onfulfilled(data) &#123; // 1.取promise实例传出的异步操作结果 console.log(data) // 2. 返回值作为then方法返回的promise对象 的 [[PromiseValue]] 值，同时也是后一个then(若有)的成功回调函数的参数。 return newData&#125;promise.then(onfulfilled, onrejected)// promise.then(onfulfilled, onrejected).then((data) =&gt; &#123; console.log(data)&#125;) 参数 then方法接受onfulfilled、onrejected两个回调函数。简单说，then方法的回调函数作用是，接受异步操作传回的值作为参数，并执行自己。特别注意，异步操作结果 是从 Promise构造函数内部 传向 实例对象的then方法的回调函数里。特别需要注意，onfulfilled、onrejected两个回调函数中不能再使用reject 和 resolve函数，回调函数的 return 值 会被传递出去。 onfulfilled是监听到promise对象的状态为fulfilled后，并且resolve函数后面的语句执行完毕或者后面没有语句了，才会立即调用（MDN说状态改变后，resolve将被异步调用（由当前的线程循环来调度完成））。（使用resolve函数后，会马上将 promise对象 变为fulfilled状态，并马上传出数据data） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout') console.log(p1) resolve('1') // 马上将 `promise`对象p1 变为`fulfilled`状态，并马上传出数据 '1' console.log(p1) // 先于then方法的onfulfilled回调函数执行 console.log('2') // 先于then方法的onfulfilled回调函数执行 &#125;, 2000)&#125;)var p2 = p1.then((data) =&gt; &#123; console.log(data) return 5&#125;)// 同步语句先执行console.log(p1)console.log(p2)// Promise &#123;&lt;pending&gt;&#125; 第15行执行结果// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "1"// Promise &#123;&lt;pending&gt;&#125; 第16行执行结果// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: 5// setTimeout// Promise &#123;&lt;pending&gt;&#125; //第4行执行结果// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "1"// Promise &#123;&lt;resolved&gt;: "1"&#125; //第6行执行结果// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "1"// 2// 1// 等上面输出结束了再看p2console.log(p2)// Promise &#123;&lt;resolved&gt;: 5&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: 5 onrejected是监听到promise对象的状态为rejected后，并且reject函数后面的语句执行完毕或者后面没有语句了，才会立即调用。（使用reject函数后，会马上将 promise对象 变为rejected状态，并马上传出错误error） 1234567891011var p1 = new Promise(function (resolve, reject) &#123; resolve('成功');&#125;);p1.then(console.log, console.error);// "成功"var p2 = new Promise(function (resolve, reject) &#123; reject(new Error('失败'));&#125;);p2.then(console.log, console.error);// Error: 失败 上面代码中，p1、p2都是Promise 实例，它们的then方法绑定两个回调函数：成功时的回调函数console.log，失败时的回调函数console.error（可以省略）。p1的状态变为成功，p2的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。 上下例子比较。 123456var p3 = new Promise(function (resolve, reject) &#123; reject('失败') resolve('成功') &#125;);p3.then(console.log, console.error)// 失败 上面代码中，p3，它们的then方法绑定两个回调函数：成功时的回调函数console.log，失败时的回调函数console.error（可以省略）。p3的状态变为失败，但是不会接着变为成功，因为Promise实例的状态只会发生一次变化，然后就凝固了。 返回值 then方法总是返回一个promise对象。这个promise对象是怎样的，视情况而定。下面分类讨论。 我们知道 promise对象 在控制台打出来是这样的，promise对象 托管了 异步操作的完成情况 和 操作结果 1234567891011121314promise实例 状态为 pending// Promise &#123;&lt;pending&gt;&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "resolve传出的值 or then方法的回调函数return值"promise实例 状态为 fulfilled// Promise &#123;&lt;resolved&gt;: "resolve传出的值 or then方法的回调函数return值"&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "resolve传出的值 or then方法的回调函数return值"promise实例 状态为 rejected// 待补充 情况1：then 方法的回调函数有 return 值，则 return 值 为 then 方法 返回的promise 对象的 [[PromiseValue]] 值。 若后面还有then 方法，那么这个 return 值会作为下一个then方法的成功回调函数的参数。 1234567891011121314151617181920212223242526272829var p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('promise1') resolve('leave promise1') // 马上将 `promise`对象p1 变为`fulfilled`状态，并马上传出数据'promise1' console.log('1') // 先于then方法的onfulfilled回调函数执行 &#125;, 2000)&#125;)var p2 = p1.then((data) =&gt; &#123; console.log(data) console.log('then1') return 'then return value!'&#125;)console.log(p2)// Promise &#123;&lt;pending&gt;&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "then return value!"// promise1// 1// leave promise1// then1console.log(p2)// Promise &#123;&lt;resolved&gt;: "then return value!"&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "then return value!" 上面代码中的 p1.then方法onfulfilled回调函数的return 值&#39;then return value!&#39; 则是 p1.then方法返回的promise对象 p2 的[[PromiseValue]] 的值。若then方法后面还有then，则后一个then的成功回调函数会接受前一个then传出的值（return值） 12345678910111213141516171819202122232425var p3 = p1.then((data) =&gt; &#123; console.log(data) console.log('then1') return 'then return value!'&#125;).then((data) =&gt; &#123; console.log(data) // then return value!&#125;)// 下面这句为同步任务，先执行console.log(p3)// Promise &#123;&lt;pending&gt;&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: undefined// leave promise// then1// then return value!// 等上面结果都输出后，再次log(p3)p3// Promise &#123;&lt;resolved&gt;: undefined&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: undefined 上面代码中p3 是p1.then(fn).then(fn) 返回的promise对象。可以看出第2个then成功回调函数中传入的data就是前一个then方法的return值。 第2个then的成功回调函数没有return值，所以第2个then返回的promise对象[[PromiseValue]]的值为 undefined。同时上面也可以看出then方法返回的promise对象的状态改变，可以没有return 作触发，这一点 和 new Promise(fn)返回的promise不一样，若参数函数fn中没有使用resolve 和 reject,fn执行中也没有发生错误，则无法改变promise对象的状态，promise对象的状态一直为pending，也就无法调用then方法的onfulfilled 和 onrejected两个回调函数。 还要注意的是，new Promise(fn1).then(fn2).then(fn3)这样的链式调用，只能保证fn1执行完，再执行第 1 个 then，但是后面的then方法执行顺序无法保证。并不是第一个then执行完，再执行第2个then。尤其是then方法中含有异步操作时。 情况2 then方法 的成功回调函数 return 一个 new命令造的 promise 对象。那么这个then方法返回的promise对象 与 这个 new命令造的 promise 对象 保持一致。注意这时候又可以用resolve，reject改变 promise 对象的状态了，以及控制异步操作的执行顺序，使得异步操作 写得像同步一样。这时下一个then方法的成功回调函数接受的值就是resolve传出的值了。 12345678910111213141516171819202122232425262728293031var p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout') resolve('promise1 resolve value') // 马上将 `promise`对象p1 变为`fulfilled`状态，并马上传出数据'promise1' console.log('1') // 先于then方法的onfulfilled回调函数执行 &#125;, 2000)&#125;)var p2 = p1.then((data) =&gt; &#123; console.log(data) return new Promise((resolve, reject) =&gt; &#123; console.log('promise2') resolve('promise2 resolve value') &#125;)&#125;)// 下面为同步任务先执行console.log(p2)// Promise &#123;&lt;pending&gt;&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "promise2 resolve value"// setTimeout// 1// promise1 resolve value// promise2p2// Promise &#123;&lt;resolved&gt;: "promise22"&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "promise22" 后面再加一个then 123456789101112131415161718var p3 = p2.then((data) =&gt; &#123; console.log(data) return 'then2 return value'&#125;)// 下面为同步任务先执行console.log(p3)// Promise &#123;&lt;pending&gt;&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "then2 return value"// promise2 resolve valuep3 // Promise &#123;&lt;resolved&gt;: "then2 return value"&#125;// __proto__: Promise// [[PromiseStatus]]: "resolved"// [[PromiseValue]]: "then2 return value" then方法可以链式使用。 12345678p1 .then(step1) .then(step2) .then(step3) .then( console.log, console.error ); 上面代码中，p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。 最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是成功回调函数），Promise 开始寻找第一个失败回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。 12// 2. 再返回一个promise对象，可用于Promise + then的异步串联使用 // return new Promise((resolve, reject)=&gt;&#123; // 异步操作 // resolve(data) or reject(error) &#125;) then() 用法辨析Promise 的用法，简单说就是一句话：使用then方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？ 答： Promise对象实例的then方法的链式运用，第一个then 方法的 成功回调函数 接受 Promise对象实例 传出的值 并作为参数， 失败回调函数 接受 Promise对象实例 传出的错误 并作为参数。第二个then 方法的 成功回调函数 接受 前一个 then 方法的 成功回调函数 成功执行后的返回值， 失败回调函数 接受 Promise对象实例 传出的错误 或者 前面then 方法的 成功回调函数 执行失败后 的报错 并作为参数。第三个then 方法 的 成功回调函数 接受 前一个 then 方法的 成功回调函数 成功执行后的返回值，失败回调函数 接受 Promise对象实例 传出的错误 或者 前面then 方法的 成功回调函数 执行失败后 的报错 并作为参数。以此类推。Promise 对象的报错具有传递性。 下面四种写法不过是上面原理的变形，牢记原理分析。 123456789101112131415// 写法一f1().then(function () &#123; return f2();&#125;);// 写法二f1().then(function () &#123; f2();&#125;);// 写法三f1().then(f2());// 写法四f1().then(f2); 为了便于讲解，下面这四种写法都再用then方法接一个回调函数f3。 写法一的f3回调函数的参数，是f2函数的运行结果。 123f1().then(function () &#123; return f2();&#125;).then(f3); 写法二的f3回调函数的参数是undefined。 1234f1().then(function () &#123; f2(); return;&#125;).then(f3); 写法三的f3回调函数的参数，是f2函数返回的函数的运行结果。 12f1().then(f2()) .then(f3); 写法四与写法一只有一个差别，那就是f2会接收到f1()返回的结果。 12f1().then(f2) .then(f3); 实例：图片加载下面是使用 Promise 完成图片的加载。 12345678var preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; 上面代码中，image是一个图片对象的实例。它有两个事件监听属性，onload属性监听到在图片加载成功后调用，onerror属性在监听到图片加载失败调用。调用是隐性的。 上面的preloadImage()函数用法如下。 123preloadImage(&apos;https://example.com/my.jpg&apos;) .then(function (e) &#123; document.body.append(e.target) &#125;) .then(function () &#123; console.log(&apos;加载成功&apos;) &#125;) 上面代码中，图片加载成功以后，onload属性会返回一个事件对象，因此第一个then()方法的回调函数，会接收到这个事件对象。该对象的target属性就是图片加载后生成的 DOM 节点。 小结 Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。 12345678p1 .then(asyncStep1) .then(asyncStep2) .then(asyncStep3) .then( console.log, console.error ); 而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。 ????不能理解 Promise 的缺点是，编写和阅读代码都有一定难度。编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。 微任务 Promise 的then方法的回调函数属于异步任务，会在同步任务之后执行。 1234567new Promise(function (resolve, reject) &#123; resolve(1);&#125;).then(console.log);console.log(2);// 2// 1 上面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then方法的回调函数属于异步任务，一定晚于同步任务执行。 1234567new Promise(function (resolve, reject) &#123; resolve(1); console.log(2)&#125;);console.log(3);// 2// 3 上面代码new命令所在的语句 和 console.log(3)语句都是同步任务。先执行new命令所在的语句，生成实例对象后，再执行Promise的回调函数，回调函数中的语句 resolve(1)和console.log(2) 都是同步任务，都会依次执行。本轮事件循环最后执行 console.log(3)语句。 12345678910111213var p1 = new Promise(function (resolve, reject) &#123; resolve(1); // 本轮事件循环 console.log(2); // 本轮事件循环 &#125;);p1.then(console.log); // 微任务，追加到本轮事件循环console.log(p1); // 本轮事件循环 console.log(3); // 本轮事件循环 // 2// Promise &#123;&lt;resolved&gt;: 1&#125;// 3// 1 但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务。 123456789101112setTimeout(function() &#123; console.log(1);&#125;, 0);new Promise(function (resolve, reject) &#123; resolve(2);&#125;).then(console.log);console.log(3);// 3// 2// 1 上面代码的输出结果是321。这说明**then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。** 1234567891011121314151617181920212223242526272829303132function async() &#123; let i = 0 let id = setInterval(function () &#123; console.log(i) i++ if (i &gt; 5) &#123; window.clearInterval(id) &#125; &#125;,10) &#125;let p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 2000, 'end')&#125;)console.log(p1)p1.then(console.log) .then(async) .then(() =&gt; &#123; console.log('我是第三个then，先执行')&#125;)console.log('我第2执行')// Promise &#123;&lt;pending&gt;&#125; 14行执行结果// 我第2执行 18行执行结果// end// 我是第三个then，先执行 17行执行结果// 1 4行执行结果// 2 4行执行结果// 3 4行执行结果// 4 4行执行结果// 5 4行执行结果 由上面代码可见，链式使用then方法时，then方法也不是一个一个按顺序执行的。若then的回调函数中还有异步操作，则异步操作还是会被加到任务队列里，在下一轮事件循环执行。而本轮事件则会执行完当前then方法的同步任务，就去执行下一个then方法的同步任务。 再看下面一个例子，第2 和 第3 个then 的回调函数中 都有异步任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function async1() &#123; console.log('then 1') let i = 0 let id1 = setInterval(function () &#123; console.log(i) i++ if (i &gt; 5) &#123; window.clearInterval(id1) &#125; &#125;,10) &#125;function async2() &#123; console.log('then 2') let s = 'abc' let i = 0 let id2 = setInterval(function () &#123; console.log(s[i]) i++ if (i &gt;= s.length) &#123; window.clearInterval(id2) &#125; &#125;,10) &#125;let p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 2000, 'end')&#125;)console.log(p1)p1.then(console.log) .then(async1) .then(async2)console.log('我第2执行')// Promise &#123;&lt;pending&gt;&#125;// 我第2执行// end// then 1// then 2// 0// a// 1// b// 2// c// 3// 4// 5 把setInterval的延迟时间 改成不一样。第 1 个 setInterval 延迟 5， 第 2 个 setInterval 延迟10。 结果如下： 1234567891011121314// Promise &#123;&lt;pending&gt;&#125;// 我第2执行// end// then 1// then 2// 0// 1// a// 2// 3// b// 4// 5// c 下面这个例子演示了Promise 异步串联调用 重点！！ 123456789101112131415161718192021222324252627282930313233343536373839404142function china() &#123; console.log('china') return new Promise( (resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('中国') resolve('自治区') &#125;,3000) &#125; )&#125;function gx(data) &#123; console.log('guangxi' + data) return new Promise( (resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('广西自治区') resolve('市') &#125;,2000) &#125; )&#125;function gl(data) &#123; console.log('guilin' + data) return new Promise( (resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('桂林市') resolve('临桂区') &#125;,1000) &#125; )&#125;china().then(gx).then(gl).then((data) =&gt; console.log(data))chinaPromise &#123;&lt;pending&gt;&#125;VM1962:6 中国VM1962:13 guangxi自治区VM1962:17 广西自治区VM1962:24 guilin市VM1962:28 桂林市VM1962:34 临桂区 上面代码中这种用法就是前面是用 Promise 构造函数 生成 promise，后面的then的成功回调函数里 return 一个 用 Promise 构造函数 生成 promise，实际上都是为了能一直使用resolve 和 reject 来改变promise对象状态，从而控制异步操作的执行顺序，这样then就一个个执行了，异步代码写得和同步一样。关键是 让回调函数有 Promise 功能，即 回调函数要return new Promise((resolve, reject) =&gt; {}) 当then方法的回调函数需要参数时，就不得不使用一个匿名函数包裹，并且要在这个匿名函数内 return 原来的回调函数。这样后面then才能收到原来 回调函数 用 resolve传出的值。 1234567891011121314151617181920212223242526272829303132writeCode('', result) .then((data) =&gt; &#123; console.log(data) return createPaper() &#125;) .then((data) =&gt; &#123; console.log(data) return writeCode(result, result2) // writeCode需要参数，所以用箭头函数包裹，再 return 出去，这样writeCode内部用resolve 传出的值 // 才能被后面的then 获取到 &#125;) .then((data) =&gt; &#123; console.log(data) return writeMarkdown(md) &#125;) .then((data) =&gt; &#123; console.log(data) return writeCode(result + result2, result3) &#125;) .then((data) =&gt; &#123; console.log(data) return markdownToHtml() &#125;) .then((data) =&gt; &#123; console.log(data) return writeCode(result + result2 + result3, result5) &#125;) .then((data) =&gt; &#123; console.log(data) console.log('简历完成') &#125;) 上面这个代码我错了好多次啊啊！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6编程风格]]></title>
    <url>%2F2019%2F08%2F09%2FES6%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[编程风格 块级作用域 字符串 解构赋值 对象 数组 函数 Map 结构 Class 模块 ESLint 的使用 本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。 多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。 1 块级作用域（1）let 取代 var ES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。建议不再使用var命令，而是使用let命令取代. （2）全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。所有的函数都应该设置为常量。 const优于let有几个原因。 一个是const可以提醒阅读程序的人，这个变量不应该改变； 另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算； 最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说**let和const的本质区别，其实是编译器内部的处理不同**。 1234567891011// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3];// 使用const + 数组的解构赋值 const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个变量的值，二是防止了无意间修改变量值所导致的错误。 长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串 静态字符串一律使用单引号或反引号，不使用双引号。 动态字符串使用反引号。模板字符串 12345678910// badconst a = "foobar";const b = 'foo' + a + 'bar';// acceptableconst c = `foobar`;// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`; 解构赋值 使用数组成员对变量赋值时，优先使用数组的解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// good 推荐const [first, second] = arr; 函数的参数如果是对象的成员，优先使用对象的解构赋值。 1234567891011121314151617// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125;// 函数调用getFullName (obj) 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象 单行定义的对象，最后一个成员不以逗号结尾。 多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。对象的属性名是动态的意思是对象的属性名需要计算得出。 12345678910111213// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 ！！！！ 1234567891011121314151617181920212223var ref = 'some value';// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 上面atom对象的ref属性的属性名和属性值相同，可简写。注意上面对象的方法简写，省略了function关键字。 数组 使用扩展运算符（…）拷贝数组。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 上面代码中items 和 itemsCopy 都是对象。 使用 Array.from 方法，将类似数组的对象转为数组。 推荐 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 补充：Array.prototype.slice.call(类数组对象) 和 [].slice.call(类数组对象) 都能将类数组对象 转为 数组。 函数 立即执行函数可以写成箭头函数的形式。立即执行函数一般是匿名函数。 123(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)(); 使用 箭头函数 代替 匿名函数作参数。因为这样更简洁，而且绑定了 this。 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。 ？？？？ 1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; divide函数的解构赋值 不要在函数体内使用 arguments 对象，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); //args 为 数组 return args.join(''); //string&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 上面代码第一个方法是使用了 Array.prototype.slice.call(arguments)先将 类数组对象 转为 args数组。数组里则是传入函数的所有参数。而是第二种方法则是 使用 rest 运算符（…），使得args变量 直接获取所有传入参数，就是参数数组。 使用默认值语法设置函数参数的默认值。 注意区分，这不是函数参数解构赋值。 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map 结构注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。也就是说，对象有实体意义，而 Map 只是一种常用的结构。 12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; 上面代码有 Map 结构很多方法 Class 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; // contents 必是一个数组 &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块 首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。 1234567// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from 'moduleA'; 使用export取代`module.exports`。 123456789101112131415161718192021// commonJS的写法var React = require('react');var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from 'react';class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default， 如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 12345// badimport * as myObject from './importModule';// goodimport myObject from './importModule'; 如果模块默认输出一个函数，函数名的首字母应该小写。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; ESLint 的使用ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装 ESLint。 1$ npm i -g eslint 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。 12$ npm i -g eslint-config-airbnb$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。 123&#123; "extends": "eslint-config-airbnb"&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。 12345678var unusued = 'I have no purpose!';function greet() &#123; var message = 'Hello, World!'; alert(message);&#125;greet(); 使用 ESLint 检查这个文件，就会报出错误。 123456789$ eslint index.jsindex.js 1:1 error Unexpected var, use let or const instead no-var 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 4:5 error Unexpected var, use let or const instead no-var 5:5 error Expected indentation of 2 characters but found 4 indent✖ 5 problems (5 errors, 0 warnings) 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。 参考本文大部分内容来自 阮一峰文档，若有侵权，请联系我删除。]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符串的扩展]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[字符串的扩展 字符的 Unicode 表示法 字符串的遍历器接口 直接输入 U+2028 和 U+2029 JSON.stringify() 的改造 的改造) 模板字符串 实例：模板编译 标签模板 模板字符串的限制 本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。 字符的 Unicode 表示法 ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 \uxxxx 表示法只限于码点在\u0000~\uFFFF之间的字符（2字节 UTF-8） 12"\u0061"// "a" 超出\u0000~\uFFFF这个范围的字符，必须用两个双字节的形式表示。（四字节的 UTF-16 编码） 1234567// 四字节 UTF-16 编码"\uD842\uDFB7"// "𠮷"// 下面表示法JS引擎会解析错误"\u20BB7"// " 7" 上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（16进制）（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6 对这一点做出了改进，不论Unicode码点的范围，只要将 Unicode 码点放入大括号，就能正确解读该字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80' // true // "🚀" 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 12345'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // true 字符串的遍历器接口ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。 基本用法 for...of遍历字符串的字符 123456for (let value of 'foo') &#123; console.log(value)&#125;// "f"// "o"// "o" 注意，for...in 是遍历对象的键值。 12345for (let key in &#123;a: 1, b: 2&#125; ) &#123; console.log(key)&#125;// 'a'// 'b' 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的Unicode码点，也就是说会将这个码点视作一个字符，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7); //string类型for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// " "// " "for (let i of text) &#123; console.log(i);&#125;// "𠮷" 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\u4e2d，两者是等价的。 1'中' === '\u4e2d' // true 但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+2028：行分隔符（line separator） ES2019允许出现了 U+2029：段分隔符（paragraph separator）ES2019允许出现了 U+000A：换行符（line feed） 举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\\或者\u005c。 12345\u005C\u000D\u2028\u2029\u000A 这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被JSON.parse解析，就有可能直接报错。 12const json = '"\u2028"';JSON.parse(json); // 可能报错 JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。 1const PS = eval("'\u2029'"); 根据这个提案，上面的代码不会报错。 注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。 JSON.stringify() 的改造根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。 具体来说，UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\uD834\uDF06是两个Unicode码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\uD834和\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\uDF06\uD834并没有对应的字符。 JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。 12// 下面不对JSON.stringify('\u&#123;D834&#125;') // "\u&#123;D834&#125;" 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。 12JSON.stringify('\u&#123;D834&#125;') // "\"\\ud834\"" 或 '"\\ud834"'JSON.stringify('\uDF06\uD834') // "\"\\udf06\\ud834\"" 模板字符串传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量 。 1234567891011121314151617// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`// "In JavaScript this is// not legal."console.log(`string text line 1string text line 2`)// string text line 1// string text line 2// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。原模原样输出。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 ${变量名/函数调用/表达式/对象} 123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// "1 + 4 = 5"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// "3" 模板字符串之中还能调用函数。 123456function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 大括号里预期的值为字符串类型，如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 列出以下情况 123456console.log(`$&#123;null&#125;`) //'null'console.log(`$&#123;undefined&#125;`) // 'undefined'console.log(`$&#123;1&#125;`) // '1'console.log(`$&#123;true&#125;`) // 'true'console.log(`$&#123;'abc'&#125;`) // 'abc' console.log(`$&#123;&#123;&#125;&#125;`) // '[object Object]' 如果模板字符串中的变量没有声明，将报错。 12// 变量place没有声明let msg = `Hello, $&#123;place&#125;` // Uncaught ReferenceError: place is not defined 模板字符串甚至还能嵌套。 12345678const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 123456789101112131415const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以写成函数。箭头函数 的 返回值？？ 12let func = (name) =&gt; `Hello $&#123;name&#125;!`;func('Jack') // "Hello Jack!" 上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。 12let func = (name) =&gt; `Hello $&#123;name&#125;!`;func('Jack') // "Hello Jack!" 上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。 实例：模板编译实例：模板编译 ？？？？看不懂下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\s\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template)&#123; const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ "broom", "mop", "cleaner" ] &#125;);// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板 -&gt; 函数调用 -&gt; 处理数据模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用 来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。语法：函数名模板字符串 标签模板实际是另一种函数调用，首先拆分模板字符串，得到参数并传入标签函数，再调用标签函数，可在函数内部处理这些参数。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数名，紧跟在后面的模板字符串就是它的参数。上面代码是 标签模板 的 模板字符串 里没有变量的情况。 123456log`abc`function log(arg) &#123; console.log(arg) console.log(arg instanceof Array) //true&#125;// ["abc", raw: Array(1)] 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 处理模板字符串的规则如下： 123456let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个标签模板表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 12345678910function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于// tag函数采用test参数写法 推荐function tag(stringArr, ...values)&#123; // ...&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换一定是发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。（这个可以从模板字符串的插值语法中推导。） 模板处理函数tag的第一个参数（模板字符串数组），还有一个raw属性，用来得到原始字符串。 12console.log`123`// ["123", raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 1234567tag`First line\nSecond line`function tag(strings) &#123; console.log(strings[0]) // "First line // Second line" console.log(strings.raw[0]) // "First line\\nSecond line" &#125; 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[&quot;First line\nSecond line&quot;]，那么strings.raw数组就是[&quot;First line\\nSecond line&quot;]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。 tag函数的其他参数，依次是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。（在tag函数内部查看arguments对象可以查看所有传入函数的参数） 第一个参数：[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 12345678910111213141516171819let a = 5;let b = 10;function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return "OK";&#125;tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;// "Hello "// " world "// ""// 15// 50// "OK" 下面是一个更复杂的例子。下面这个标签模板 是首先拆分模板字符串成各个参数并传入标签函数，标签函数内部按顺序用字符串连接参数，并return回去。 123456789101112131415161718let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; let result = ''; let i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; // '+'拼接字符串的作用 if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // "The total is 30 (31.5 with tax)" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。依照前面介绍标签模板的语法，上面的代码中形参literals只是传入函数的第一个参数数组，是模板字符串中没有被变量替换的部分。故 passthru标签函数的逻辑是先取数组一个元素，再取第一个被变量替换的值，然后再取数组第二个元素，取第二个被变量替换的值，依次类推，实现了将各个参数按原来位置拼合回去。 passthru函数采用 rest 参数的另一种写法如下。 1234567891011121314let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`function passthru(literals, ...values) &#123; let output = ""; let index; for (index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index] return output;&#125;msg // "The total is 30 (31.5 with tax)" “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的应用 多语言转换（国际化处理）。 12i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// "欢迎访问xxx，您是第xxxx位访问者！" ​ 2. 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate` &lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end &lt;/ul&gt;`; ​ 3. 使用标签模板，在 JavaScript 语言之中嵌入其他语言。 123456789jsx` &lt;div&gt; &lt;input ref='input' onChange='$&#123;this.handleChange&#125;' defaultValue='$&#123;this.state.value&#125;' /&gt; $&#123;this.state.value&#125; &lt;/div&gt;` 上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到jsx函数的具体实现。 ​ 4. 下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。 12345678java`class HelloWorldApp &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); // Display the string. &#125;&#125;`HelloWorldApp.main(); 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。 举例来说，标签模板里面可以嵌入 LaTEX 语言。 1234567891011function latex(strings) &#123; // ...&#125;let document = latex`\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125; // 正常工作\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错Breve over the h goes \u&#123;h&#125;ere // 报错` 上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 模板字符串会将\u00FF和\u{42}当作 Unicode 字符进行转义，所以\unicode解析时报错；而\x56会被当作十六进制字符串转义，所以\xerxes会报错。也就是说，\u和\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。 为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 12345function tag(strs) &#123; strs[0] === undefined strs.raw[0] === "\\unicode and \\u&#123;55&#125;";&#125;tag`\unicode and \u&#123;55&#125;` 上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。 注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。 1let bad = `bad escape sequence: \unicode`; // 报错]]></content>
  </entry>
  <entry>
    <title><![CDATA[变量的解构赋值]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[变量的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 数组的解构赋值 对象的解构赋值 函数参数的解构赋值 圆括号问题 用途 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 解构赋值虽然有点绕，用熟了以后会让代码很漂亮。 数组的解构赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。现在ES6 允许写成下面这样。 1234567//ES5let a = 1;let b = 2;let c = 3;//ES6let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。解构有成功和不成功两种结果。解构成功分为完成结构和不完全解构。 下面是一些使用嵌套数组进行解构的例子。 解构成功 12345678910// 变量数量 === 值的个数let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3// 变量数量 &lt; 值的个数let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4] 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 123456789101112131415let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3 解构不成功，变量的值就等于undefined。 123456789101112// 变量数量 &gt; 值的个数 --&gt; 解构不成功let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []let [foo] = []foo // undefinedlet [bar, roo] = [1]bar //1roo //undefined 以上3种情况都属于解构不成功，y、foo 和 roo的值都会等于undefined。 事实上，只要某种数据结构具有 Iterator （遍历器）接口，都可以采用数组形式的解构赋值。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员） 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 对于 Set 结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 12345678// 转为对象以后不具备lterator接口let [foo] = 1;let [foo] = NaN;let [foo] = false;let [foo] = undefined;let [foo] = null;// 本身就不具备 Iterator 接口let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。 默认值 解构赋值允许指定默认值。注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 1234567let [foo = true] = [] //foo===truelet [x, y = 'b'] = ['a']; // x==='a', y==='b'let [x, y = 'b'] = ['a', undefined]; // x==='a', y==='b'let [x = 1] = [undefined] //x === 1let [x = 1] = [null] // x === null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值，也就是说，只有当右边数组元素严格等于undefined时，表达式才会求值。 12345function f() &#123; console.log('aaa')&#125;let [x = f()] = [1] 上面代码中，因为x能取到值1，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 1234567// [1][0] 表示数组[1]的第0个元素let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 下面代码中，因为左边x对应右边数组元素的值为undefined。所以函数f执行了。 123456function f() &#123; return 'f'&#125;let [x = f()] = []x // 'f' 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。上面第二个表达式也要注意。 对象的解构赋值简介 解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子，变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果解构失败，变量的值等于undefined。若等号右边的对象没有与变量同名的属性，则解构失败。 12let &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 上面代码中，等号右边的对象没有foo属性，所以变量foo取不到值，所以等于undefined。 对象的解构赋值的理解，可以很方便地将现有 对象的方法，赋值到某个变量。模式名和变量名相同时，语法： let { 模式名(变量名) } = 对象 123456// 例一let &#123; log, sin, cos &#125; = Math;// 例二const &#123; log, dir, error &#125; = console;log('hello') // hello 上面代码的例一将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。 如果变量名与属性名不一致，必须写成下面这样。let { 模式名：变量名 } = 对象 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。也就是说在等号左边，当变量和模式同名时，可采用简写的形式。 123let &#123; foo: foo, bar: bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;// 简写let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 与数组一样，解构也可以用于嵌套结构的对象。 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 上面的代码中，等号左边的第一个p是变量，第二个p是模式。 下面是另一个例子。 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node; // 等号左边，紫色是变量，白色是模式。line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。 下面是嵌套赋值的例子。模式不用声明，变量必须声明。 1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。模式匹配是按层递进的。 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; // Cannot destructure property `bar` of 'undefined' or 'null'. 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错。 注意，对象的解构赋值可以取到继承的属性。 123456const obj1 = &#123;&#125;;const obj2 = &#123; foo: 'bar' &#125;;Object.setPrototypeOf(obj1, obj2);const &#123; foo &#125; = obj1;foo // "bar" 上面代码中，对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。 默认值 对象的解构也可以指定默认值。 12345678910111213var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;; // x 是 模式 ，y是变量y // 3x // Uncaught ReferenceError: x is not definedvar &#123;x: y = 3&#125; = &#123;x: 5&#125;; // x 是 模式 ，y是变量y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。 1234567var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 注意点（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。 1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;) 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 （2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 （3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。?????? 字符串的解构赋值– 解的字符串的值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 等号右边的基本类型都会被转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值 推荐！！代码简洁 函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在函数被传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 解构解构，就是将对象解构为单个值，再为变量赋值，即为解构赋值。 下面是另一个例子。 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 123456789function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 传入的对象实参 会 代替 对象形参move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号。 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; （3）赋值语句的模式 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 （1）交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 更方便 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516171819// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example()a // 1b // 2c // 3// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 非常重要！！！ 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值 代码漂亮 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。代码很漂亮啊 （6）遍历 Map 结构 ?? for…of遍历 + 变量的解构赋值 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123;// 对比 for (let key in obj) &#123; console.log(key + " is " + obj[key])&#125; console.log(key + " is " + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6-let命令和const命令]]></title>
    <url>%2F2019%2F08%2F08%2FES6-let%E5%91%BD%E4%BB%A4%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[let 和 const 命令 let 命令 块级作用域 const 命令 顶层对象的属性 globalThis 对象 let 命令 基本用法 暂时性死区 不存在变量提升 不允许重复声明同名变量 基本用法 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是let命令所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令声明。 例1 基本示例 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 例2 分别使用var和let命令声明for循环的计数器，有什么不同？ 使用var声明for循环的计数器，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致函数调用时输出的是for循环结束后i的值，10。 上面的代码相当于 123456789var a = []var ifor (i = 0; i &lt; 10; i++) &#123; a[i] = f&#125;function f() &#123; console.log(i)&#125;a[6]() //10 使用let命令声明for循环的计数器i，声明的变量i仅在块级作用域内有效，最后输出的是 6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 例子3 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明循环体内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。若循环体内部的变量i与循环变量i处在同一个作用域，使用let 声明它们的时候就会报错。例如下面这个代码 1234&#123; let i = 0 let i = 0 //Uncaught SyntaxError: Identifier 'i' has already been declared&#125; 上面第三行代码在同一个区块内用let重复声明变量i,就会报错。因为let命令不允许在同一个区块内重复声明同一个变量i。 不存在变量提升var命令会发生“变量提升”现象，即变量可以在声明之前使用，变量值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 12345var tmp = 123;if (true) &#123; var tmp = 'abc'; // ReferenceError let tmp;&#125; 12345var tmp = 123if (true) &#123; let tmp console.log(tmp) //undefined&#125; ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从区块一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的，简单说，就是这个变量不能出现在let命令之前，否则就报错。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 “暂时性死区”TDZ范围：从区块开始，到let命令声明变量tmp之前，都属于变量tmp的“死区”。 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。(安全的意思是 使用了会不会报错） 123//TDZ开始typeof x; // Uncaught ReferenceError: Cannot access 'x' before initializationlet x; //TDZ结束 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // "undefined" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y]&#125;bar() // Cannot access 'y' before initialization 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。因此块作用域内的每个变量都有一个暂时性死区。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 12345678910111213141516171819// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125;//不报错let a = 1&#123; let a = 2 console.log(a) //2&#125;console.log(a) //1 因此，不能在函数体内部重新声明形参。换句话说，形参部分()和函数体内部{} 是同一作用域。 12345678910111213function func(arg) &#123; let arg&#125;func() // 报错function func(arg) &#123; &#123; let arg = 1 console.log(arg) //1 &#125; console.log(arg) //undefined&#125;func() // 不报错 块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。上面代码等同于下面代码： 1234567891011var tmp = new Date();function f() &#123; var tmp //变量提升 console.log(tmp); //undefined if (false) &#123; tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域 let实际上为 JavaScript 新增了块级作用域。 123456789function f1() &#123; let n = 5; if (true) &#123; let n = 10; console.log(n) //10 &#125; console.log(n); // 5&#125;f1() 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块(函数体区块）不受内层代码块（if区块)的影响。如果两次都使用var定义变量n，最后输出的值才是 10。内层代码块（if区块)里的变量a会覆盖外层代码块(函数体区块）里的变量a。 ES6 允许块级作用域的任意嵌套。内层作用域可以读 但不可以改写外部作用域里的局部变量，外部作用域无法读写部作用域的局部变量。 上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 12345678function f1() &#123; let a = 1 function f2() &#123; console.log(a) &#125; f2() //1&#125;f1() 1234567891011function f1() &#123; let a = 1 function f2() &#123; let a console.log(a) &#125; f2() //undefined console.log(a) //1&#125;f1() console.log(a) // Uncaught ReferenceError: a is not defined 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; //声明局部变量 ...&#125;());// 块级作用域写法&#123; let tmp = ...; //let声明的就是局部变量 ...&#125; 块级作用域与函数声明不建议在块级作用域内写函数声明语句。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。并且ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 不建议使用 123456789function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被整体提升到函数头部，实际运行的代码如下。 12345678910// 浏览器的 ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f f = function () &#123; console.log('I am inside!') &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内函数声明语句似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 1234567891011// 浏览器的 ES6 环境 如jsbin.comfunction f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码在 ES6 浏览器中，都会报错。 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。但不是整体提升,只提升变量声明，不提升函数赋值 同时，函数声明还会提升到所在的块级作用域的头部。注意是 整体函数提升。 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明语句当作let处理。 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。 12345678910111213// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f //只提升变量声明 if (false) &#123; var f //整体函数提升 f = function () &#123; console.log('I am inside!') // 重复声明一次函数f &#125; f();&#125;());// Uncaught TypeError: f is not a function 可从下面代码推断出来 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。但不是整体提升,只提升变量声明，不提升函数赋值 123456789101112131415161718192021222324// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; console.log(f) // undefined f() // Uncaught TypeError: f is not a function if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125;&#125;());--------------------------------------------------------------------------------------------------// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; console.log(f) //undefined f() //// Uncaught TypeError: f is not a function&#125;()); 123456789101112// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!') &#125;(function () &#123; if (true) &#123; console.log(f) //ƒ f() &#123; window.runnerWindow.proxyConsole.log('I am inside!') &#125; f() // 'I am inside!' // 重复声明一次函数f function f() &#123; console.log('I am inside!') &#125; &#125;&#125;()) 上面代码可推出函数声明还会提升到所在的块级作用域的头部。注意是 整体函数提升。 但是 函数作用域可以访问if区块里面的函数f，为什么呢？ 12345678910111213141516171819202122232425262728293031323334// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!') &#125;(function () &#123; // 变量声明提升 console.log(f) //undefined f() // Uncaught TypeError: f is not a function if (true) &#123; // 函数声明整体提升 console.log(f) //ƒ f() &#123; window.runnerWindow.proxyConsole.log('I am inside!') &#125; f() // 'I am inside!' // 重复声明一次函数f function f() &#123; console.log('I am inside!') &#125; &#125; &#125;)()---------------------------------------------------------------------------------------------------// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!') &#125;(function () &#123; if (true) &#123; console.log(f) //ƒ f() &#123; window.runnerWindow.proxyConsole.log('I am inside!') &#125; f() // 'I am inside!' // 重复声明一次函数f function f() &#123; console.log('I am inside!') &#125; &#125; // 为什么这里可以访问函数f ？????? console.log(f) //ƒ f() &#123; window.runnerWindow.proxyConsole.log('I am inside!') &#125; f() // 'I am inside!'&#125;)() 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 12345678910111213141516171819202122232425// 块级作用域内部的函数声明语句，建议不要使用&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 等价于&#123; let f f = function () &#123; return a; &#125; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 块级作用域内部，优先使用函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 1234567// 第一种写法，报错if (true) let x = 1; // Uncaught SyntaxError: Lexical declaration cannot appear in a single-statement context// 第二种写法，不报错if (true) &#123; let x = 1;&#125; 上面代码中，第一种写法没有大括号，所以不存在块级作用域，而let只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 1234567891011// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125;// Uncaught SyntaxError: In strict mode code, functions can only be declared at top level or inside a block. const 命令基本用法 const声明一个只读的常量。一旦声明，常量的值就不能改变。本质是变量指向的内存地址里保存的数据不变。 1234const PI = 3.1415;PI // 3.1415PI = 3; //Uncaught TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = "Hello!";let age = 25;// 以下两行都会报错const message = "Goodbye!";const age = 30; 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于这个固定地址里保存的数据是不是可变的，就不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;; // foo保存的是对象&#123;&#125;的引用，也就是对象的内存地址// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // Assignment to constant variable. 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就是要改变a保存的内存地址，则报错。 如果真的想将对象冻结，应该使用Object.freeze方法。将对象冻结以后，就不能修改对象的属性。 123456789// 常规模式const foo = Object.freeze(&#123;&#125;);foo.prop = 123; // 不起作用console.log(foo) // &#123;&#125;// 严格模式'use strict'const foo = Object.freeze(&#123;&#125;);foo.prop = 123; // VM4899:3 Uncaught TypeError: Cannot add property prop, object is not extensible 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 上面的代码会递归的检查对象的属性值的类型，若对象的属性值还是一个对象，则继续调用constantize。 ES6 声明变量的六种方法 ES5 只有两种声明变量的方法：var命令和function命令。 ES6 有6种声明变量的方法：var function let const import class 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。也就是说，在ES5中，定义了一个全局变量，就是定义了一个顶层对象的属性。 12345window.a = 1; //顶层对象的属性a // 1 全局变量a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 123// ES5var c = &#123;&#125;window.c === c //true 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 globalThis 对象 - 提案JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一 ？？(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self &#125; if (typeof window !== 'undefined') &#123; return window &#125; if (typeof global !== 'undefined') &#123; return global &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。 参考本文大部分内容来自 阮一峰文档，若有侵权，请联系我删除。]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334setLyrics(lyrics) &#123; // 把时间和歌词两部分摘出来，再放进去 this.lyricIndex = 0 let fragment = document.createDocumentFragment() let lyricsArr = [] this.lyricsArr = lyricsArr // this.lyricsArr 类的属性不用声明 lyrics.split(/\n/) .filter(str =&gt; str.match(/\[.+?\]/)) //所有带[05:45]的 .forEach(line =&gt; &#123; let regexp = /\[.+?\]/g let str = line.replace(regexp, '').trim() //去掉时间后的歌词 let t = regexp.exec(line)[0].replace(/[\[\]]/g, '').trim() // regexp.exec(line)[0] 是 [时间] replace(/[\[\]]/g, '')可以去除边界[] lyricsArr.push([t, str]) // line.match(regexp).forEach(t=&gt;&#123; // t = t.replace(/[\[\]]/g,'') // let milliseconds = parseInt(t.slice(0,2))*60*1000 + parseInt(t.slice(3,5))*1000 + parseInt(t.slice(6)) // lyricsArr.push([milliseconds, str]) // &#125;) &#125;) // 过滤无歌词的line,、歌词时间排序、虚拟dom lyricsArr.filter(line =&gt; line[1] !== '') .sort((v1, v2) =&gt; &#123; return v1[0] &gt; v2[0] ? 1 : -1&#125;) .forEach(line =&gt; &#123; let node = document.createElement('p') node.setAttribute('data-time', line[0]) node.innerText = line[1] fragment.appendChild(node) &#125;) // lyricsArr = ["未更新"] // console.log(lyricsArr) console.log(this.lyricsArr) this.$('.panel-2 .lyrics').innerHTML = '' this.$('.panel-2 .lyrics').appendChild(fragment) &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SVG使用]]></title>
    <url>%2F2019%2F07%2F10%2FSVG%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[方式一直接在html里使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;SVG使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;svg style="position: absolute;width: 0;height: 0;overflow: hidden;" width="120px" height="120px" viewBox="0 0 120 120" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt; &lt;!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch --&gt; &lt;symbol id="icon-pre" viewBox="0 0 120 120"&gt; &lt;title&gt;上一首&lt;/title&gt; &lt;desc&gt;Created with Sketch.&lt;/desc&gt; &lt;defs&gt; &lt;radialGradient cx="50%" cy="50%" fx="50%" fy="50%" r="50%" gradientTransform="translate(0.500000,0.500000),scale(1.000000,0.994186),translate(-0.500000,-0.500000)" id="radialGradient-1"&gt; &lt;stop stop-color="#AC2D73" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#120A82" offset="92%"&gt;&lt;/stop&gt; &lt;stop stop-color="#07006B" offset="100%"&gt;&lt;/stop&gt; &lt;/radialGradient&gt; &lt;linearGradient x1="90.5072268%" y1="20.6957496%" x2="9.4941375%" y2="79.3043243%" id="linearGradient-2"&gt; &lt;stop stop-color="#3B2EE8" stop-opacity="0.2" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#FC429F" offset="25%"&gt;&lt;/stop&gt; &lt;stop stop-color="#B639E5" offset="87%"&gt;&lt;/stop&gt; &lt;stop stop-color="#FCFCFC" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="126.40209%" y1="13.5040932%" x2="-24.1592819%" y2="87.2715353%" id="linearGradient-3"&gt; &lt;stop stop-color="#FC429F" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#3B2EE8" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="67.8867993%" y1="30.9688504%" x2="75.4688625%" y2="21.1618118%" id="linearGradient-4"&gt; &lt;stop stop-color="#FC57A9" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#FCFCFC" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="61.4131653%" y1="33.8941487%" x2="39.4202448%" y2="71.4869303%" id="linearGradient-5"&gt; &lt;stop stop-color="#B639E5" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#3B2EE8" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="92.2146132%" y1="-4.63859816%" x2="10.4535745%" y2="110.070945%" id="linearGradient-6"&gt; &lt;stop stop-color="#FC429F" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#B639E5" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"&gt; &lt;g id="iPhone-8" transform="translate(-177.000000, -29.000000)"&gt; &lt;g id="上一首" transform="translate(177.000000, 29.000000)"&gt; &lt;g id="图-资源-12"&gt; &lt;ellipse id="Oval" fill="url(#radialGradient-1)" cx="60" cy="60.3278689" rx="56.0655738" ry="56.3934426"&gt;&lt;/ellipse&gt; &lt;path d="M59.9548308,5.61469731 C86.7262364,5.59034291 109.53495,25.1646104 113.727249,51.7617846 C117.919548,78.3589588 102.24883,104.07023 76.7829298,112.377093 C51.3170297,120.683956 23.6283668,109.116322 11.5058441,85.1059517 C-0.616678668,61.0955812 6.4316347,31.7820844 28.1225135,15.9982575 C37.381525,9.2515634 48.5217809,5.61766153 59.9548308,5.61469731 Z M59.9548308,3.93450958 C33.9678996,3.96156583 11.4045662,21.9459534 5.43790156,47.387911 C-0.528763057,72.8298686 11.6648878,99.0619808 34.8998782,110.769246 C42.7110885,114.676325 51.3147233,116.713418 60.0383473,116.721311 C81.0928073,116.708669 100.365002,104.83052 109.936925,85.9670171 C119.508848,67.1035138 117.766372,44.4356389 105.425394,27.2765176 C94.8863331,12.5904686 77.9653263,3.9033857 59.9590067,3.93450958 L59.9548308,3.93450958 Z" id="Shape" fill="url(#linearGradient-2)" fill-rule="nonzero"&gt;&lt;/path&gt; &lt;path d="M3.10837279,78.6885246 C-5.35495222,53.4533715 3.8779541,25.6687872 25.7703616,10.4918033 L28.852459,14.9558468 C8.92145404,28.7385915 0.519285038,54.0210331 8.24380779,76.9680513 L3.10837279,78.6885246 Z" id="Path" fill="url(#linearGradient-3)"&gt;&lt;/path&gt; &lt;path d="M114.245163,65.6499501 C116.372688,46.0329572 107.677121,26.8058523 91.5234854,15.4091655 C75.3698494,4.01247878 54.2926478,2.23434907 36.4483634,10.7628794 L34.0983607,5.8762456 C53.7206607,-3.5030912 76.898549,-1.5488063 94.6627212,10.9828374 C112.426893,23.5144812 121.990192,44.6572978 119.651842,66.2295082 L114.245163,65.6499501 Z" id="Path" fill="url(#linearGradient-4)"&gt;&lt;/path&gt; &lt;path d="M54.6247073,120 C35.5244375,118.320115 18.3772721,107.417802 8.52459016,90.6891545 L13.1637002,87.8688525 C22.1211082,103.081395 37.7137233,112.995026 55.0819672,114.520073 L54.6247073,120 Z" id="Path" fill="url(#linearGradient-5)"&gt;&lt;/path&gt; &lt;path d="M64.6784245,119.344262 L64.2622951,113.931055 C86.6626643,112.2425 105.714136,96.9321406 112.196238,75.4098361 L117.377049,76.9630103 C110.258865,100.635232 89.3126319,117.480598 64.6784245,119.344262 Z" id="Path" fill="url(#linearGradient-6)"&gt;&lt;/path&gt; &lt;/g&gt; &lt;g id="Group" transform="translate(62.295082, 61.639344) scale(-1, 1) translate(-62.295082, -61.639344) translate(40.655738, 40.655738)" fill="#FFFFFF"&gt; &lt;path d="M30.013345,18.4824896 C31.9627648,19.8670855 31.9627648,22.0908305 30.013345,23.4754264 L3.51281591,41.3283223 C1.56339608,42.7129182 -3.77064001e-08,41.7688755 0,39.2514284 L0,2.70648765 C0,0.189040535 1.5826973,-0.734023408 3.51281591,0.629593776 L30.013345,18.4824896 Z" id="Path"&gt;&lt;/path&gt; &lt;rect id="Rectangle" fill-rule="nonzero" x="36.7213115" y="0" width="6.55737705" height="41.9672131" rx="3.27868852"&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; &lt;/symbol&gt; &lt;symbol id="icon-next"&gt; &lt;title&gt;下一首&lt;/title&gt; &lt;desc&gt;Created with Sketch.&lt;/desc&gt; &lt;defs&gt; &lt;radialGradient cx="50%" cy="50%" fx="50%" fy="50%" r="50%" gradientTransform="translate(0.500000,0.500000),scale(1.000000,0.994186),translate(-0.500000,-0.500000)" id="radialGradient-1"&gt; &lt;stop stop-color="#AC2D73" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#120A82" offset="92%"&gt;&lt;/stop&gt; &lt;stop stop-color="#07006B" offset="100%"&gt;&lt;/stop&gt; &lt;/radialGradient&gt; &lt;linearGradient x1="90.5072268%" y1="20.6957496%" x2="9.4941375%" y2="79.3043243%" id="linearGradient-2"&gt; &lt;stop stop-color="#3B2EE8" stop-opacity="0.2" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#FC429F" offset="25%"&gt;&lt;/stop&gt; &lt;stop stop-color="#B639E5" offset="87%"&gt;&lt;/stop&gt; &lt;stop stop-color="#FCFCFC" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="126.40209%" y1="13.5040932%" x2="-24.1592819%" y2="87.2715353%" id="linearGradient-3"&gt; &lt;stop stop-color="#FC429F" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#3B2EE8" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="67.8867993%" y1="30.9688504%" x2="75.4688625%" y2="21.1618118%" id="linearGradient-4"&gt; &lt;stop stop-color="#FC57A9" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#FCFCFC" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="61.4131653%" y1="33.8941487%" x2="39.4202448%" y2="71.4869303%" id="linearGradient-5"&gt; &lt;stop stop-color="#B639E5" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#3B2EE8" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;linearGradient x1="92.2146132%" y1="-4.63859816%" x2="10.4535745%" y2="110.070945%" id="linearGradient-6"&gt; &lt;stop stop-color="#FC429F" offset="0%"&gt;&lt;/stop&gt; &lt;stop stop-color="#B639E5" offset="100%"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"&gt; &lt;g id="iPhone-8" transform="translate(-17.000000, -29.000000)"&gt; &lt;g id="下一首" transform="translate(17.000000, 29.000000)"&gt; &lt;g id="图-资源-12"&gt; &lt;ellipse id="Oval" fill="url(#radialGradient-1)" cx="60" cy="60.3278689" rx="56.0655738" ry="56.3934426"&gt;&lt;/ellipse&gt; &lt;path d="M59.9548308,5.61469731 C86.7262364,5.59034291 109.53495,25.1646104 113.727249,51.7617846 C117.919548,78.3589588 102.24883,104.07023 76.7829298,112.377093 C51.3170297,120.683956 23.6283668,109.116322 11.5058441,85.1059517 C-0.616678668,61.0955812 6.4316347,31.7820844 28.1225135,15.9982575 C37.381525,9.2515634 48.5217809,5.61766153 59.9548308,5.61469731 Z M59.9548308,3.93450958 C33.9678996,3.96156583 11.4045662,21.9459534 5.43790156,47.387911 C-0.528763057,72.8298686 11.6648878,99.0619808 34.8998782,110.769246 C42.7110885,114.676325 51.3147233,116.713418 60.0383473,116.721311 C81.0928073,116.708669 100.365002,104.83052 109.936925,85.9670171 C119.508848,67.1035138 117.766372,44.4356389 105.425394,27.2765176 C94.8863331,12.5904686 77.9653263,3.9033857 59.9590067,3.93450958 L59.9548308,3.93450958 Z" id="Shape" fill="url(#linearGradient-2)" fill-rule="nonzero"&gt;&lt;/path&gt; &lt;path d="M3.10837279,78.6885246 C-5.35495222,53.4533715 3.8779541,25.6687872 25.7703616,10.4918033 L28.852459,14.9558468 C8.92145404,28.7385915 0.519285038,54.0210331 8.24380779,76.9680513 L3.10837279,78.6885246 Z" id="Path" fill="url(#linearGradient-3)"&gt;&lt;/path&gt; &lt;path d="M114.245163,65.6499501 C116.372688,46.0329572 107.677121,26.8058523 91.5234854,15.4091655 C75.3698494,4.01247878 54.2926478,2.23434907 36.4483634,10.7628794 L34.0983607,5.8762456 C53.7206607,-3.5030912 76.898549,-1.5488063 94.6627212,10.9828374 C112.426893,23.5144812 121.990192,44.6572978 119.651842,66.2295082 L114.245163,65.6499501 Z" id="Path" fill="url(#linearGradient-4)"&gt;&lt;/path&gt; &lt;path d="M54.6247073,120 C35.5244375,118.320115 18.3772721,107.417802 8.52459016,90.6891545 L13.1637002,87.8688525 C22.1211082,103.081395 37.7137233,112.995026 55.0819672,114.520073 L54.6247073,120 Z" id="Path" fill="url(#linearGradient-5)"&gt;&lt;/path&gt; &lt;path d="M64.6784245,119.344262 L64.2622951,113.931055 C86.6626643,112.2425 105.714136,96.9321406 112.196238,75.4098361 L117.377049,76.9630103 C110.258865,100.635232 89.3126319,117.480598 64.6784245,119.344262 Z" id="Path" fill="url(#linearGradient-6)"&gt;&lt;/path&gt; &lt;/g&gt; &lt;path d="M70.6690827,59.1382273 C72.6185025,60.5228233 72.6185025,62.7465682 70.6690827,64.1311641 L44.1685536,81.98406 C42.2191338,83.3686559 40.6557377,82.4246132 40.6557377,79.9071661 L40.6557377,43.3622254 C40.6557377,40.8447782 42.238435,39.9217143 44.1685536,41.2853315 L70.6690827,59.1382273 Z" id="Path" fill="#FFFFFF"&gt;&lt;/path&gt; &lt;rect id="Rectangle" fill="#FFFFFF" fill-rule="nonzero" x="77.3770492" y="40.6557377" width="6.55737705" height="41.9672131" rx="3.27868852"&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; &lt;/symbol&gt;&lt;/svg&gt; &lt;!-- 引用svg --&gt;&lt;p&gt; &lt;svg&gt; &lt;use xlink:href="#icon-pre"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg&gt; &lt;use xlink:href="#icon-next"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 将所有的svg代码copy在一起放在html里面，里面每个svg图片代码用symbol包裹，最外面用svg包裹，好处是图片一起加载。之前每个svg图片代码的svg头部都是一样的，如下。 123&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;svg style="position: absolute;width: 0;height: 0;overflow: hidden;" width="120px" height="120px" viewBox="0 0 120 120" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt; &lt;!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch --&gt; 特别注意，svg的symbol引用时，symbol 标签一定要有 viewBox属性，symbol上不要写宽高。svg标签上写上宽高，viewBox可写可不写。不然在CSS没法设置svg设置宽高。做到了两个细节，SVG整体才能任意自动缩放。 123&lt;symbol id="icon-pre" viewBox="0 0 120 120"&gt; &lt;!-- 省略代码 --&gt;&lt;/symbol&gt; 123456&lt;svg style="position: absolute;width: 0;height: 0;overflow: hidden;" width="120px" height="120px" viewBox="0 0 120 120" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt; &lt;!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch --&gt; &lt;symbol id="icon-pre" viewBox="0 0 120 120"&gt; &lt;!-- 省略代码 --&gt; &lt;/symbol&gt; &lt;/svg&gt; 在html里面引用svg图片方法如下 123&lt;svg&gt; &lt;use xlink:href="#icon-pre"&gt;&lt;/use&gt;&lt;/svg&gt; 1234svg &#123; width: 20px; height: 20px;&#125; 这种方法使用svg缺点是html代码混乱冗长。请看法2 方式二]]></content>
  </entry>
  <entry>
    <title><![CDATA[link & visited & hover & active]]></title>
    <url>%2F2019%2F05%2F02%2Flink%20%26%20visited%20%26%20hover%20%26%20active%2F</url>
    <content type="text"><![CDATA[:active CSS伪类匹配被用户激活的元素。它让页面能在浏览器监测到激活时给出反馈。当用鼠标交互时，它代表的是用户按下按键和松开按键之间的时间。 :active 伪类通常用来匹配tab键交互。通常用于但并不限于 &lt;a&gt; 和 &lt;button&gt; HTML元素。 这个样式可能会被后声明的其他链接相关的伪类覆盖，这些伪类包括 :link，:hover和 :visited。 为了正常加上样式，需要把 :active的样式放在所有链接相关的样式后，这种链接伪类先后顺序被称为LVHA顺序: :link — :visited — :hover — :active。 注意: 在有多键鼠标的系统中，CSS 3 规定 :active 伪类必须只匹配主按键；对于右手操作鼠标来说就是左键。 像我这种普通用户，左键按下和右键按下都是激活元素，或者说给元素加上:active 12345body &#123; background-color: #ffffc9 &#125;a:link &#123; color: blue &#125; /* 未访问链接 */a:visited &#123; color: red &#125; /* 已访问链接 */a:hover &#123; font-weight: bold &#125; /* 用户鼠标悬停 */a:active &#123; color: lime &#125; /* 激活链接 */ 12345&lt;body&gt; &lt;h1&gt;:active CSS选择器示例&lt;/h1&gt; &lt;p&gt;这个链接在鼠标按下和松开的这段时间内会变成绿色,访问过后(点击)变红色，悬停加粗，未访问是蓝色: &lt;a href="#"&gt;Mozilla Developer Network&lt;/a&gt;. &lt;/p&gt;&lt;/body&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2019%2F05%2F02%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[清除浮动方法（代码亲测）为什么要清除浮动？ 1 先看有浮动会是什么样子： 当一个内层元素是浮动的时候，如果没有关闭浮动时，其父元素也就不会再包含这个浮动的内层元素，因为此时浮动元素已经脱离了文档流。也就是为什么外层不能被撑开了！ 没有给最外层的DIV.outer 设置高度，但是我们知道如果它里面的元素不浮动的话，那么这个外层的高是会自动被撑开的。但是当内层元素浮动后，就出现了以下影响： （1）：背景不能显示 （2）：边框不能撑开 （3）：margin 设置值不能正确显示 参考：来自 2 浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。 高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷） 知道浮动和为什么要清除浮动之后我们可以开始学习如何清除浮动了，这时候我们就需要用到清除浮动的属性clear, 12/* 元素的某个方向上不能有浮动元素 */clear:left | right | both | none | inherit； 1clear:both; /* 元素的左右两侧均不允许浮动元素 */ 注意：用于清除浮动的元素一定要放在父元素的最后一个子元素，也就是所有浮动元素的右边，否则父元素还是没有包裹住浮动元素 1 万能清除浮动方法（添加after伪元素） 12345678910111213141516&lt;style&gt; .container &#123; border: 1px solid red;&#125;.item &#123; float: right;&#125;.clearfix::after &#123; content: ''; display: block; clear: both;&#125;.clearfix&#123; zoom: 1; /* IE 兼容 */&#125;&lt;/style&gt; 12345678&lt;div class="container clearfix"&gt; &lt;div class="item"&gt; 我是浮动元素1 &lt;/div&gt; &lt;div class="item"&gt; 我是浮动元素2 &lt;/div&gt;&lt;/div&gt; 2 还是clear清除浮动，将用于清除浮动的元素放在最后一个子元素位置上，设置clear:both 1234567891011121314151617&lt;style&gt; .container &#123; border: 1px solid red; background: chocolate; padding: 10px; margin: 20px; &#125; .itemLeft &#123; float: left; &#125; .itemRight &#123; float: right; &#125; .clearfix &#123; clear: both/left; &#125;&lt;/style&gt; 123456789101112131415&lt;div class="container"&gt; &lt;div class="itemLeft"&gt; 左浮元素1 &lt;/div&gt; &lt;div class="itemLeft"&gt; 左浮元素2 &lt;/div&gt; &lt;div class="itemRight"&gt; 右浮元素1 &lt;/div&gt; &lt;div class="itemRight"&gt; 右浮元素2 &lt;/div&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; // 放在最后&lt;/div&gt; 3 在父元素上设置overflow: hidden/auto;也能清除浮动，这是创建了BFC，父元素包裹住了浮动元素。但hidden对搜索引擎优化seo不友好。 123456789101112131415&lt;style&gt; .container &#123; border: 1px solid red; background: chocolate; padding: 10px; margin: 20px; overflow: auto/hidden; &#125; .itemLeft &#123; float: left; &#125; .itemRight &#123; float: right; &#125;&lt;/style&gt; 1234567891011121314&lt;div class="container"&gt; &lt;div class="itemLeft"&gt; 左浮元素1 &lt;/div&gt; &lt;div class="itemLeft"&gt; 左浮元素2 &lt;/div&gt; &lt;div class="itemRight"&gt; 右浮元素1 &lt;/div&gt; &lt;div class="itemRight"&gt; 右浮元素2 &lt;/div&gt;&lt;/div&gt; 其他有副作用，就不一一列举了 部分参考来自]]></content>
  </entry>
  <entry>
    <title><![CDATA[项目：键盘导航]]></title>
    <url>%2F2019%2F03%2F19%2F%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%94%AE%E7%9B%98%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[存储在 localStorage 的数据可以长期保留,localStorage 中的键值对总是以字符串的形式存储. 123//hash变更后要立刻存档到randomNlocalStorage.setItem('randomN',JSON.stringify(hash)) //JSON.stringify(hash)是把hash变成json字符串的 JSON.parse(localStorage.getItem('randomN') || 'null') //JSON.parse()方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象 1234567var hashT = &#123;'keys': keys,'hash': hash&#125;/*hashT是一个对象*/var hash = hashT['hash'] //hashT.hashvar keys = hashT['keys'] //hashT.keys 1var x = prompt(&apos;请输入要变更的网址域名,不用输入协议。如：iqiyi.com或www.taobao.com&apos;) 123location.href = &apos;http://&apos;+website //模拟用户在地址栏输入地址，修改当前网址为按键地址 window.open(&apos;http://&apos;+website,&apos;_blank&apos;) //新开窗口打开用户按键的网站 1/* 易错 [id类用#号][class类用 .] */ 12/*display: inline-block; //当时为了设置kbd的宽高 vertical-align: top; /*与display:inline-block配套使用*/ 1/*变成弹性盒，垂直居中，左右居中，布局三句话*/ 1kbd:hover &gt; .text&#123;transform: scale(1.6);&#125; /*hover的时候字体变大，但是不会把盒子撑大，也就是页面并不会动*/ 1/*background有六个值，最后一个是默认值*/ 1/*父包裹器[div,id=main] 为不定宽块状元素,要实现内容居中，法一定宽，法二变为内联，父元素加text-align:center;*/ 12/*.wrapper&gt;div&#123; //改用flex布局 line-height:50px; /*父元素 .wrapper&gt;div高度固定，子元素为单行内联文本，垂直居中设置：height=line-height*/ 1height: 100vh; /*viewport height 可视高度和屏幕一样高*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[项目实战：小程序开发]]></title>
    <url>%2F2019%2F02%2F24%2F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[app.json 是当前小程序的全局配置 app是全局的 page是局部的 你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。 &lt;navigator&gt;相当于html里面的a链接。但是只能链接到小程序内部的页面，不能链接到外部的页面。保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。 小程序的组件 是具有一定功能的HTML元素。 建议：图片资源不要直接放到小程序文件下，这样会导致小程序包太大，打开就会很慢。能用图片外链就用图片外链。像用&lt;img&gt;组件也不是很方便。 尝试使用字体图标iconfont。 bug: 小程序的wxml不能写入汉字。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cookie与登录注册]]></title>
    <url>%2F2019%2F02%2F24%2FCookie%E4%B8%8E%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[请预习 Cookie、Session、Cache-Control 等 HTTP 知识 https://zh.wikipedia.org/wiki/Cookie https://zhuanlan.zhihu.com/p/22396872?refer=study-fe Session 维基百科：https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6) Cache-Control 课上的代码：https://github.com/FrankFang/sign-in-demo 要点： Cookie 的特点 服务器通过 Set-Cookie 响应头设置 Cookie 浏览器得到 Cookie 之后，每次请求都要带上 Cookie 服务器读取 Cookie 就知道登录用户的信息（email） 问题 我在 Chrome 登录了得到 Cookie，用 Safari 访问，Safari 会带上 Cookie 吗no Cookie 存在哪Windows 存在 C 盘的一个文件里 Cookie会被用户篡改吗？可以，下节课会讲 Session 来解决这个问题，防止用户篡改 Cookie 有效期吗？默认有效期20分钟左右，不同浏览器策略不同后端可以强制设置有效期，具体语法看 MDN Cookie 遵守同源策略吗？也有，不过跟 AJAX 的同源策略稍微有些不同。当请求 qq.com 下的资源时，浏览器会默认带上 qq.com 对应的 Cookie，不会带上 baidu.com 对应的 Cookie当请求 v.qq.com 下的资源时，浏览器不仅会带上 v.qq.com 的Cookie，还会带上 qq.com 的 Cookie另外 Cookie 还可以根据路径做限制，请自行了解，这个功能用得比较少。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F19%2F%E4%BC%9A%E5%8A%A8%E7%9A%84%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[页面会动的原理首先分析一下我们的需求，页面内容（html）和CSS样式效果（CSS）同步自动显示。关键词有html页面内容，CSS样式，自动显示，同步显示。自动显示意味着不是人为操作 写页面和样式，那只能是JS写页面和样式，那如何显示内容和样式呢？JS写完内容一定得加入到页面中（&lt;body&gt;标签中，加入到&lt;pre&gt;标签中更好，保留代码格式呈现）才能显示页面内容，JS写完样式得加入到&lt;style&gt;标签中才能显示CSS样式，这都是JS操作页面的体现。同步显示就是JS将写好的样式和内容同时分别加入&lt;style&gt; 和&lt;pre&gt;标签中。 综上，页面会动的原理就是JS同时往&lt;style&gt; 和&lt;pre&gt;中写内容，只是两者的解析方式不一样。为了效果逼真，使用setInterval( () =&gt; {},间隔时间)一点点往页面中添加内容。预览 实战-页面会动的简历文本加注释加到`标签的内容不能出现文本，故将文本都加上注释。 代码高亮功能原理：给页面的选择器加span标签 自己写肯定不划算，引用别人的代码高亮库，Copy-Run-Modify 引入Prism.css Prism.js库，并查看官方文档如何使用 代码高亮效果 异步异步就是先写的代码后执行。也是 不等结果直接进行下一步。例如： 更好理解的是明天六点起床这个例子，假如我们现在是晚上11点，你定好了明早六点起床的闹钟，然后你从今晚11点到明早6点之间的时间都可以玩游戏，显然玩游戏操作并不是等你起床这个操作以后再执行的。不等起床发生就能玩游戏，这就是异步事件。 同理可知，同步就是先等结果才能执行下一步。 回调回调是拿到异步结果的一种方式 回调也可以拿同步结果。 回调就是回电话通知。 使用回调函数可以使异步事件 同步执行，即回调函数可以让异步事件按我们想到的顺序发生。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS常用DOM API]]></title>
    <url>%2F2019%2F02%2F19%2FJS%E5%B8%B8%E7%94%A8DOM-API%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031321str.substring(indexStart[, indexEnd]) //字符串切片，含头不含尾str.slice(beginSlice[, endSlice]) //slice() 返回一个从原字符串中提取出来的新字符串包括beginSlice但不包括 endSlice。2var id = setInterval( function()&#123;&#125; , 间隔时间) //缺点，间隔时间只会读一次clearInterval(id)//改进，使用setTimeout,所有的setInterval都可以改成setTimeoutsetTimeout(function fn()&#123; setTimeout(fn,间隔时间) &#125;,间隔时间)//两个的不同是setTimeout执行一次就结束了，连续执行需要递归调用fn即可，所以使用setTimeout，间隔时间是需要重复调用的。而setInterval是自动重复调用，间隔时间只读取一次，需要你帮它停下来。3document.querySelector('#idName')body.querySelector('#className')document.querySelector('divOrOtherSelector')document.querySelectorAll('#idName') //得到NodeListdocument.querySelectorAll('#className')document.querySelectorAll('divOrOtherSelector')4const content = idName.innerHTML //获取HTML语法表示的元素的后代idName.innerHTML = htmlString //设置HTML语法表示的元素的后代5document.createElement('div')6document.body.appendChild(paper)7]]></content>
  </entry>
  <entry>
    <title><![CDATA[虚拟DOM深入讲解]]></title>
    <url>%2F2019%2F02%2F16%2F%E8%99%9A%E6%8B%9FDOM%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[虚拟 DOM是什么虚拟 DOM有什么用虚拟 DOM如何实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * @author ruoyu * @description 虚拟 DOM Demo * @todo 暂时不考虑复杂情况 */class VNode &#123; constructor(tag, children, text) &#123; this.tag = tag this.text = text this.children = children &#125; render() &#123; if(this.tag === &apos;#text&apos;) &#123; return document.createTextNode(this.text) &#125; let el = document.createElement(this.tag) this.children.forEach(vChild =&gt; &#123; el.appendChild(vChild.render()) &#125;) return el &#125;&#125;function v(tag, children, text) &#123; if(typeof children === &apos;string&apos;) &#123; text = children children = [] &#125; return new VNode(tag, children, text)&#125;/*let nodesData = &#123; tag: &apos;div&apos;, children: [ &#123; tag: &apos;p&apos;, children: [ &#123; tag: &apos;span&apos;, children: [ &#123; tag: &apos;#text&apos;, text: &apos;xiedaimala.com&apos; &#125; ] &#125; ] &#125;, &#123; tag: &apos;span&apos;, children: [ &#123; tag: &apos;#text&apos;, text: &apos;jirengu.com&apos; &#125; ] &#125; ]&#125; *//*创建vNodes实例*/let vNodes = v(&apos;div&apos;, [ v(&apos;p&apos;, [ v(&apos;span&apos;, [ v(&apos;#text&apos;, &apos;xiedaimala.com&apos;) ] ) ] ), v(&apos;span&apos;, [ v(&apos;#text&apos;, &apos;jirengu.com&apos;) ]) ] )console.log(vNodes)console.log(vNodes.render())//虚拟DOM实现数据更新//增加、删除、修改一个元素function patchElement(parent, newVNode, oldVNode, index = 0) &#123; if(!oldVNode) &#123; parent.appendChild(newVNode.render()) &#125; else if(!newVNode) &#123; parent.removeChild(parent.childNodes[index]) &#125; else if(newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) &#123; parent.replaceChild(newVNode.render(), parent.childNodes[index]) &#125; else &#123; for(let i = 0; i &lt; newVNode.children.length || i &lt; oldVNode.children.length; i++) &#123; patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i) &#125; &#125;&#125;let vNodes1 = v(&apos;div&apos;, [ v(&apos;p&apos;, [ v(&apos;span&apos;, [ v(&apos;#text&apos;, &apos;xiedaimala.com&apos;) ] ) ] ), v(&apos;span&apos;, [ v(&apos;#text&apos;, &apos;jirengu.com&apos;) ]) ] )let vNodes2 = v(&apos;div&apos;, [ v(&apos;p&apos;, [ v(&apos;span&apos;, [ v(&apos;#text&apos;, &apos;xiedaimala.com&apos;) ] ) ] ), v(&apos;span&apos;, [ v(&apos;#text&apos;, &apos;jirengu.coms&apos;), v(&apos;#text&apos;, &apos;ruoyu&apos;) ]) ] )const root = document.querySelector(&apos;#root&apos;)patchElement(root, vNodes1) 分析虚拟DOM实现（1）### 分析虚拟DOM实现（2）]]></content>
  </entry>
  <entry>
    <title><![CDATA[40面向对象编程]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象预习： 程序员也不知道什么是面向对象 MDN 给了我们一堆术语 请尝试理解面向对象，并背诵 MDN 里的以下内容 Class 类，定义对象的特征。它是对象的属性和方法的模板定义.Object 对象，类的一个实例。Property 属性，对象的特征，比如颜色。Method 方法，对象的能力，比如行走。Constructor 构造函数，对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致.例如：Object() String() Number( )Inheritance 继承，一个类可以继承另一个类的特征。Encapsulation 封装，一种把数据和相关的方法绑定在一起使用的方法.Abstraction 抽象，结合复杂的继承，方法，属性的对象能够模拟现实的模型。Polymorphism 多态，多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。 namespace 命名空间，包含了很多名字的空间。 封装 Model View Controller完整代码：https://github.com/FrankFang/resume-15-8 controller === object controller.init(view, model) === controller.init.call(controller, view, model)那么 controller.init 里面的 this 当然 TM 是 controller也就是这个1里面的objectcontroller.init 里面的 this 就是 objectobject.init 里面的 this 就是 object initB.call(this)initB 里面的 this === call 后面的thiscall 后面 this === 第二条里的 this第二条里面的 this === object=&gt; initB 里面的 this 就是 object 复习 this对this的理解是细节，牢记this就是call后面的第一个参数，当对象的属性是函数，又称方法，当函数作为对象里的方法被调用时，函数里的 this 是调用该函数的对象，例如 controller是一个对象，controller.init(view) 等价于controller.init.call(controller,view),而函数init()里的this就是controller,view才是调用函数init时传进去的参数。 123456789101112131415161718192021221.button.onclick = function f1()&#123; console.log(this) // this值是，触发事件的元素button&#125;button.onclick.call(&#123;name: &apos;frank&apos;&#125;) //则this就是call后的第一个参数&#123;name: &apos;frank&apos;&#125;2.button.addEventListener(&apos;click&apos;, function()&#123; console.log(this) // this值是，该元素的引用button&#125;3.$(&apos;ul&apos;).on(&apos;click&apos;, &apos;li&apos; /*selector*/, function()&#123; console.log(this) //this 则代表了与 selector 相匹配的元素，即li 元素&#125;)以上的解决办法：去看 on 的源码呀 -&gt; 做不到jQuery 的开发者知道 onclick 的源码，f1.call(???)jQuery 的开发者写了文档看文档呀 例题： 1 2 3 箭头函数内是没有this的，所以箭头函数内外this值是一样的。 new 的作用https://zhuanlan.zhihu.com/p/23987456 总结：回顾进阶时我们记住的关于原型链 var object = new Object() 自有属性 空(0) object.__proto__ === Object.prototype var array = new Array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 自有属性 0:’a’ 1:’b’ 2:’c’,length:3array.__proto__ === Array.prototypeArray.prototype.**proto** === Object.prototype var fn = new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x+y&#39;)自有属性 length:2, 不可见的函数体: ‘return x+y’fn.**proto** === Function.prototype Array is a function Array = function(){...} Array.proto === Function.prototype || 和&amp;&amp;或 和 且 的值一般都不是false/true, 而是falsy/truthy。回忆一下五个falsy值，0 NaN &#39;&#39; null undefined 例如：a||b c&amp;&amp;d 的值一般都是从a b c d中选取一个值，它的值永远都是现取的，而不是重新生成一个值。 a&amp;&amp;b 与运算从左到右依次找第一个falsy值，若找到第一个falsy值，则返回第一个falsy值，后面不再执行;若没有falsy值(全为truthy值)，则返回最后一个表达式的truthy值。 例如： c||d或运算符从左到右依次找到第一个truthy值，若找到第一个truthy值，则返回第一个truthy值，后面不再执行；若没有truthy值(全为falsy值)，则返回最后一个表达式的falsy值。 例如： var app = {} 与 var app = app || {} var app = {} 是危险代码,可能会覆盖之前声明的app变量 var app = app || {} 是安全代码，它就是 if(app){ app = app；} else{ app={}； }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Anaconda安装和tensorflow安装]]></title>
    <url>%2F2019%2F01%2F27%2FAnaconda%E5%AE%89%E8%A3%85%E5%92%8Ctensorflow%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[补充：这是我第二次在Anaconda下安装tensorflow，第一次安装tansorflow安装了一天，从早到晚吧，参考了好几篇教程，最后还是直接在Anaconda Navigator的tensorflow环境下直接安装tensorflow，也没报错。第二次安装只记得今天这篇教程了，因为之前电脑系统崩了，又得重头来一遍，用的这篇教程，但是里面有些指令不管用了，自己摸索了一下，大概花了两三个小时就安装上了Anaconda和tensorflow，花时间把修改后的内容写了一篇博客，留给自己复习用。这次是为了春运抢票需要用python，干脆就给装了。不敢居功，原文链接奉上。 一、什么是Anaconda？​ 简单来说，Anaconda是一个包管理器和环境管理器。当安装好Anaconda并开始运行时，就会发现我们电脑里面安装好的环境和依赖包都可以在Anaconda里面找到，管理（安装、更新、卸载等）起来简直不能再方便。而且Anaconda附带一大批常用的数据科学包，这样在使用Python等处理数据的时候就不用安装完这个包再装那个包了。还有一个Anaconda非常强的方面就是环境管理，一台电脑多种环境可以造成很多混乱和错误，但是用Anaconda可以创建并管理多个不同的环境，需要哪个用哪个，Mom再也不用担心我的项目在不同环境下疯狂报错的问题啦。 二、安装Anaconda1下载Anaconda我是在Windows 10环境下安装Anaconda，我从官网下载Anaconda安装包，我是连着家里的网，下载速度感觉和使用镜像下载差不多。或者选择清华大学镜像网站，最下面找到最新版的，选择要安装的操作系统，下载就OK。 2安装Anaconda下载好之后就跟安装一般的软件没啥区别，选择自己安装的文件夹路径，下一步就ok，需要注意下图中的两项都需要勾选。 补充：勾选了，等安装结束以后还是检查一下电脑的环境变量-系统变量里面有没有Anaconda的安装路径，如果没有的话，你就要手动添加了，反正我的是勾选了还是没有路径，自己手动添加的。 接下来就是一小段时间的等待，可以去喝杯茶。时间真的挺长的。 3测试Anaconda是否完成它安装完成后，在开始菜单找到并打开Anaconda控制台:Anaconda Prompt ，也叫终端。 执行命令： 1conda list 可以看到自己电脑上安装的一些包，至此Anaconda安装完成。 4更新Anaconda如果发现自己安装的Anaconda不是最新版本的,更新命令：conda update --prefix 安装路径 anaconda 三、在Anaconda下安装Tensorflow 因为要下载Tensorflow，所以我先在Anaconda的配置文件中添加清华镜像库，这样下载和更新的速度会快很多，命令： 12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes Tensorflow目前只支持Python3.5/3.6环境，而且在Python3.5环境下的表现更好一些。所以利用Anaconda创建Python3.5的环境，用来安装Tensorflow，执行命令： conda create -n tensorflow python=3.5 然后打开Anaconda Navigator，点击环境（Environment），可以看到我已经创建了一个名为tensorflow的环境。 在Anaconda Prompt启动刚刚配置好的Tensorflow环境，命令： conda activate Tensorflow 如果不使用Tensorflow了，需要将环境关掉，命令：conda deactivate 接下来就在这个环境中安装Tensorflow（之前的工作是给安装Tensorflow准备环境），执行命令： pip install tensorflow 安装tensorfdlow的时间也是很长很长，耐心等吧。 使用这个命令我成功安装了tensorflow，然后终端提醒我更新pip版本，告诉我使用命令： python -m pip install --upgrade pip 5.等安装过程完成后，我们来测试一下：打开Python编辑器，输入import tensorflow，没有报错信息，则安装完成 这应该算是时间比较新的一个教程了，全为亲身实践，可用，在安装的过程中就遇见了一个错误。 pip3指令不可用，估计是pip没有更新导致的，我换成pip install tansorflow就安装成功了，之后终端也提示\我更新pip了，上文有提到。好了，我要抢车票去了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[把MVC的VC加到简历里]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%8A%8AMVC%E7%9A%84VC%E5%8A%A0%E5%88%B0%E7%AE%80%E5%8E%86%E9%87%8C%2F</url>
    <content type="text"><![CDATA[把MVC的VC加到简历里完整代码：https://github.com/FrankFang/resume-15-6 在简历里使用 Swiper 进入 Swiper 官网 ,仔细读已经写得很详细了。 安装 Swiper 命令行：npm install swiper 在页面引入 Swiper（引入Swiper的CSS和JS) 抄袭 HTML（CRM 中的 Copy） 抄袭 CSS 抄袭 JS 运行（CRM 中的 Run） 修改 HTML（CRM 中的 Modify） 修改 CSS 修改 JS 在简历里使用Swiper我们学到了一种思想，CRM思想，即Copy-Run-Modify Copy别人的代码，Run别人的代码，Modify别人的代码。这就是CRM思想，使用别人的东西，如：Swiper/jQuery MVC 是什么 Model-View-Controller 如何弄出一个 View 如何弄出一个 Controller 如何弄出一个 Model 如何使用Swiper点击Swiper 官网 。Copy-Run-Modify 立即执行函数的产生过程 我们不想要全局变量 我们要使用局部变量 ES 5 里面，只有函数有局部变量 于是我们声明一个 function xxx，然后 xxx.call() 这个时候 xxx 是全局变量（全局函数） 所以我们不能给这个函数名字 function(){}.call() 但是 Chrome 报错，语法错误 试出来一种方法可以不报错: !function(){}.call() (我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系) (function(){}).call() 方方不推荐 12xxx (function()&#123;&#125;).call() 报错 frank192837192463981273912873098127912378.call() 不推荐 使用立即执行函数!function(){ 把你模块化代码放在这里}.call() 立即执行函数的作用立即执行函数的作用就是隔离作用域的。 两个独立模块的变量想交流怎么办？方法1：把变量放到window下 方法2：使用闭包 立即执行函数使得 person 无法被外部访问 闭包使得匿名函数可以操作 person，然后将这个匿名函数赋值给全局属性window.linyanGrowUp 全局属性window.linyanGrowUp 保存了匿名函数的地址 任何地方都可以使用 window.linyanGrowUp =&gt; 任何地方都可以使用 window.linyanGrowUp 操作 person，但是不能直接访问 person 总结：立即执行函数肯定是和闭包结合起来用的。 MVC 及注意事项MVC就是Model-View-Controller。MVC 是一个抽象的知识，你很有可能短时间无法理解。但是没有关系，多写类似的代码形成肌肉记忆就可以了。MVC的前提是你的代码经过模块化。 View 用户看得见的视图 只要你操作了页面，一个模块的js就对应一个View。添加了View以后，HTML代码也分块了，实际上用户看到的是HTML + CSS,因为CSS的样式是加在HTML内容上的。View的作用就是告诉js你这个模块对应着页面中哪些内容。 controller操纵view。从整个代码结构上来看，html构成view,js代码构成controller，controller操纵view。整个代码就变得很有结构。 例如： 这里的controller控制功能还是简单的，再看下图： Model 就是一个操作数据的对象 MVC思想Model 操作数据View 表示视图Controller 是控制器 Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View；用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View MVC就是一种代码的组织形式，model和view传给controller，controller负责对model初始化，然后对view进行操作。view只负责看得见的东西（HTML元素），model负责请求和保存数据。controller负责操作，controller代码会相对复杂一些。 有了MVC思想以后，代码就不至于写成一坨。以前还用注释来分隔代码，现在不需要用注释分隔代码，直接用MVC思想来组织代码。 当引入了MVC的思想以后，你就发现所有的代码结构都一样。]]></content>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习工具安装与使用合集]]></title>
    <url>%2F2019%2F01%2F11%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[前端学习工具安装与使用合集前言：此时的我刚刚开始前端学习之路，很多东西学了不久就忘了，写下这篇博客方便自己以后复习回顾。有些内容还只有标题，文章会一直更新的。如果帮到了你，我也很开心哦~ 科学上网编辑器 Webstorm VScode sublime Webstorm不怎么需要配置，跟VScode操作有点像，更改进一点就是会自动帮你把文件的模板给建好。还没使用过。 VScode安装 ：官网下载安装包 。 使用感受：我喜欢用VScode写html css js。可以将VScode上的代码上传到GitHub管理,VScode这个软件有Git的功能。但是我只是用VScode写代码，用Git Bash上传代码到GitHub。[ 使用：VScode教程。 sublime还没使用过。 markdown编辑器 Typora 安装 ：Typora从官网下载，安装简单，一直next即可。 使用 ：打开Typora，新建xxx.md文件，使用markdown语法写xxx.md文件，每写完一句按下Tab键 或者 敲一个空格 就能即时渲染。在windows下使用Typora写md文件时插入图像，必须先把本地图像上传到图床图床推荐 ，生成图片链接后，再使用markdown语法将图片插入到文章中，即：![](图床生成的图片链接粘到这里)。 md语法 ：md基础语法 markdown语法 图床推荐sm.ms Git Bash 命令行Git Bash安装包：百度网盘 提取码：6p64 在windows下安装Git Bash教程: 链接 我的使用感受：Git Bash是一个功能强大的软件，我们在windows上的操作在Git Bash上都能做，Git Bash是模拟Linux操作系统，Git Bash是一个Bash,不是Git。Git Bash里面内置了几十个指令，如：ls mkdir rm touch ,而Git指令只是它其中的一个。Git Bash可以在本地建一个.git仓库，通过git指令既可以操作这个本地的仓库，也可以将这个仓库上传到Git Hub，同样，可以在Git Hub上建一个不空的仓库然后通过git clone克隆到本地。相当于通过git指令 可以把本地电脑里的仓库和Git Hub远程仓库进行一个关联。 命令行使用方法总结 ：命令行基础 Git指令的安装与配置安装：不需要安装Git，Git Bash 内置了 Git 命令。 配置：请在命令行运行这五句话！！！一定要运行这五句话，不然 git 就不能用了。 12345git config --global user.name xxxxxx //把xxxxxx替换成你的英文名字随便什么都行) git config --global user.email xxxxxx //把xxxxxx替换成你的邮箱跟github一致或者不一致也行) git config --global push.default simple //本来我写的是 matching，不过想了想可能 simple 更好git config --global core.quotepath false //防止文件名变成数字git config --global core.editor &quot;vim&quot; //使用vim编辑提交信息 另外很重要的一点！自己运行 git的时候注意一下：git remote add origin 后面的地址，不允许使用 https 开头的地址，见下图: Node.js官网下载：Node.js 安装：一直next，可以改路径。安装后，不要点击 Node.js 的图标这样使用。 配置打开 Git Bash，依次输入以下命令，按回车： 123npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress false npm 的配置被存储在 ~/.npmrc，我们可以随时改。 使用装了 Node.js 之后我们就可以在 Git Bash 里面使用 node 和 npm 这两个命令了。进入node环境后，按ctrl+D是 退出。 试着在Git Bash输入以下命令： 1234which nodewhich npmnode -vnpm -v 依次看看可以输出什么内容，不报错说明安装成功了。 npm 安装命令行小工具我们可以用 npm 的翻译工具做一个随时可用的小字典，这个小工具的名字叫做 fanyi。 打开Git Bash运行 npm i -g fanyi 即可安装 fanyi，安装完成之后，接着在Git Bash输入 fanyi frontend 就可以看到对应的中文释义了！超级酷对不对！ node使用使用方式1： 进入Git Bash 输入node,回车，就进入node环境下，这时我们就可以写JS了。 如简单的JS语句，1+2,回车 结果得3 使用方式2： ​ 打开Git Bash，进入一个有xxx.js文件的文件夹下，运行node xxx.js,node就会执行这个xxx.js文件，你将在Git Bash看到执行结果。 GitHub源代码管理神器我的账号：liaolinyan2018.github.io。 我的感受：我喜欢使用github来管理我的源代码，github可以将我的每一次代码提交都记录下来，这样我可以打开我代码的1.0版本、2.0版本、3.0版本、4.0版本，而不用每次更改代码都要编辑好名字然后存在电脑硬盘里，不仅费电脑内存而且危险，一旦电脑出事，东西就没了。github这个功能简直太棒了，虽然使用时间不长，但是我几乎每天都在使用它提交代码。 使用方法：值得写一篇博客。GitHub源代码管理博客 QQ截图测量颜色和尺寸代码分享当我们的代码遇到问题时，需要求助别人，直接把代码分享过去是比较方便的。使用jirengu-bin 是比较方便的，或者使用jsbin 分享源代码，这两个bin都可以存储多个版本的代码，非常方便，适用于小项目demo，一边调试一边写代码。不适用于大项目。 Linux虚拟机安装教程此处应有一篇博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[实现AJAX]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%AE%9E%E7%8E%B0AJAX%2F</url>
    <content type="text"><![CDATA[AJAX 的所有功能 客户端的JS发起请求（浏览器上的） 服务端的JS发送响应（Node.js上的） JS 可以设置任意请求header吗？ 第一部分 request.open(&#39;get&#39;, &#39;/xxx&#39;),设置请求的方式，路径。 第二部分 request.setRequestHeader(&#39;content-type&#39;,&#39;x-www-form-urlencoded&#39;)设置请求头,request.setRequestHeader必须写在open和send之间 第三部分 是回车，不设置也不显示 第四部分request.send(&#39;我非要设置请求体&#39;) JS 可以获取任意响应 header 吗？ 第一部分 request.status(200)/request.statusText(OK) 第二部分响应头request.getResponseHeader()/request.getResponseHeader(&#39;Content-Type&#39;) request.getAllResponseHeaders() 第四部分响应体request.responseText 今天写 window.jQuery.ajax封装AJAX是为了将AJAX的功能封装在一个函数里，以后要使用AJAX就调用这个函数就可以了。 123window.jQuery.ajax = function(options)&#123; // 代码&#125; 内存图 自己封装jQuery.ajax代码代码分析 callback回调就是满足某个条件的函数call a function call a function back 回调的问题问题是每个程序员的回调名不一样 Promise 解决了回调名不一样这个问题promise本质上是为了规定 统一 一种形式。 请背 12345678910111213function xxx()&#123; return new Promise((f1, f2) =&gt; &#123; // doSomething() setTimeout(()=&gt;&#123; // 成功就调用 f1，失败就调用 f2 &#125;,3000) &#125;)&#125;xxx().then(success, fail)// 链式操作xxx().then(success, fail).then(success, fail) 升级你的 jQuery.ajax 满足 Promise 规则]]></content>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2018%2F12%2F29%2FAJAX%2F</url>
    <content type="text"><![CDATA[前端如何向后端发请求？ 用form可以发请求，但是会刷新页面或新开页面，刷新页面就要重新渲染页面，导致用户体验不好 用a可以发 get 请求，但是也会刷新页面或新开页面 用img可以发 get 请求，但是只能以图片的形式展示- 用link可以发 get 请求，但是只能以 CSS、favicon 的形式展示 用script可以发 get 请求，但是只能以脚本的形式运行 有没有什么方式可以实现发get、post、put、delete请求都行，想以什么形式展示就以什么形式展示？？？ 微软的突破IE5 率先在JS中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。随后 Firefox浏览器、 Safari浏览器、 Opera浏览器 也跟进（抄袭）了，取名 XMLHttpRequest，并被纳入 W3C 规范。实际上，AJAX这个术语就是用JS发HTTP请求这个技术的代名词。从此以后，AJAX奠定了前端的基础。很神奇地说。 AJAX的作用是 应用了AJAX的网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。简单点说，AJAX就是使用 XMLHttpRequest 对象与服务器通信**。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。AJAX最吸引人的就是它的“异步”特性，也就是说他可以在不重新刷新页面的情况下与服务器通信，交换数据，然后更新页面。 AJAX预习阮一峰写得很详细：http://javascript.ruanyifeng.com/bom/ajax.html Jesse James Garrett 给 AJAX取名叫做：异步的 JavaScript 和 XML（Asynchronous JavaScript and XML） 后来，AJAX就成为 JavaScript 脚本发起 HTTP 请求的代名词，只要用脚本发起请求，就可以叫做 AJAX 请求,AJAX这个词已经成为了一个代名词，字面含义已经消失了。其实AJAX现在应该是AJAJ，异步的JavaScript和JSON。 尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。JSON和XML都被用于在Ajax模型中打包信息。 具体一点，AJAX包括以下几个步骤： 客服端使用XMLHttpRequest发HTTP请求 服务器返回 XML 格式的字符串(现在JSON,XML过时) JS 解析XML(现在JSON,XML过时)，从中提取数据，并更新局部页面 如何使用 XMLHttpRequest整个过程是请求（request），响应(response)，浏览器解析(JSON.parse) 下面是一个用原生JS发HTTP请求的例子。 前端程序员写在main.js里的代码 /frank.com网站的浏览器访问jack.com网站的服务器,属于跨域访问/ 12345678910111213141516myButton.addEventListener('click', () =&gt; &#123; let request = new XMLHttpRequest() //1 request.open('GET', '/xxx?note') // 2 request.send() // 3 request.onreadystatechange = ()=&gt;&#123; //4 if(request.readyState === XMLHttpRequest.DONE)&#123; if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123; console.log('说明请求成功') let obj = JSON.parse(request.responseText) &#125;else if(request.status &gt;= 400)&#123; console.log('说明请求失败') &#125; &#125; &#125;&#125;) 仔细分析上面的代码， 1生成一个XMLHttpRequest 实例对象request , 2初始化request, 3 发送request请求 发送数据，2和3发送一个实际的请求，通过调用HTTP请求对象的 open() 和 send() 方法。open() 的第一个参数是HTTP请求方法（大写字母)，第二个参数是你要发送的URL。由于安全原因，默认不能调用第三方URL域名,否则会跨域访问。第三个参数是可选的，用于设置请求是否是异步的，默认为true，是异步的。 false是同步。send() 方法的参数可以是任何你想发送给服务器的内容 4 告诉request对象，我们提供了一个函数负责处理响应。在处理响应的函数中，首先检查请求状态readyState，再检查HTTP响应码， 最后就可以拿到服务器返回的数据responseText了。如果request.readyState === XMLHttpRequest.DONE（对应的值是4），表示客户端收到了(下载完成)服务器响应并且是没问题的，可以继续执行。 request.readyState 属性返回一个 request代理当前所处的状态。一个 request代理总是处于下列状态中的一个： 值 状态 描述 0 XMLHttpRequest.UNSENT 代理被创建，但尚未调用 open() 方法。 1 XMLHttpRequest.OPENED open() 方法已经被调用。 2 XMLHttpRequest.HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。 3 XMLHttpRequest.LOADING 下载中； responseText 属性已经包含部分数据。 4 XMLHttpRequest.DONE 下载操作已完成。客户端收到了响应 注意上面这一步只在你发起异步请求时有效（既 open() 的第三个参数未特别指定或设为 true）。如果你你发起的是同步请求则不必使用函数处理响应，但是非常不推荐这样子做，它的用户体验很糟糕。 下面是后端程序员写在server.js里的代码。 12345678910111213141516171819&#125;else if(path==='/xxx')&#123; response.statusCode = 200 //1 response.setHeader('Content-Type', 'text/json;charset=utf-8') //2 response.setHeader('Access-Control-Allow-Origin', 'http://frank.com:8001') //3 response.write(` &#123; "note":&#123; "to": "小谷", "from": "方方", "heading": "打招呼", "content": "hi" &#125; &#125; `) //4 response.end()&#125; //封装的ajax函数，只适合GET方法 123456789101112131415myButton.addEventListener('click', function () &#123;ajaxRequest('GET', '/xxx?note')&#125;)function ajaxRequest (methodString, urlString) &#123; let request = new XMLHttpRequest() request.open(methodString, urlString) request.send() request.onreadystatechange = ()=&gt;&#123; if(request.readyState === 4)&#123; if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123; let object = JSON.parse(request.responseText) &#125;else if(request.status &gt;= 400)&#123; &#125; &#125; &#125;&#125; 使用XMLHttpRequest 对象与服务器通信分为四步: 生成一个XMLHttpRequest实例对象request 配置request对象 发送request对象 监听request对象的readystate变化 细节分析： window.XMLHttpRequest 既是构造函数 也是一个对象。 var request = new XMLHttpRequest()，request是XMLHttpRequest的一个实例对象，有很多属性。 当request.readyState值为4时，整个请求过程已经完成（响应体已经下好了）。 request.onreadystatechange监听request.readyState 后台只能返回一个字符串给前端，不能返回对象，只不过这个字符串可以可以是XML格式、JSON格式、CSS格式、HTML格式、Text格式，例如上面后端代码就是返回JSON格式的字符串给浏览器，response.setHeader(&#39;Content-Type&#39;, &#39;text/json;charset=utf-8&#39;) 响应的第四部分是字符串。可以用 JSON 语法表示一个对象，也可以用 JSON 语法表示一个数组，还可以用 XML 语法，还可以用 HTML 语法，还可以用 CSS 语法，还可以用 JS 语法，还可以用我自创的语法 JSON —— 一门新语言，但不是一门编程语言http://json.org查看JSON的铁轨图。JSON和JS是两门语言。JSON是抄袭JS，但JSON没有抄袭JS的function,undefined,symbol。JSON的作者还写了《语言精粹》来说JS的不好。 一、 JSON 值的数据类型：null true/false JSONstring JSONnumber JSONobject JSONarrayJSON是一种轻量级的用于数据交互的文本格式。人类很容易读写。机器很容易解析和生成。JSON是一种完全独立于语言的文本格式。所以非常通用。JSON就是为了表示文本数据。 JavaScript数据类型 与 JSON 数据类型 的区别 对象和数组 属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。 数值 禁止出现前导零（ JSON.stringify 方法自动忽略前导零，而在 JSON.parse 方法中将会抛出 SyntaxError）；如果有小数点, 则后面至少跟着一位数字。 字符串 只有有限的一些字符可能会被转义；禁止某些控制字符； Unicode 行分隔符 （U+2028）和段分隔符 （U+2029）被允许 ; 字符串必须用双引号括起来。 1234567891011/*`JS` 与 `JSON`*/ 值的一一对应undefined 没有null nulltrue,false true,false'frank' "frank" ['a','b'] ["a","b"] &#123;name:'frank'&#125; &#123;"name":"frank"&#125;function fn()&#123;&#125; JSON没有函数var a=&#123;&#125;;a.self=a 办不到（JSON没有变量）&#123;__proto__&#125; JSON没有原型链 二、 JSON 对象JSON对象是JavaScript 的原生对象，用来处理 JSON 格式数据，注意不是函数也不是构造函数。JSON对象包含两个方法: JSON.parse() 方法， JSON.stringify() 方法。除了这两个方法, JSON这个对象本身并没有其他作用。 JSON.parse() 用于解析JSON字符串并返回对应的值，可以额外传入一个转换函数，用来将生成的值和其属性, 在返回之前进行某些修改。 1234567891011JSON.parse("null") //nullJSON.parse('null') //nullJSON.parse("true") //trueJSON.parse("123") //123JSON.parse('"foo"') // "foo"JSON.parse("\"abc\"") // "abc" 字符串尤其要注意，双引号里面的是转义字符，这样JS引擎才能识别JSON.parse("[]") //[]JSON.parse("&#123;&#125;") //&#123;&#125;JSON.parse("[\"a\", \"b\", \"c\"]") //["a", "b", "c"]JSON.parse("&#123;\"1\": \"a\", \"2\": \"b\", \"3\": \"c\"&#125;") //&#123;1: "a", 2: "b", 3: "c"&#125;JSON.parse("&#123;\"a\": \"a\", \"b\": \"b\", \"c\": \"c\"&#125;") //&#123;a: "a", b: "b", c: "c"&#125; 注意 1JSON.parse("undefined") //Uncaught SyntaxError: Unexpected token u in JSON at position 0 如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。 1JSON.parse("'String'") //Uncaught SyntaxError: Unexpected token ' in JSON at position 0 上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错。 也就是说，双引号字符串中 的内容必须符合JSON格式。 为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。 12345try &#123; JSON.parse("'String'");&#125; catch(e) &#123; console.log('parsing error');&#125; JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。 123456789function f(key, value) &#123; if (key === 'a') &#123; return value + 10; &#125; return value;&#125;JSON.parse('&#123;"a": 1, "b": 2&#125;', f)// &#123;a: 11, b: 2&#125; 上面代码中，JSON.parse的第二个参数是一个函数，如果键名是a，该函数会将键值加上10。 JSON.stringify() 该方法将对象/值转换为 符合JSON格式的字符串，并且可以被JSON.parse方法还原。可以通过额外的参数, 控制仅包含某些属性, 或者以自定义方法来替换某些key对应的属性值。 1 JSON.stringify()方法的第一个参数 是 被转换的值 123456789JSON.stringify(null) //"null"JSON.stringify(true) //"true"JSON.stringify(123) //"123"JSON.stringify('abc') //"\"abc\"" 尤其要注意，双引号里面的是转义字符，这样JS引擎才能识别JSON.stringify([]) //"[]"JSON.stringify(&#123;&#125;) //"&#123;&#125;"JSON.stringify(['a','b','c']) // "[\"a\", \"b\", \"c\"]"JSON.stringify(&#123;1: 'a', 2: 'b', 3: 'c'&#125;) // "&#123;\"1\": \"a\", \"2\": \"b\", \"3\": \"c\"&#125;" 上面代码表明JSON格式字符串一定是被双引号包裹起来的。所以当JSON格式字符串里面还有字符串时，必须要加转义字符。分单的双的太麻烦了，以后JSON格式需要用引号的地方只用双引号。 注意： 如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。 123456var obj = &#123; a: undefined, b: function () &#123;&#125;&#125;;JSON.stringify(obj) // "&#123;&#125;" 如果数组的成员是undefined、函数或 XML 对象，则这些数组元素被JSON.stringify转成null。 12var arr = [undefined, function () &#123;&#125;];JSON.stringify(arr) // "[null,null]" 正则对象会被JSON.stringify转成空对象。 1JSON.stringify(/foo/) // "&#123;&#125;" 函数和undefined 会返回undefined 12JSON.stringify(function () &#123;&#125;) // undefinedJSON.stringify(undefined) // undefined JSON.stringify方法会忽略对象的不可遍历的属性。 12345678910111213var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'foo': &#123; value: 1, enumerable: true &#125;, 'bar': &#123; value: 2, enumerable: false &#125;&#125;);JSON.stringify(obj); // "&#123;\"foo\":1&#125;" 2 JSON.stringify()方法 还可以接受一个数组，数组的元素值是对象的部分属性名，作为第二个参数。这个数组指定了 对象的哪些属性需要转成字符串。这个数组只对对象的属性有效，对数组无效。 123456789var obj = &#123; 'prop1': 'value1', 'prop2': 'value2', 'prop3': 'value3'&#125;;var selectedProperties = ['prop1', 'prop2'];JSON.stringify(obj, selectedProperties) // "&#123;\"prop1\": \"value1\", \"prop2\": \"value2\"&#125;" 12345JSON.stringify(['a', 'b'], ['0'])// "[\"a\",\"b\"]"JSON.stringify(&#123;0: 'a', 1: 'b'&#125;, ['0'])// "&#123;\"0": \"a\"&#125;" 上面代码中，第二个参数指定 JSON 格式只转0号属性，实际上对数组是无效的，只对对象有效。 第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。这个函数会对 对象的每对键值对 操作。 123456789function f(key, value) &#123; if (typeof value === "number") &#123; value = 2 * value; &#125; return value;&#125;JSON.stringify(&#123; a: 1, b: 2 &#125;, f)// '&#123;\"a\": 2, \"b\": 4&#125;' 上面代码中的f函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以2，否则就原样返回。 注意，这个处理函数f是递归处理所有的键。递归的意思是若f函数的返回值还是一个对象，就会用f函数继续处理这个对象，直到f函数返回一个值为止，f函数返回的是一个值（不是undefined），JSON.stringify方法才会处理这个值对应的属性。 123456789101112var o = &#123;a: &#123;b: 1&#125;&#125;;function f(key, value) &#123; console.log("["+ key +"]:" + value); return value;&#125;JSON.stringify(o, f)// []:[object Object]// [a]:[object Object]// [b]:1// '&#123;\"a\":&#123;\"b\": 1&#125;&#125;' 上面代码中，对象o一共会被f函数处理三次，最后那行是JSON.stringify的输出。第一次键名为空，键值是整个对象o；第二次键名为a，键值是{b: 1}；第三次键名为b，键值为1。 1234567891011121314var o = &#123;a: &#123;b: 1&#125;, c: &#123;d: 2&#125;&#125;;function f(key, value) &#123; console.log("["+ key +"]:" + value); return value;&#125;JSON.stringify(o, f)//[]:[object Object]//[a]:[object Object]//[b]:1//[c]:[object Object]//[d]:2//"&#123;/"a/":&#123;/"b/":1&#125;,/"c/":&#123;/"d/":2&#125;&#125;" 上面代码同上。 在递归处理中，每一次处理的对象，都是前一次返回的值。 一定是在递归处理中 ？？？ 1234567891011var o = &#123;a: 1&#125;;function f(key, value) &#123; if (typeof value === 'object') &#123; return &#123;b: 2&#125;; &#125; return value * 2;&#125;JSON.stringify(o, f)// "&#123;\"b\": 4&#125;" 上面代码中，f函数第一次处理对象o，键名为空，键值为整个对象{a: 1}, f函数内部判断发现键值为对象类型 就 返回{b: 2}，然后f函数处理{b:2}，键值为2，f直接返回2倍键值。最后JSON.stringify方法就处理修改后的对象o。 如果处理函数返回undefined或没有返回值，则该属性会被忽略，即不会被JSON.stringify方法处理转换成JSON格式字符串。 123456789function f(key, value) &#123; if (typeof(value) === "string") &#123; return undefined; &#125; return value;&#125;JSON.stringify(&#123; a: "abc", b: 123 &#125;, f)// '&#123;"b": 123&#125;' 上面代码中，a属性经过处理后，返回undefined，于是该属性被忽略了。 3 JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个,也就是10和20一个效果）；如果是字符串（不超过10个字符，多出的字符会被忽略掉），则该字符串会添加在每行属性前面。 123456789101112131415JSON.stringify(&#123; p1: 1, p2: 2 &#125;, null, 2);/*"&#123; /"p1/": 1, /"p2/": 2&#125;"*/JSON.stringify(&#123; p1:1, p2:2 &#125;, null, '|-');/*"&#123;|-/"p1/": 1,|-/"p2/": 2&#125;"*/ 4 若参数对象有toJSON 方法 如果参数对象有自定义的toJSON方法，那么JSON.stringify(obj)会相当于JSON.stringify(obj.toJSON())，而忽略原对象的其他属性。 下面是一个普通对象的例子。 12345678910var user = &#123; firstName: '三', lastName: '张', // 以下会生成一个user对象的属性，属性名为函数名fullname，数值值为函数返回值 get fullName()&#123; return this.lastName + this.firstName; &#125;&#125;;user.fullname //"张三"JSON.stringify(user) // "&#123;"firstName":"三","lastName":"张","fullName":"张三"&#125;" 现在，为这个对象加上toJSON方法。 1234567891011121314151617var user = &#123; firstName: '三', lastName: '张', get fullName()&#123; return this.lastName + this.firstName; &#125;, toJSON: function () &#123; return &#123; name: this.lastName + this.firstName &#125;; &#125;&#125;;JSON.stringify(user)//相当于JSON.stringify(user.toJSON())// "&#123;/"name/": /"张三/"&#125;" 上面代码中，JSON.stringify发现参数对象有toJSON方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。 Date对象就有一个自己的toJSON方法。 123var date = new Date('2015-01-01');date.toJSON() // "2015-01-01T00:00:00.000Z"JSON.stringify(date) // ""2015-01-01T00:00:00.000Z"" 上面代码中，JSON.stringify发现处理的是Date对象实例，就会调用这个实例对象的toJSON方法，将该方法的返回值作为参数。 toJSON方法的一个应用是，将正则对象自动转为字符串。因为JSON.stringify默认不能转换正则对象，但是设置了toJSON方法以后，就可以转换正则对象了。 12345678910var obj = &#123; reg: /foo/&#125;;// 不设置 toJSON 方法时JSON.stringify(obj) // "&#123;"reg":&#123;&#125;&#125;"// 设置 toJSON 方法时RegExp.prototype.toJSON = RegExp.prototype.toString;JSON.stringify(/foo/) // ""/foo/"" 上面代码在正则对象的原型上面部署了toJSON()方法，将其指向toString()方法，因此转换成 JSON 格式时，正则对象就先调用toJSON()方法转为字符串，然后再被JSON.stringify()方法处理。 同源策略只有 协议+域名+端口一模一样才允许发 AJAX 请求,所以AJAX相当安全例如你只要不是baidu.com里面的JS,你就不能向baidu.com这个网站发起AJAX请求。其实实际上AJAX请求已经发出去了，但request.readyState值始终为0，浏览器根本看不到响应的内容。http://baidu.com可以向http://www.baidu.com发 AJAX 请求吗? NO!http://baidu.com:80可以向 http://baidu.com:81发 AJAX 请求吗? NO! 浏览器必须保证 只有 协议+端口+域名 一模一样才允许发 AJAX 请求。CORS 可以告诉浏览器，我俩一家的，我们一摸一样，别阻止他。例如：当frank.com:8001想要访问jack.com:8002时,你要打电话给jack.com:8002的后端程序员，当jack.com:8002的后端程序员给sever.js要加上如下响应头后，frank.com:8001才能访问jack.com:8002。 response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://frank.com:8001&apos;) CORS 跨域突破同源策略 === 跨域CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。例如上面代码： response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://frank.com:8001&apos;) http://www.ruanyifeng.com/blog/2016/04/cors.html 使用CORS跨域 和 使用JSONP使用CORS跨域可以发送的请求种类不受限制，如：GET,POST,DELETE，PUT而JSONP只能发起GET请求。主要还是看后台的水平。 模拟windows下修改hosts文件，添加两个域名frank.com，jack.com，开两个服务器server，一个作浏览器，一个作服务器，模拟访问。 使用原生JS来发送AJAX请求请背 请背 请背 let request = new XMLHttpRequest() //1.生成一个XMLHttpRequest实例对象request request.open(&apos;get&apos;, &apos;/xxx&apos;) // 2.配置request对象 request.send() //3.发送request对象 request.onreadystatechange = ()=&gt;{ //4.监听request对象的readystate变化 if(request.readyState === 4){ if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300){ console.log(&apos;说明请求成功&apos;) }else if(request.status &gt;= 400){ console.log(&apos;说明请求失败&apos;) } } } 自己的心得标签有 添加路径的属性 就能向后台发送请求，比如form的action属性，img的src，link的href。AJAX貌似是前端的一个新的开始，此后开始百家争鸣。慢慢接触一些简单的后端代码，知道当浏览器遇到路径时，就会发起http请求，会进到路径里面去。这应该就是浏览器遇到路径，就会给这个路径的后端服务器发送请求，后端可以在这个路径里写好会执行什么代码，而浏览器会获取服务器端数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[初识JSONP]]></title>
    <url>%2F2018%2F12%2F28%2F%E5%88%9D%E8%AF%86JSONP%2F</url>
    <content type="text"><![CDATA[为什么需要有JSONP？JSONP是在改进用户体验中产生的。form表单提交数据会刷新页面，刷新就要重新渲染页面，用户体验就会下降；用img只能知道成功和失败，不能知道更多的数据，那用script怎么让后端知道我要执行什么代码呢，那就加callback参数，[script+callback参数]就是【JSONP】,然后后端就根据callback构造一个函数调用，把数据塞到函数的第一个参数，然后call一下，这样浏览器就得到了它想到的数据。这就是跨域获取数据。 什么是 JSONP？答：JSONP 是指在浏览器中通过动态创建 script 标签来发送GET请求，来得到服务端的数据的这么一种技术例如：请求方：frank.com 的前端程序员（浏览器）响应方：jack.com 的后端程序员（服务器） 请求方创建 script，src 指向响应方，同时传一个查询参数 ?callbackName=yyy 响应方根据查询参数callbackName，构造形如 yyy.call(undefined, &#39;你要的数据&#39;) 或 yyy(&#39;你要的数据&#39;) 这样的响应 浏览器接收到响应，就会执行yyy.call(undefined, &#39;你要的数据&#39;) 那么请求方就知道了他要的数据这就是 JSONP 约定： 1. `callbackName -&gt; callback` &lt;br&gt; 2. yyy -&gt; 随机数 frank12312312312321325()&lt;br&gt; 3. jQuery 用法 $.ajax({ url: &quot;http://jack.com:8002/pay&quot;, dataType: &quot;jsonp&quot;, success: function( response ) { if(response === &apos;success&apos;){ amount.innerText = amount.innerText - 1 } } }) 请问JSONP为什么不支持POST请求？答：因为JSONP是通过动态创建script实现的，动态创建script时只能用get，不能用post。 碎碎念什么是数据库数据库本质上就是一个文件。数据库其实就是硬盘上的一个文件数据库再厉害也不能不用文件存。 进入高级以后就是跟后端（服务器）打交道了。可以向后端发请求的标签form表单,script,a,link都可以向后台服务器发请求。但是form表单提交一定会刷新页面。script,a,link只能发起get请求，没有办法选择get，post。 Ajex是受域名影响的，script是不受域名影响的，JSONP也不受域名影响。JSON也是一门语言，其特点就是一定要加双引号。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DOM事件]]></title>
    <url>%2F2018%2F12%2F15%2FDOM%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[DOM事件简介我们主要学DOM Level2 ,因为DOM level 1介绍得很简单，而现在通行的DOM Level3并没有对事件进行大的修改和补充，所以我们主要学DOM Level2。 在同一个元素上设置多个监听事件。则监听事件按队列排序存储，一次点击同时触发，按照队列先进先出的原则触发。 在不同元素上设置监听事件，但这些元素存在爷爷爸爸儿子这样的关系。当点击子元素时，子父爷及祖先的监听事件都会被触发，即监听事件会传播。这样的监听事件触发分为捕获阶段和冒泡阶段，可通过设置参数true只执行捕获阶段，或者默认false冒泡阶段。设置stopPropagation可以阻断监听事件的传播。建议阻止传播，不然点击元素，容易同时触发父元素，爷爷元素的监听事件。bug就来了。 从上到下：捕获阶段，从下到上，冒泡阶段。 实例：点击别处关闭浮层 解决法用DOM事件addEventListener（）。 用jQuery写。这样写节省内存。 易错1 不知不觉一次触发多个事件，事件冲突 易错2 false会阻止prevent事件发生和传播propagation,建议单独设置设置false后，这个浮层里面checkbox点击不了 易错3 不加阻止传播 冒泡的演示]]></content>
  </entry>
  <entry>
    <title><![CDATA[用jQuery实现我们的简历吧]]></title>
    <url>%2F2018%2F12%2F13%2F%E7%94%A8jQuery%E5%AE%9E%E7%8E%B0%E6%88%91%E4%BB%AC%E7%9A%84%E7%AE%80%E5%8E%86%E5%90%A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[用jQuery做一个轮播]]></title>
    <url>%2F2018%2F12%2F12%2F%E7%94%A8jQuery%E5%81%9A%E4%B8%80%E4%B8%AA%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[内容样式行为分离内容（html负责） 样式（css负责）行为（JavaScript负责）分离。如果不这样做，用html做样式，代码混乱，主次不分；如果用css写内容，用户选择不了这个内容且js也选择不了；如果用css控制逻辑行为，那么css加载将会很慢；如果用JS控制css，比如$div.show(), $div.hide() 这两个API建议建议不使用,因为$div.hide()返回的display不确定，可能会影响我们原来的布局。其实这个解决办法很简单，我们只要用JS去切换状态就好了，如$div.addClass(‘active’),我们只用JS切换状态，至于这个状态下的样式该是什么样子，就由你CSS控制就好了。 轮播需求分析用户点击按钮，可以切换图片到可视窗口。 轮播分析轮播的思路思路1:用户看到的只是局部画面让4张图片横排后就像一张大图片images，而我们的让用户看到的窗口只有一张图片大小。思路2：滚来滚去用户点击按钮，将组合成的这一大张图片整体左移或者右移。 轮播功能优化 支持图片数量不限 实现自动播放(播放图片数量===图片应有数量) 自动切换到某图片对应按钮高亮使用jQuery的链式操作，可以一直.. ，注意下一次的操作对象是上一次链式操作的结果。 鼠标滑过图片自动轮播停止，滑出图片自动轮播继续。 自动轮播同时可点击按钮实现图片切换，同时按钮高亮 优化代码优化代码原则：看哪里有重复代码，哪里就能优化。 轮播技术细节 CSS布局就使用两种 display:flex;align-items:flex-start; display:float $(p1).on(&#39;click&#39;,function(xxx){function-body}),这是jQuery的写法，第一个参数是要触发事件的名称，第二个是触发的事件执行的函数。 img是可替换标签，要提前写好宽高，这样当浏览器图片还没有下载下来的时候，就会有个占位符占据这个位置，当浏览器把图片下载下来以后就用图片把占位符替换掉。提前写好img的宽高可避免重排问题，重排问题特别浪费cup。 注意allButtons[i]是DOM对象，log打出来就知道了 注意给用户看到的窗口只有一张图片大小，每次移动的宽度也是图片的宽度。即 窗口宽度 === 移动宽度/次 === 图片宽度 移动过程记得加动画过渡。 用括号把立即执行函数包起来就能避免使用全局变量。]]></content>
  </entry>
  <entry>
    <title><![CDATA[仿jQuery构造的两个函数]]></title>
    <url>%2F2018%2F12%2F12%2F%E4%BB%BFjQuery%E6%9E%84%E9%80%A0%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在我的理解，jQuery就是一个个封装好的函数，这些函数里面就是调用了DOM的API,可以理解为DOM的API难用，然后我们进行了API升级改造。jQuery对象是对dom对象的封装，在获取dom对象的基础上增加了很多对象的方法，所以它们是很类似但又不同的两种对象。 通过仿写jQuery来理解jQuery这是我在jsbin上写的两个封装函数的例子,供学复习使用。http://js.jirengu.com/hibeh/4/edit?html,css,js,console,output HTML代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;div&gt;div3&lt;/div&gt; &lt;div&gt;div4&lt;/div&gt; &lt;div&gt;div5&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; JavaScript代码 /*一、jQuery的API封装*/ window.jQuery = function(nodeOrselector){ /*1. 获取并重构nodes对象*/ let nodes = {}; if(typeof nodeOrselector === &apos;string&apos;){ let temp = document.querySelectorAll(nodeOrselector);//伪数组 for(let i = 0;i&lt;temp.length;i++){ nodes[i] = temp[i]; } nodes.length = temp.length; }else if(nodeOrselector instanceof Node){ nodes = {0: nodeOrselector,length: 1}; } /*2.1 给对象nodes添加方法addClass（函数属性）*/ nodes.addClass = function(classes){ //把classes值通过forEach函数传进去 classes.forEach( (value) =&gt; { for(let i=0;i&lt;nodes.length;i++){ nodes[i].classList.add(value); } }); } /*2.2 给对象nodes添加方法setText（函数属性）*/ nodes.setText = function(text){ if(text){ for(let i=0 ;i&lt;nodes.length;i++){ nodes[i].textContent = text; } } } /*3. 返回nodes对象*/ return nodes } /*二、jQuery的API使用*/ window.$ = jQuery var $div = $(&apos;div&apos;) $div.addClass([&apos;red&apos;]) // 可将所有 div 的 class 添加一个 red $div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 代码细节问题 html 就是加了几个div，没什么好说的。 js代码分为两部分，第一部分是封装jQuery的API过程。第二部分是使用jQuery的API 简单说，封装jQuery的API就是个把一堆代码封装成函数的过程，这个跟普通封装函数没有什么区别。这部分分为3步：1获取并重构nodes对象，也是个伪数组，有length。注意先要初始化nodes，即 let nodes = {};,然后我们在获取nodes对象的成员时，使用了DOM的API - querySelectorAll。2.1给对象nodes添加方法addClass（函数属性）,说白了就是nodes本来就是个对象，给对象加个（key）属性addClass，属性值(value)是个函数，这样我们在使用属性就能调用这个函数。在编写addClass这个函数我们用到了数组属性forEach，一定要记得传数组参数。还用到了箭头函数以及DOM的API - ndoe.classList.add。2.2 同理，给对象nodes添加方法setText（函数属性），这个函数也用了DOM的API - node.textContent。3 return nodes,一定要记得返回值，函数一定要有返回值，不然就给你 return undefined。 第二部分，jQuery的API使用。 window.$ = jQuery,那么$就是jQuery这个函数，可以少写单词。 var $div = $(&#39;div&#39;),此时$div就是nodes对象,这样我们就通过标签名获得了一组同名标签对象。建议在声明jQuery对象时在变量名前加$，这样就能清楚地知道这是jQuery的对象，要使用jQuery的API,而不是使用DOM的API。 $div.addClass([&#39;red&#39;])，这句话就是$div这个对象调用了它的属性函数addClass，同时传了一个数组参数[&#39;red&#39;]，注意必须是数组，因为我们用了forEach。这里还要注意一点是$div实际上也被传入到这个属性函数addClass里面了，这是不同于以前我学C语言。因为$div.addClass([&#39;red&#39;])实际上是$div.addClass.call($div,[&#39;red&#39;])的简写，后者是js函数调用的规范版。.前面的东西也是作为参数传入到函数里面的。 $div.setText(&#39;hi&#39;)，也是同上的原理，$div调用了它的属性函数setText，实际传入了两个参数$div和&#39;hi&#39;。 以下内容是我随堂记的笔记，比较零散，你可不看。 在编程里，变量名大写默认是常量。 有一个易错的点，不要用全局变量当作id，比如alert,parent之类的，你用了要么就是你覆盖别人，要么就是别人覆盖你。所以要么你不用全局变量，要么你造一个函数，把这个变量变成局部的。 DOM作业某题引发的关于全局变量、局部变量、立即执行函数的问题:用var声明一个变量，var会先找作用域，如果发现没有函数，那么var就会声明一个全局变量，那么就有可能将window的全局变量覆盖掉。然后JS就想了一个办法升级，用let在块{}里面声明变量，let是跑不出去{}外面的，如{let parent},这个parent就是局部变量，跑不出{}。而var由于可以变量提升，块{}是包不住var的，只有函数才能包住var，让var声明一个局部变量，如（ function(){var parent}.call() ）,这是立即调用函数的例子，必须用括号将函数括起来，不然会报错。立即调用函数可以写为( function(){var parent}() ) 易错题 调试大法，出bug时，一行行删能找到bug，但是注意你删的过程中不要造成新的bug。排bug大法。 jQuery的设计思想：给我一个node，给你返回对象；你给我一个id，我就能给你找到这个选择器。 总结简单说，jQuery就是封装了一些DOM的API的函数集合，也叫jQuery的API。jQuery的对象使用jQuery的API，DOM的对象使用DOM的API。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS:DOM的API]]></title>
    <url>%2F2018%2F12%2F10%2FJS-DOM%E7%9A%84API%2F</url>
    <content type="text"><![CDATA[&lt;html&gt;&lt;head&gt;&lt;body&gt;//三个标签都可以省略 DOM 是一棵树（tree）DOM--Document Object Model是XML文档的。DOM是把我们大脑里的Document树 映射成一个对象Object的这么一种模型。即在内存中Document的结点node是用一个个对象进行存储的，而我们程序员操作内存，就是操作这些对象。对象里面存储的内容又得看DOM规范来确定。 树上有 NodeNode 分为 Document（是html的爸爸）、Element（元素/标签）和 Text（文本），以及其他不重要的(注释结点等)。注意回车算文本结点。通过构造函数把结点变成对象。Node的原型链关系 Node 的接口 属性 childNodes 获取子结点（包括文本结点），children获取子标签结点 firstChild lastChild nextSibling previousSibling nodeName 一般都为大写 nodeType 记 1为标签结点，3为文本结点。 nodeValue innerText 注意：面试问：innerText的textContext的区别,同都是获取页面内容 textContent outerText ownerDocument 属于哪个文档 parentElement parentNode 涉及单词有： child / children / parent node first / last next / previous sibling / siblings type value / text / content inner / outer element 然后互相组合 方法 如果一个属性是函数，那么这个属性就也叫做方法；换言之，方法是函数属性 appendChild() cloneNode() true深拷贝 false浅拷贝 面试：深拷贝与浅拷贝的区别 contains() hasChildNodes() insertBefore() isEqualNode() 两个独立标签相等，但是不是相同的，相等和相同的概念不一样 isSameNode() 相同，同一个（标签），=== removeChild() 只是从页面中移除了这个标签，但是它还存在内存中 replaceChild() 替换 normalize() // 常规化，合并文本结点 看MDN例子 搞清楚英文单词的意思就知道用法 如果发现知道英文后依然不明白用法，看 MDN 的例子即可 DOM APi 无外乎「增删改查」 Document 接口 属性 anchors 弃用 body characterSet childElementCount children doctype documentElement domain fullscreen head hidden images links 获取页面中所有的a标签 location onxxxxxxxxx origin plugins readyState referrer scripts scrollingElement styleSheets title visibilityState 方法： close() open() createDocumentFragment() createElement() createTextNode() execCommand() 当你想设计一个父文本编辑器时才用到。 exitFullscreen() getElementById() 基本没人用 getElementsByClassName() 基本没人用 getElementsByName() 基本没人用 getElementsByTagName() 基本没人用 getSelection() hasFocus() querySelector() 主要使用 只返回一个元素 querySelectorAll() 主要使用 返回所有元素，返回的是个伪数组 registerElement() write() writeln() 写一行Element 的接口看MDN总结当我们在控制台输入API的时候，控制台会告诉我们使用的API是哪个类型的结点提供的,如此你就能知道你将得到什么类型的Node。DOM面试唯一考点，google: DocumentFragment优化，面试前看一篇。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS函数]]></title>
    <url>%2F2018%2F12%2F10%2FJS%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这是面试知识点最密集的一课。函数可以没有参数，但一定要有return，不然会自动给你加return undefined； 函数的 5 种声明函数只有两种声明方法Function和function。 function f(){}直接用关键字function声明具名函数 function (){}用关键字function声明匿名函数,但是不能单独声明一个匿名函数，必须先声明一个变量，然后把匿名函数赋值给它。即 var f = function(){}; var f = function yy(){} var f =new Function(&#39;a&#39;,&#39;b&#39;,&#39;return a+b&#39;)用全局对象Function在声明一个函数，基本没人用。可采用拼接法。var n =1 ;var f =new Function(&#39;a&#39;,&#39;b&#39;,&#39;return a+&#39; + n + &#39;+b&#39;);f(1,2)//4 箭头函数。 f = (x,y)=&gt;{return x+y}箭头函数是匿名函数。数组和对象的区别：原型不同。数组和对象不同，其中之一就是两者的公有属性不同。数组之所以是数组，是因为它有数组的特点，而对象没有数组的特点。它们二者的原型是不一样的。 函数的name属性 函数的本质函数就是一段可以反复调用的代码块。作为一个程序员要更深地去理解函数，就要理解函数在内存是如何放的。函数是可以执行一段代码的对象。 如何调用函数 f.call小白执行f(1,2)正式的应该这样 f.call(undefined,1,2)。只有这样写才能正确理解this。用call方法时，第二个才是我们要传的参数。 this 和 arguments this就是f.call()里面的第一个参数，在JAVA里面比较有用，在JS里没什么用。当初是为了像JAVA而设计的，在JS里面没什么用，this就是一个参数。 arguments就是f.call()里除了第一个参数以外的其他参数。arguments是一个伪数组，伪数组的意思就是长得像数组，但是它的__proto__指向的不是Array.prototype，并且伪数组的整个原型链中都没有Array.prototype，即也使用不了a.push（）之类数组特有的函数API(没有数组的公有属性)。arguments就是一个长得像数组的普通对象。 什么是 call stackf.call()的过程就是先进后出的过程，类似栈。看到call就进入到函数里面,同时记下返回的地方，看到return就返回原来标记的地方，继续执行接下来的代码。栈空间有限，调用次数太多就会发生stack overflow. 作用域有函数就有作用域。一定要变量提升，一开始看见题目就要变量提升。浏览器在画作用域树的时候都是先找到所有变量声明，然后把这些声明都放到最前面。 变量提升(我错了两次) 作用域混淆 变量是这个变量，但是值会变，不一定相等。闭包闭包就是如果一个函数使用了它范围外（作用域）的变量，那么 【这个函数+这个变量】组合的整体 就叫做闭包。 闭包经常用来获取并保存某个环境里的数据，等着回调函数回来 取值。 例子1 12345678910111213141516console.log(i)for(var i=0; i&lt;6;i++) &#123; setTimeout(()=&gt;console.log(i), 0)&#125;console.log(i)// 依次输出undefined6// 最后 是 setTimeout 回调函数输出666666 上面代码中 只使用了 一层闭包，当同步操作执行完毕后，轮到 serTimeout 里的回调函数执行时，setTimeout(()=&gt;console.log(i), 0)，因为 回调函数里没有定义 i 变量，因此 log 函数里的 i 只能去寻找函数外的 i 变量，而 i 变量 经过 之前的同步操作(i++) 后，此时值为6，因此 寻找到的 i 变量 值为 6 ，6 次 循环 建立了6 个 异步操作setTimeout，因此输出 6 个 6。 下面这个例子就是使用了闭包。 1234567891011121314151617console.log(i)for(var i=0; i&lt;6;i++) &#123; (function (i) &#123; setTimeout(()=&gt;console.log(i), 0) &#125;)(i)&#125;console.log(i)// 依次输出undefined // 第一行代码执行结果6 // 第7行代码执行结果// 第 4 行 异步输出012345 上面哪里体现使用了闭包呢？ for 循环 初始化 循环变量 i = 0 ，会创建一个立即执行函数并同时向立即执行函数内传入i，此时 i 值为 0 ，因此该立即执行函数作用域内的 i 变量 值 也是 0，这是 第一处使用闭包。setTimeout 的 回调函数作用域里没有定义 i 变量，因此 setTimeout(()=&gt;console.log(i), 0) 回调函数 中的 i 访问的就只是 外部的i ，也就是 立即执行函数里的i，这是第二处使用闭包。 因着 setTimeout 是异步操作，就去事件队列排队去了，等同步操作执行完了就执行回调函数，所以暂时没有值输出，当 setTimeout 可以执行的时候，回调函数里的 i 就会去 函数 能访问的环境里找 i 变量 取值。，因为闭包的存在，是可以取到当时的值的接着执行 for循环的 i++，计数值加1 ，i为1 ，然后执行循环体，再创建一个立即执行函数，再使用两次闭包，将计数值 1 保留在环境中，setTimeout 还是去排队。一直等到 外部 i 加到 6 ，不满足循环条件，不再执行循环体，循环结束，然后执行 最后一个同步操作，console.log(i)，输出6。至此同步操作都结束了，就去事件队列里 看看 哪些 异步操作可以执行了 。此时 setTimeout 的回调函数才开始执行，而 回调函数作用域 i 的值因为使用了闭包，使得计数值还是当时的值，并没有被销毁，因此输出0 1 2 3 4 5。 实际上，6次循环 我们创建了 6 个 立即执行函数，通过使用闭包，分别将 6 个 计数值 分别 保留在 6 个立即执行函数中，并没有在函数结束后就立即销毁变量，所以当异步操作的 回调函数回来找 时 依然可以访问到。 这也是可以理解闭包的例子，首先函数在创建的时候就已经确定了该函数内部能够访问的环境作用域，就是这个函数所在的作用域。那么 函数 和 该函数能访问的环境 就叫做闭包。 使用 let 命令 可以达到 和 闭包一样的效果 123456789101112for(let i=0; i&lt;6;i++) &#123; setTimeout(()=&gt;console.log(i), 0)&#125;console.log(i)// 先报错 第4 行执行结果012345 使用 let 命名 声明 计数变量 i ，使得 for 循环 形成了一个独立的作用域，循环体内部可以访问 () 里定义的 循环计数变量，而 for 循环外部 又是 另一个作用域 ，可以看作这个代码的 根作用域，setTimeout 的回调函数里 是 函数作用域。也就是说 上面代码中，存在三个作用域。 1234567891011console.log(i)for(var i=0; i&lt;6;i++) &#123; setTimeout(()=&gt;console.log(i), 0)&#125;console.log(i)// 依次输出undefined6// 最后 是 setTimeout 回调函数输出 6 个 66 (6个) 使用 var 命名 声明 计数变量 i ， for 循环 并不是一个独立的作用域，() 里 定义的 循环计数变量 不仅循环体可以访问，循环体外也可以访问，实际上，() 里 定义的 循环计数变量 就是 for循环外部作用域的，也是这个代码的 根作用域，setTimeout 的回调函数里 是 函数作用域。也就是说 上面代码中，只存在两个作用域。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS数组]]></title>
    <url>%2F2018%2F12%2F05%2FJS%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[回忆：简单类型number,string,boolean加new生成对象，不加new就是生成简单类型。而对象array,function,狭义object加不加new都是生成object。 Array声明 var a = Array(3); var a = Array(3,3); var a = []; 数组var a = [1,2,3] a.xxx = &apos;xxx&apos; //&quot;xxx&quot; a.yyy = &apos;yyy&apos; //&quot;yyy&quot; a //(3) [1, 2, 3, xxx: &quot;xxx&quot;, yyy: &quot;yyy&quot;] 0：1 1：2 2：3 xxx:&quot;xxx&quot; yyy:&quot;yyy&quot; length:3 __proto__:Array(0) //遍历数组1 for(let i =0 ;i &lt; a.length; i++){console.log(a[i])} //1 2 3 //遍历数组2 for(let key in a){console.log(key);console.log(a[key]);} //1 2 3 xxx yyy 伪数组伪数组就是你的原型链中没有Array.prototype.说实话，我也没听懂这个是啥，先记着。 数组的API这些数组的API貌似都有遍历数组的功能。 a.forEach( function(x,y){function-body} )遍历。传函数参数。且函数必须有两个参数,第一个参数对应数组的value,第二个参数对应数组的key。函数参数可以有第三个参数，第三个参数就是数组a本身。实际上通过 .已经把数组a传入到forEach当中。以下分布分解：下面来看a.forEach的实质： API都是函数,函数的参数还可以是函数。控制台里: shift+回车 可以换行。JS内置排序为快速排序 a.sort(function(firstNumber,secondNumber){return firstNumber-secondNumber}),传函数参数，函数参数必须有两个参数，分别对应数组a的第一、第二个数。函数体return回的值决定排序顺序，默认采用快排。return回的值是正值表示从大到小排，负值表示从小到大排，0表示fn和sn相等，fn-sn表示从小到大排，sn-fn表示从大到小排。排完序后是覆盖原来的a数组，即存回原来a的内存处。 a.join(&#39;连接符&#39;),用间隔符间隔连接。 a.contact两个数组合并成一个数组，常用于数组复制。 a.map类似a.forEach，映射。区别是a.forEach没有返回值(undefined),而a.map要有返回值，要return返回一个值。 a.filter过滤两个API链起来使用。 a.reduce(function(){},0),这个求和API有两个参数，前一个是函数，要返回的，后一个是初始值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[搜索引擎大法]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%A4%A7%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言写这篇文章的原因是发现自己不太会用搜索引擎，为了不做一个古人，决定收录一些常用的例子。 size:zhihu.com css不正交]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS的对象]]></title>
    <url>%2F2018%2F11%2F27%2FJS%E7%9A%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JS语言内置了一些对象，我们需要知道这些对象。全局的概念就是在全文每个地方都能使用。 全局对象 window我们知道JS的出现就是为了能够控制浏览器行为，故浏览器先于ECMAscript存在。ECMAScript规定全局对象叫做global，但是浏览器把window作为全局对象。window是一个hash表，有很多属性。window 的属性就是全局变量。windows的属性分为两种，一种公有，一种私有。公有就是ECMAscript规定的，私有就是某些浏览器自己加的windows属性，且各浏览器表现出来的形式不一样。 ECMAScript规定的： global.parseInt global.parseFloat global.Number global.String global.Boolean global.Object 各浏览器自己加的属性: window.alert(弹框提示) window.prompt（用户填写） window.comfirm（用户确认） window.console.log（开发者） window.console.dir window.document（文档，其标准DOM由W3C组织制定） window.document.createElement window.document.getElementById window.history(浏览器，其标准为BOM) window.history.back 全局属性，window可省略下面我们学习四个全局属性，Number() String Boolean Object. var n1 = Number(&#39;1&#39;) 和 var n2 = 1; 与 var n3 = new Number(1)三者的区别：前二者声明数字number类型，后者为对象object类型 有一个重要的问题需要弄清楚，我们知道，简单类型（number/string/boolean）是没有属性的，但是上面为什么n2.toString又是成立的呢，其实是n2.toString返回的是一个临时对象temp的temp.toString()值，这是JS设计者想的一个办法，既能语法像JAVA满足boss的要求，又能方便程序员的使用。下面我们来看看var n2 = 1; n2.toString(); 这两句代码发生了什么： var n2 = 2; //1.声明了一个简单的number类型，值为2 n2.toString(); //2.执行这句时，发现n2不是一个对象，这时会在内存里新建一个临时对象temp,这个临时对象temp等价于用new Number(1)创建的对象（复杂数字，由属性和值组成）。 //3.调用temp的toString属性，将temp.toString的值返回 作为 n2.toString的值（实际上n2是没有属性的）。 //3.在返回值后temp这个对象会被立刻释放掉，立刻释放掉，下次又使用的时候又重新建temp临时对象。 //4.说明：temp这个临时对象随浏览器解析n2.String()这句代码而建立，随代码执行结束而释放。 //4.说明：可以往temp里面加属性，只不过temp用完就被释放，所以添加属性没有意义，下次找不见。 内存图 还有一个易错的问题：123 var s1 = String(1) 和 var s2 = &#39;this is a string.&#39;; 与 var n3 = new Number(&#39;this is a string.&#39;)三者的区别：前二者声明数字string类型，后者为对象object类型。代码在内存的原理同number，不再画图复述。看下图： var b1 = Boolean(4) 和 var b2 = false; 与 var b3 = new Boolean(false);三者的区别：前二者声明数字boolean类型，后者为对象object类型。第一为强制类型转换为boolean,第二是程序员方便使用，第三是给老板看，把 false包装成 对象。代码在内存的原理同number,string，不再画图复述 var o1 = Object(2) 和 var o2 = {}; 与 var o3 = new Object();三者的区别：第一是强制类型转换成对象类型，第二程序员常用声明一个对象类型，第三应付boss，仿JAVA。但是注意o2!==o3，两个不同的对象 全局函数 公用的属性藏在哪proto:object //proto这个属性不用写就有，每一个对象的 proto 存储「公用属性组成的对象」的地址。当解析一句代码时，如果这个不是对象，就包装成一个对象，自动生成__proto__。所有对象的公有属性（也叫原型）： Object.prototype;所有number的公有属性（也叫原型）： Number.prototype所有string的公有属性（也叫原型）： String.prototype所有boolean的公有属性（也叫原型）： Boolean.prototype 原型链多用开发者工具的控制台去验证，尝试理解。prototype和__proto__的区别：前者的函数的属性，后者是对象的属性。 重要公式-原型与原型链var 对象 = new 函数（）对象.proto === 函数.prototype //都指向同一个公有属性对象地址，调用API// 推论var number = new Number()number.proto = Number.prototypeNumber.proto = Function.prototype // ?因为 Number 是 Function 的实例 var object = new Object()object.proto = Object.prototypeObject.proto = Function.prototype //? 因为 Object 是 Function 的实例,Function 是 Object 的构造函数。 var function = new Function()function.proto = Function.prototypeFunction.proto == Function.prototye // ?因为 Function 是 Function 的实例！]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS的类型]]></title>
    <url>%2F2018%2F11%2F27%2FJS%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[类型的转换 转化为string 转化为number 转化为booleanfalsy(虚值)是在 Boolean 上下文中已认定可转换为’假‘的值，在使用强制类型转换转换成boolean时为 false。有以下五个为false,其他值都为true。 各类型的API待补充 垃圾回收如果一个对象没有被引用，它就是垃圾，将被回收。但是IE6有bug不会清垃圾。请在结束一天工作后用下面代码清垃圾。 内存图内存速度快，断电不保存；外存相对内存速度慢，断电内容保存。SSD外存速度接近内存，贵，易坏；机械硬盘，不易坏；固态硬盘；开机将硬盘的内容读到内存，给操作系统、浏览器等分配空间。浏览器先进行所有的变量提升（变量声明）;按顺序在stack先存好对象，后期再加属性值会很麻烦,所以在stack栈内存 存 对象在heap堆内存的地址，对象的内容实际上存在堆内存里。 深复制&amp;浅复制对于简单类型来说，赋值就是深复制,比较简单。var a = 1;var b = a;b = 2 ;a = ? //a===1，即b变a不变就是深复制对复杂类型的数据（对象）来说才分浅复制和深复制。对于对象来说，对Stack内存的地址拷贝（一个变，全都变）就是浅复制；对Heap内存进行完全的拷贝才是深拷贝这是浅复制的例子：这是深复制的例子：注意 b= a; b=null;是不会改变隐藏对象里的内容的,只有x.key = ‘yyy’才能改变对象里的内容，画图好理解。 面试题举例（易混）1 2??????3模拟执行过程：(Heap堆内存里存着两个对象{n：1}和{n:2}，地址为随机分配的addr34 和addr54) var a = {n:1}//var a,var {n:1}, a===addr34 var b = a //var b ,b===addr34 &apos;=&apos;是浅复制 a.x = a = {n:2} //这句话最容易理解错，首先浏览器从左往右看，再从右往左计算。 //从左往右看的时候，`a.x`和`a`里的`a===addr34`， //从右往左计算的时候，先执行a={n:2},执行后a===addr54； //然后a(addr34).x=a(addr54)。故a.x = a = {n:2}执行结束后，addr34地址存的对象多了一个属性x,属性x的值为addr54,即对象{n:2}在Heap里的地址。 //而b还是指向Heap地址为addr34这个对象，即b===addr54]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS的数据类型]]></title>
    <url>%2F2018%2F11%2F27%2FJS%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言笔记记录一些特殊的、易错内容。JS是集大家之所长的语言，容易上手。CoffeeScript 是JS的改良版，在这之后才出现的ES6,ES7,ES8。目前掌握ECMAScript6（ECMAScript2015）标准就差不多了,从2015年以后，每年更新一次规范，更新的内容并不多。JS的语法特性通常是先投入使用，再写入规范。 简单类型numberJavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 0.1 + 0.2 ===0.3 //false 0.3/0.1 //2.9999999999999996 (0.3-0.2) === (0.2 - 0.1) //false 进制问题。JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。由于数字的影响，0开头的是八进制，电话号码要存字符串var string = &#39;01367122&#39; 十进制：没有前导0的数值或有前导0，但后面有数字8和9，则该数值被视为十进制。 八进制：有前缀0o或00的数值（鼓励使用），或者有前导0、且只用到0-7的八个阿拉伯数字的数值(废弃但支持)。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 0xff // 255 0o377 // 255 0b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 0xoo // 报错 0o88 // 报错 0b22 // 报错 NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 5 - &apos;x&apos; // NaN 0 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 typeof NaN //&quot;number&quot; NaN的运算规则。 //1.NaN不等于任何值，包括它本身。 NaN === NaN // false //2.数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 [NaN].indexOf(NaN) // -1 //3.NaN在布尔运算时被当作false。 Boolean(NaN) // false //4.NaN与任何数（包括它自己）的运算，得到的都是NaN。 NaN + 32 // NaN NaN - 32 // NaN NaN * 32 // NaN NaN / 32 // NaN Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity(0除以0会得到NaN)。都表示超出了正常的表示范围。Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1 / 0 // Infinity Infinity === -Infinity // false 1 / -0 // -Infinity -1 / -0 // Infinity string字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。习惯：CSS用双引号，JS用单引号。形如：&#39;我是字符串&#39; //1.转义符 `\`, 告诉浏览器我并不以我后面紧跟着那个字母结束，如`&apos; \&apos; &apos;` (表示单引号)。 var a = &apos;\&apos;&apos; //单引号 var n = &apos;\n&apos; //回车 var t = &apos;\t&apos; //Tab var b = &apos;\\&apos; // \ 符号 //2.单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 &apos;key = &quot;value&quot;&apos; &quot;It&apos;s a long journey&quot; //3.如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 &apos;Did she say \&apos;Hello\&apos; ?&apos; // &quot;Did she say &apos;Hello&apos; ?&quot; &quot;Did she say \&quot;Hello\&quot; ?&quot; // &quot;Did she say &quot;Hello&quot; ?&quot; 多行字符串输出问题 //1.输出为多行字符串 var s = &apos;12 /*这里的按[tab]键对齐，不是加空格，加空格会报错,也不是按回车[enter]*/ 345&apos; s //&quot;123 345&quot; ES6改进多行文本的BUG boolean只有两个值：true 和 false。下列运算符会返回布尔值： 前置逻辑运算符： ! (Not) 相等运算符：===(严格相等)，!==（严格不相等），==（相等)，!=（不相等） 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。6个falsy值： null undefined 0 NaN ‘’ false symbolgoogle: 方应杭 symbol。现在用不上。 undefined两个特殊类型: null undefined,都表示没有赋值，什么也没有。这是JS之父设计之初的bug。习惯用undefined表示空的，非对象（简单类型变量）；用null表示空对象。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 Number(null) // 0 5 + null // 5 Number(undefined) // NaN 5 + undefined // NaN null后来从对象里面分出来的一个数据类型，习惯还称为 空对象。对象暂不赋值为null。 var obj = null; //声明一个空对象 复杂类型object对象就是一组“键名-键值对”（key-value）的集合，是一种无序的复合数据(简单类型数据+复杂类型数据)集合。可分为以下三种： 狭义的的object 数组arrey数组是特殊的对象（key键值为0 1 2 3 4 5…有序数，不用给键值） 函数function 大括号{}就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。var obj = {foo: &#39;Hello&#39;,bar: &#39;World&#39;};对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。如果键名是数值，会被自动转为字符串。如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。key的命名加了单引号&#39;&#39;,key的命名几乎没有任何限制，不会报错。 // 报错 var obj = { 1p: &apos;Hello World&apos; }; // 不报错 var obj = { &apos;1p&apos;: &apos;Hello World&apos;, &apos;h w&apos;: &apos;Hello World&apos;, &apos;p+q&apos;: &apos;Hello World&apos; }; delete的用法 for in 的用法 typeof 的用法]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS与画板]]></title>
    <url>%2F2018%2F11%2F21%2FJS%E4%B8%8E%E7%94%BB%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[画板分析：按下去鼠标-动鼠标-松开鼠标按在哪里？事件：document.onmousedown = function(x){console(x)} 监听动作？ 事件：document.onmousemove = function(y){console(y)} 松鼠标？事件：**document.onmouseup = function(z){console(z)} 通过上次键盘网站我们知道，function(x)中的x/y/z都是存放对应事件所有信息的hash表。 API-别人提供的可供程序员调用的 变量作用域 全局变量可以传进任何一个函数内部,且可以在任何地方对它赋值 设置在函数内部的变量只能在函数内使用 用元素做画板，画得太快导致线条不连续，有缺陷 专门有个标签做画板 &lt;canvas&gt;&lt;/canvas&gt;canvas 默认inline-block,不能设置为 block,可设置宽高&lt;canvas width=300 height=150&gt;&lt;/canvas&gt; 不建议用CSS样式控制canvas的初始宽高，这样做你只能得到canvas等比例缩放的，会出现滚动条，要用其它办法 查canvas mdn，熟悉各种JS 的 API，从在canvas画一个长方形开始 stroke描边 fill填充 clear挖空var canvas = document.getElementById(‘canvas’);var context = canvas.getContext(“2d”);context.strokeStyle = “bule”;context.strokeRect(1, 1, 100, 100);context.fillStyle = “white”;context.fillRect(1, 1, 100, 100);context.clearRect(45, 50, 40, 10); 注意 aaa.clientX`aaa.clientY是相对于视口的高度，也就是浏览器窗口(html)的高度，并不是对canvas的高度。canvas画图，点击时画的位置就是相对的，要解决这个bug，使相对于浏览器的位置 就是 相对于canvas的位置，即设置html,body{margin:0px;}` bug2只要用了xxx.onmousemove就会出现不连续的bug。 画rectangle 长方形 画三角形 画圈 画线 context是上下文 用canvas实现画连续的线思路：两个函数（画圈、画线），三个事件（按下鼠标、移动鼠标、松开鼠标)。参考视频：canvas画圈。关键点：lastPoint=newPoint bug3 用CSS样式给canvas加 width=100vh height=100vw导致画图会变形。不建议加CSS样式设置宽高，而是直接在canvas上面加宽高。 改进，多做几个画笔颜色，就像女孩用的眼影一样，做成一个小盒子，用户可点击可选择不同的画笔；加画笔盒子；加橡皮擦； 优化代码：给一坨东西取一个名字。 作用域的问题，放在最外面最前面的就是全局变量了。 用js给代码加className,添加状态实现控制，代替if()else() 变量提升：JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部 下面第二部分-添加功能 手机上可看、可用，多种颜色的画笔，保存，眼影盘把画笔包裹起来,美工，背景图 img 和 script用src，link用href git commit -v 能看到你对仓库的所有改动,这个时候可以对仓库的改动做一个总结。下次代替’git commit -m &quot;改动信息提交&quot;‘ google搜索的时候不想看到某个广告或内容可以用 -广告，如：阻止 980 - 索爱 meta:vp，添加viewport可以让页面不能缩放，这样PC端内容就以1：1的比例展示在手机端。实现canvas可以在手机上可看 解决手机可用问题,形如在PC端的xxx.onmousedown的mouse事件， 对应在手机上有xxx.ontouchstart的touch事件。手机没有mouse事件。所以当从PC端切换到手机端，只要更换监听事件就可以了。而不能简单通过手机和电脑来区分监听mouse和touch事件，有些手机不支持触屏，有些电脑可以触屏;而是根据设备是否支持touch 和mouse来区分监听哪个事件。区分设备是否支持touch触发：在PC端上：id.ontouchstart === defined,即touch未定义，就是说PC这个设备不支持touch事件；在手机端：id.ontouchstart === null,即touch被初始化了，现在为空，支持touch触发。故我们可以判断 id.ontouchstart的值来判断设备是否支持touch触发，测试时可直接在console命令台输入&#39;ontouchstart&#39; in document.body 特性检测：不是检测设备，而是检测设备是否具有这个功能特性。 mouse对应MouseEvent,touch对应TouchEvent,两个事件不一样,触屏一般都是支持多点触屏（同时用几个鼠标点基本不会出现）的。获取坐标的方法也不一样。TouchEvent的x,y坐标为xxx.touches[0].clientX和xxx.touches[0].clientY,其中trouches[0]是数组。 手机端的代码和PC端的代码一样，就是mouse换touch，取坐标的方法略微不一样，直接copy小改一下。 一般改进一个功能后就上传到github进行代码备份并添加备注信息。 给画笔加图标，给橡皮擦加图标http://iconfont.cn id.onclick某某某被点击后要执行什么，支持手机端和PC端的 id.onclick = function(){ 要执行的功能操作；} 加戏：添加默认状态示意，默认使用画笔，画笔一开始就高亮。如果eraser和brush被点击了，就变红且变大，让用户明确的知道选择了什么。 用CSS样式先做个颜色盘（各种形状），点哪个颜色给哪个颜色高亮一下，变大: transform:scale(2)；transition:all 0.3s context.strokeStyle = &#39;blue&#39; 意思是上下文的描边样式是蓝色。 一般标签是className,svg标签是classList。id.classList.add(&#39;class&#39;) id.classList.remove(&#39;class&#39;) 禁用滚动条，body{overflow:hidden;} 去掉ol,ul的样式。ol,ul{list-style:none;} 颜色盘的各种颜色用ul&gt;li结构和画笔的各种颜色也用ul&gt;li结构。位置都用绝对定位：position:fixed;left:10px;top:10px; 养成个习惯,js用id名，css用class名。 上下文颜色 和 线条宽度 由开始的写死 变成点击对应颜色或线条后改变如： red.onclick = function(){点击红颜色，给画笔换成红色*(context.strokeStyle = ‘red’)，其他颜色不选择}thin.onclick = function(){点击细线，给画笔设置宽度（context.lineWidth = 3）小一点的},或者在外面定义全局变量lineWidth,对应点击赋值，初始设置context.lineWidth = lineWidth bug是一定有的，这是线条还是不完美。需要改bug 需求是无限加的，加 清屏 撤销 保存下载按钮,加icon,每次加完icon都要更新我们的js代码，重新添加js代码到我们的&lt;script&gt;&lt;/script&gt;清屏：google: js canvas clear建一个大的清空长方形保存下载：google:js canvas save as image 学会google很重要 修bug改bug 上传到github更新很慢，启用局域网调试。google查windows的局域网地址，用手机访问 局域网地址:8080 添加CSS样式，让canvas绝对定位 position:fixed 可以给画出的东西加CSS滤镜，不需要服务器，只用浏览器就可以。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS初]]></title>
    <url>%2F2018%2F11%2F18%2FJS%E4%B8%8E%E5%AF%BC%E8%88%AA%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[document.onkeypress = function(randomName){ console.log(&apos;你按下的这个键所有信息是：&apos;) console.log(randomName) //猜想randomName是存所有信息的hash表名 } 新建 二维数组和hash表。 用js代码写html。 添加CSS样式 监听用户事件-即用户输入q打开qq.com获取用户输入的键值–取出对应hash表的网站域名–修改当前网站地址/新开窗口打开 加功能-用户自己设定按键对应的网站用js给kbd里加儿子button标签，加css样式。当鼠标滑过kbd时，显示button的值。 使用localStorage，将用户修改的网站地址保存到本地，避免出现用户刷新网页后，网页内容还是原来程序员自定义的网址。方法是把存修改后地址的变量保存到这个js之外的地方去。首先获取用户编辑button对应的键值，用prompt获取用户要变更的网址，变更哈希，在这步结束以后，用户若是刷新网页，以上更改内容无效，于是用localStorage 把 变更过的hash表 保存到random的桶里，还必须在前面加上每次刷新网页时优先读取localStorage 的random 桶里的hash表。这样一来，要是上次用户修改了网页，当下次用户再次打开网页时，优先读取的是 修改过后的网站hash表。这就做到了实现用户自定义网站的要求。 键盘导航的功能基本够了，现在给键盘加CSS样式，立体，阴影，hover之类的。 加网站图标。 /favicon.icon 这个还挺麻烦的，加img标签及CSS样式，JS实现功能。有点容易错 if(hash[row[index2]]){img.src = ‘http://‘ + hash[row[index2]] + ‘/favicon.ico’}else{img.src = ‘//i.loli.net/2017/11/10/5a05afbc5e183.png’}/*监听失败事件*//*console.log(&#39;获取icon失败了&#39;)*/img.onerror = function(shijianName){shijianName.target.src = ‘./failphoto.jpg’} 在用户修改网站后，不仅要立即更新hash表存档，还要马上更改icon,用js实现 button.onclick = function(randomName){ //button被点击了 //console.log(randomName) 这里的randomName就是事件click 哈希表的名称，randomName这个hash表存着这个事件的所有信息,打印出事件的所有信息 button2 = randomName[&apos;target&apos;] //randomName[&apos;target&apos;]是用户点击的元素 img2 = button2.nextSibling //button2.nextSibling 可以取到当前被点击的button2的下一个兄弟 var key = button2[&apos;id&apos;] //q w e r t y 取出用户要编辑哪一个kbd的键值 //console.log(randomName[&apos;target&apos;][&apos;id&apos;] /*这里用key是错误的，这里没有按下kbd没有[&apos;key&apos;]，不能像下面一样用*/) var x = prompt(&apos;请输入要变更的网址&apos;) //获取用户要更改的网址 hash[key] = x //hash变更 //console.log(hash) //每次都打出hash //hash变更后要立刻存档到randomN localStorage.setItem(&apos;randomN&apos;,JSON.stringify(hash)) //JSON.stringify(hash)是把hash变成字符串的 //hash变更 if(hash[key]){img2.src = &apos;http://&apos;+hash[key]+&apos;/favicon.ico&apos;} //对应网站icon也要变更 else{img2.src = &apos;//i.loli.net/2017/11/10/5a05afbc5e183.png&apos;} /*监听失败事件*//*console.log(&apos;获取icon失败了&apos;)*/ img2.onerror = function(shijianName){shijianName.target.src = &apos;./failphoto.jpg&apos;} } 解决bug。onerror 各种bug，测试。一般一个事件发生以后，我们可以知道这个事件所包含的所有信息，button.onclick = function(randomName){}，如这个事件的所有信息都存在randomName这个桶里（也是一个hash表），我们可以打出这个桶里的信息，可以通过randomName.target获得事件每次发生的对象，而不是用button,button往往存的是最后一个值。 优化代码-组装函数。可选做很酷，先完成前面。封装函数就是把能实现一个功能的代码包起来，命个名字。代码结构由 数组型 变成 树形，逻辑清晰，易读性高，纠错快！ 只看一个子树就好了，每个子树的代码也不会很长，这样也不会疲倦。原来我在学C语言的时候，封装成函数是这个原因啊！确实很有道理 知识 在写页面之前，先画一下这个页面的功能有哪些。 用数据结构分析页面 数组的样子，和 hash表的样子 js声明变量 js的if结构 js的while结构 js的API函数 用js写html 用开发者工具调试-console &amp; application 开发者工具模拟3g慢速网 背景图片不能太大，裁剪图片，太久加载不出来用户就不会打开了 获取网站的icon，例如：点击获取微博的icon http://weibo.com/favicon.ico 上传一个图片 标签就是一个哈希表 18的习题要做一个错题收集。还没学过基础知识，还是有点模糊。 以上内容供自己回顾使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言：只有先搞清楚数据结构，才能去想算法。 哈希表（Hash Table）在计算中，哈希表（哈希映射）是实现关联数组抽象数据类型的数据结构，该数据结构可以将键映射到值。哈希表使用哈希函数来计算桶或槽阵列的索引，从中可以找到所需的值。简单说，哈希表(数组)的结构就是 {key:value;key:value;key:value;key:value;key:value;key:value;} 计数排序中的桶（复杂度 O(n+max)，比快排还快n是数的总数，max是hash表的长度（桶的个数）。计数排序算法看上次笔记《算法》 桶排序思想很多排序里面都有桶，桶排序每个桶里不止放一个数，桶排序每一个桶里放一个范围内的数，然后每个桶里的数是乱序，还要采用其他排序。 基数排序思想定下0-9十个基数（基数排序10个桶固定），将一组数 先按个位数相同进桶，按照先进先出的原则出桶，此时得到的一组数个位是按从小到大排好的；将上步得到的这组数 按十位数相同进桶，按照先进先出的原则出桶，此时得到的数十位是按从小到大排好的，同时十位相同的一组数的个位也是排好从小到大顺序的；再将上步得到的这组数按百位数相同依次进桶，依此类推，第三次进桶出桶以后，这组数百位从小到大排列的，同时百位数相同的几个数，其低位是排好序的（也就是个位和十位是排好的）,这就是基数排序的算法思想。这里特地说一下，进桶的原则是基数相同进同一个桶，出桶的原则是 同一个基数桶里，按先进先出的原则 出桶。 计数排序、桶排序、基数排序三者的区别排序就是要么浪费空间，要么浪费时间。这三种排序都是出桶和入桶桶排序就是先分范围再排序，桶数量不固定，浪费空间； 计数排序一个桶内放一个数，排序简单，桶数量不固定，浪费桶； 基数排序适合1-10万这种差距大的数，桶数量固定。 队列（Queue） 先进先出 可以用数组实现 举例：排队，线上购买火车票,前面基数排序 同一个桶出桶就是按照先进先出原则，也就是说同一个桶中所有的数就构成一个队列。 栈（Stack） 先进后出 可以用数组实现 举例：上楼下楼 故数组既可以是队列quene，也可以是栈stack。数组不是数据结构，数组是哈希表,一个索引标记的空间装着一个数 链表（Linked List） 数组无法直接删除中间的一项，链表可以数组删除一个数，非常复杂，先清空该位置，再将后面的数依次前移。 用哈希（JS里面用对象表示哈希（对象的结构就是哈希表结构））实现链表。只要看到一个哈希指向另一个哈希，另一个哈希又指向另一个哈希的结构就是链表。j不常用链表在链表中，删除一个数，只需要把这个数上一个节点的指针指向这个数下一个节点，再释放掉这个数所在的节点空间。 head表头、node节点 概念 故发现数组查询一项很快，而 链表（尤其中间删除）删除很快。前端常用 数组 而 不是链表 树（tree）如果哈希表之间满足如下关系，就是树。 举例：层级结构、DOM只要用到 层级结构 就用到 树。 概念：层数、深度、节点个数 二叉树binary tree—一个节点只能开两个叉 满二叉树—-叶子节点是长满的 完全二叉树—除最后一层外其他层都是满的/最后一层某些节点差右子树 完全二叉树和满二叉树可以用数组实现，普通树只能用链表表示,因为从节点从左到右，不存在跳跃，利用节点层数和树的节点规律可以算出数组的索引，从而树结构用数组实现后，取数很方便。 其他树可以用哈希（对象）实现,类似链表。 操作：增删改查 堆排序用到了 tree其他树：B树、红黑树、AVL树 堆排序 堆排序可视为一棵完全二叉树即除最底层外，每一层都是满的，最底层可以缺少右边的叶子节点（相当于数组后面元素没有了）。故 堆可以用数组表示，每一个节点 对应 数组中的一个元素。 堆的特征：上面的数大下面的数小 最大堆：最大数在上面、最小堆：最小的数在上面 最大堆调整 堆排序概念最多、算法复杂 从右到左遍历数组（因为数组最右边是树的最右叶子结点），先做一次最大堆调整，得到最大数，再把最大数放在一遍，将剩下的数做最大堆调整，依次类推，最后我们就得到了一个堆。从最外层开始调，俩儿子做对比，挑出厉害的再跟爸爸对比， 爸爸辈再和爷爷做对比，如果爸爸有调整，那么儿子们需要和新来的爸爸再打架。不断这样做，做到没法打架。 堆排序可视化堆排序JS代码完整讲解（看到最后）]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[结构化编程 顺序结构 条件结构 循环结构变量&amp;常量js 不能使用数字,会自动把数字转成 字符串string，如&#39;字符串&#39;。不加引号的则是变量，变量是一个容器，可以装东西，而字符串是常量，不能变。排序算法思想，局部的结果就是最终的结果。画流程图程序是 赋值+运算，画流程图 普通赋值/运算 是 方形，比较判断是 菱形。数据结构和算法的相互依存性解决一个和数据有关的问题，分析问题，建立这个问题的数据结构，最后才去写算法，解决这个问题。在前端中，js使用的数据结构是 数组 和 对象，js没有指针，不用链表。5种算法大分类会第一种-分而治之算法，熟悉前三种，贪婪算法就是 把眼前最优解 当作整体最优解，动态规划算法 是把局部最优解当作 整体最优解。分而治之是最好用的。排序冒泡排序（大的往后排）选择排序（每次都找出一个极端排最前或最后）插入排序（扑克牌起牌算法）计数排序（强迫症收牌算法）：优点速度比快排还快，缺点需要空间大需要先放好桶（准备好空间）。在收牌结束的时候就排好序了。不能排小数和复数，不然需要的空间太大了。计数排序—入桶演示： 快排（排序的速度快），不要老是选择第一个元素为轴心归并排序堆排序 排序变成伪代码查看排序效果演示通过看演示效果，冒泡排序算法就是一堆机械重复。]]></content>
  </entry>
  <entry>
    <title><![CDATA[入门复习小结]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%85%A5%E9%97%A8%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[回顾目前所学的知识点计算机是如何存储数据的0和1的存储 软件安装主要是gitbash 命令行基础多记单词 pwd print working dir 打印出当前正在使用的目录名 cd change dir 进入这个目录,常用的如 返回上一级目录cd ..，进入hexo目录 cd /e/hexo mkdir make directories 创建一个新的目录，如mkdir test mkdir /e/hexo/test touch 新建一个文件，不可给文件添加内容，如touch 1.txt echo &quot;hi&quot; &gt; 1.txt ，echo一个新文件1.txt，并将内容”hi”添加到1.txt echo &quot;hi&quot; &gt;&gt; 1.txt ，追加内容”hi”到文件1.txt，若1.txt不存在，则新建1.txt再追加。 echo &quot;hi&quot; &gt;! 1.txt 没使用过。强制覆盖内容 cp -r copy files and directories /copy directories recursively 拷贝文件/递归的拷贝目录 ， 如 cp test(必须已存在) cptestrm -rf remove files or directories/ remove directories and their contents recursively/f-force 强制的移除文件/目录里的所有内容，如rm -rf test mv move (rename) files/Rename source to dest/move source(s) to directory. 重命名文件， 如 mv 1.txt(必须已存在) 2.txt tree list contents of directories in a tree-like format 以树结构的形式列出目录里的内容。 git initgit add . /常用/git commit . -m “hi” /常用/git commit=Record changes to the repository`-m=-message` git pull git push /常用/git clone curl -L http://baidu.com curl -s -v -- http://baidu.com ping qq.com /*hexo与github快速搭建博客*/ hexo init hexo g hexo server //不常用 hexo deploy 脚本由单个命令行到写个小脚本，计算机按照你写的脚本执行脚本，就完成一些列工作。程序复用可以省很多工作。 HTTP 入门前面四节课的知识都是为了HTTP入门储备知识，HTTP是前端的第一个核心知识。方方说以后也是围绕HTTP来学。前面我们用命令行curl和直接查开发者工具 学习请求和响应的四部分。 命令行查看： curl -L http://baidu.com curl -s -v – http://baidu.com 面试考默写请求和响应四部分、状态码： GET 请求GET /?w=1 HTTP/1.1 Host: baidu.com Accept: text/html 对应响应 HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Content-Length: 10000 POST 请求 POST /login?w=1 HTTP/1.1 Host: baidu.com Accept: application/ms-word Content-Type: application/x-www-form-urlencoded Content-Length: 10 username=fangfang&amp;password=mima 响应 HTTP/1.1 403 Forbidden Content-Type: application/md-word Content-Length: 200 word格式 Node.js ServerNode.js Server，是为了学server，不是学Node.js，也是为了学HTTP怎么运作起来的。自己用脚本写了一个小server,平时使用别人开发出来的http-server . -c-1,可在本地浏览调试html HTML 几个经常使用的标签 和 几个难的标签。有很多细碎的知识点。无难点，多动手。 可加meta&lt;meta charset=&quot;utf-8&quot;&gt; 要想浏览器浏览量高，可加&lt;meta name=&quot;keyword&quot; content=&quot;前端开发&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;前端开发&quot;&gt; a标签是发起get请求，form标签是发起post请求。 最后说的话 前12次课，学了前端的简单HTTP,简单HTML，简单CSS应用，第二个练手项目-一个在线静态简历。前四节课练手项目-hexo+github搭建个人博客。 要多练手CSS写静态页面，上设计师网站去临摹作品，google:web page free psd,上切图网站可以下载很多PSD文件 看阮一峰的CSS理论+小demo CSS页面只有 好看 好看 好看 的说法，没有人关心CSS代码写得好不好 src和href的搭配。a和link标签用href，img和script和iframe用src]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F09%2FCSS%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[CSS布局,从上到下。从内到外，注意细节。无难点，多动手。 CSS布局是否兼容IE8？如果需要兼容IE8那就用 float布局，定宽 或百分比实现弹性布局。 不需要兼容IE8 就用 flex布局，弹性宽度，例如 移动端就用flex布局 原则 不到万不得已，不要写死 width 和 height。 PC端最外面div设置mix-height，里面再设置一层写width=mix-height。移动端宽度一定不要写死，设置width: auto。PC端要兼容IE的话可以写死高度宽度，然后就一直float float，不要用高级语法了。左浮左浮，均匀布局。 flex 布局 尽量用高级语法,能用的都用上，如 calc() 如果是 IE，IE能把页面写出来就不错了，就宽度高度全部写死 float布局float布局是目前应用最广的，兼容IE5。核心方法就是： 0 把宽度算好 1 儿子全加 float: left （right） 2 父亲 加添加类 class=&quot;clearfix&quot; 12345.clearfix::after&#123; content:''; display:block; clear:both; &#125; 两栏布局（百分比布局，弹性布局）基本原型：外面的两个div已经被固定作为布局了。关键就是两个儿子就已经把布局给固定了。代码还是要实际敲才有感受。 123456789101112131415161718192021&lt;style&gt; .parent &#123; border: 1px solid red; background: green; margin: 0 auto; //儿子居中 &#125; .child:nth-child(1) &#123; width: 30%; text-align: center; &#125; .child:nth-child(2) &#123; background: blue; width: 70%; text-align: center; &#125; .clearfix::after &#123; content: ''; display: block; clear: both; &#125;&lt;/style&gt; 12345678&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; 儿子1 &lt;/div&gt; &lt;div class="child" style="float: left"&gt; 儿子2 &lt;/div&gt;&lt;/div&gt; 扩展应用：两栏布局的中间加了margin，留白。外面的两个div已经被固定作为布局了。 123456789101112131415161718192021222324&lt;style&gt; .parent &#123; border: 1px solid red; margin: 0 auto; //儿子居中 &#125; .child:nth-child(1) &#123; width: 30%; text-align: center; &#125; .child:nth-child(2) &#123; background: blue; width: 70%; text-align: center; &#125; .clearfix::after &#123; content: ''; display: block; clear: both; &#125; .grandchild &#123; margin-right: 20px; background: green; &#125;&lt;/style&gt; 123456&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; &lt;div class="grandchild"&gt;孙子1&lt;/div&gt; &lt;/div&gt; &lt;div class="child" style="float: left"&gt;儿子2&lt;/div&gt;&lt;/div&gt; 两栏布局（定宽）123456789101112131415161718192021222324252627282930&lt;style&gt; .parent &#123; background: #ddd; margin: 0 auto; /* 儿子居中 */ min-width: 500px; /* pc网页限制最小宽度，超过最小宽度出现滚动条 */ &#125; .child:nth-child(1) &#123; width: 80px; /* 小宽度写死 */ background: black; height: 40px; /* 假设logo宽度 */ line-height: 40px; /* 行高=高度，实现单行文本垂直居中 */ text-align: center; /* 单行文本水平居中 */ color: white; &#125; .child:nth-child(2) &#123; /* 大宽度就不写死，根据内容自适应 */ line-height: 24px; /* line-height可以控制字体的高度，24+8+8=40 左边logo和右边导航栏高度相等，就自动对齐了*/ padding: 8px 0; &#125; .clearfix::after &#123; /* IE9以下不支持 */ content: ''; display: block; clear: both; &#125; .clearfix &#123; zoom: 1; /* 兼容IE6 */ &#125; .navItem &#123; margin-left: 20px; &#125;&lt;/style&gt; 123456789101112&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; logo &lt;/div&gt; &lt;div class="child clearfix" style="float: right"&gt; &lt;div class="navItem" style="float: right"&gt;导航1&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航2&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航3&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航4&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航5&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 用float实现均匀布局方法1：缺点语法太高级，IE9以下不支持 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;style&gt; .parent &#123; background: #ddd; margin: 0 auto; /* 儿子居中 */ min-width: 500px; /* pc网页限制最小宽度，超过最小宽度出现滚动条 */ &#125; .child:nth-child(1) &#123; width: 80px; /* 小宽度写死 */ background: black; height: 40px; /* 假设logo宽度 */ line-height: 40px; /* 行高=高度，实现单行文本垂直居中 */ text-align: center; /* 单行文本水平居中 */ color: white; &#125; .child:nth-child(2) &#123; /* 大宽度就不写死，根据内容自适应 */ line-height: 24px; /* line-height可以控制字体的高度，24+8+8=40 左边logo和右边导航栏就对齐了*/ padding: 8px 0; &#125; .clearfix::after &#123; /* IE9以下不支持 */ content: ''; display: block; clear: both; &#125; .clearfix &#123; zoom: 1; /* 兼容IE6 */ &#125; .navItem &#123; margin-left: 20px; &#125; .banner &#123; width: 600px; height: 300px; background: #aaa; margin: 10px auto 0; /* 定宽的元素设置margin: 0 auto;才会水平居中 */ &#125; .pictures &#123; width: 600px; margin: 0 auto; &#125; .picture &#123; width: 135px; /* 宽度根据总宽度计算出来的 */ height: 135px; margin: 10px; background: #777; &#125; /* 用float作平均布局 方法1 缺点语法太高级，IE9以下不支持*/ .picture:nth-child(4n+1) &#123; margin-left: 0; &#125; .picture:nth-child(4n) &#123; margin-right: 0; &#125;&lt;/style&gt; 1234567891011121314151617181920212223&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; logo &lt;/div&gt; &lt;div class="child clearfix" style="float: right"&gt; &lt;div class="navItem" style="float: right"&gt;导航1&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航2&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航3&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航4&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航5&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="banner"&gt;&lt;/div&gt;&lt;div class="pictures clearfix"&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt;&lt;/div&gt; 重点：用float实现均匀布局方法2，负margin法，需要计算。优点： 兼容IE5的，兼容所有浏览器。不满8个卡片也是ok的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt; .parent &#123; background: #ddd; margin: 0 auto; /* 儿子居中 */ min-width: 500px; /* pc网页限制最小宽度，超过最小宽度出现滚动条 */ &#125; .child:nth-child(1) &#123; width: 80px; /* 小宽度写死 */ background: black; height: 40px; /* 假设logo宽度 */ line-height: 40px; /* 行高=高度，实现单行文本垂直居中 */ text-align: center; /* 单行文本水平居中 */ color: white; &#125; .child:nth-child(2) &#123; /* 大宽度就不写死，根据内容自适应 */ line-height: 24px; /* line-height可以控制字体的高度，24+8+8=40 左边logo和右边导航栏就对齐了*/ padding: 8px 0; &#125; .clearfix::after &#123; /* IE8支持 */ content: ''; display: block; clear: both; &#125; .clearfix &#123; zoom: 1; /* 兼容IE6 */ &#125; .navItem &#123; margin-left: 20px; &#125; .banner &#123; width: 600px; height: 300px; background: #aaa; margin: 10px auto 0; /* 定宽的元素设置margin: 0 auto;才会水平居中 */ &#125; .pictures &#123; /* 父元素已经用于定位了，margin也不能改 */ width: 600px; margin: 0 auto; &#125; .picture &#123; width: 135px; height: 135px; margin: 10px; background: #777; &#125; .middle &#123; /* 加个负margin，就能去掉首、尾子元素的左、右，子元素就能对齐均匀分布了 */ /* background: #555; margin-left: -10px; margin-right: -10px; */ margin: 0 -10px; /* 给一个没有宽度的div负margin，它就会撑出去。 */ &#125;&lt;/style&gt; 12345678910111213141516171819202122232425&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; logo &lt;/div&gt; &lt;div class="child clearfix" style="float: right"&gt; &lt;div class="navItem" style="float: right"&gt;导航1&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航2&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航3&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航4&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航5&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="banner"&gt;&lt;/div&gt;&lt;div class="pictures"&gt; &lt;div class="middle clearfix"&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;div class="picture" style="float: left;"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; flex 布局父元素加 display: flex;justify-content: center;align-items: center;,那么子元素就水平垂直居中。 此外还有 justify-content: space-between;两端对齐，多余的空间放到中间。 justify-content: space-around;多余的空间放到子元素的两边。 flex布局简单，但是不满8个卡片，样式会有改变，跟卡片的个数和宽度有关系。卡片宽度根据包裹卡片的div宽度有关系。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; .parent &#123; background: #ddd; margin: 0 auto; /* 儿子居中 */ min-width: 500px; /* pc网页限制最小宽度，超过最小宽度出现滚动条 */ &#125; .child:nth-child(1) &#123; width: 80px; /* 小宽度写死 */ background: black; height: 40px; /* 假设logo宽度 */ line-height: 40px; /* 行高=高度，实现单行文本垂直居中 */ text-align: center; /* 单行文本水平居中 */ color: white; &#125; .child:nth-child(2) &#123; /* 大宽度就不写死，根据内容自适应 */ line-height: 24px; /* line-height可以控制字体的高度，24+8+8=40 左边logo和右边导航栏就对齐了*/ padding: 8px 0; &#125; .clearfix::after &#123; /* IE8支持 */ content: ''; display: block; clear: both; &#125; .clearfix &#123; zoom: 1; /* 兼容IE6 */ &#125; .navItem &#123; margin-left: 20px; &#125; .banner &#123; width: 600px; height: 300px; background: #aaa; margin: 10px auto 0; /* 定宽的元素设置margin: 0 auto;才会水平居中 */ &#125; .pictures &#123; width: 600px; /* 跟banner等宽 */ margin: 0 auto; display: flex; justify-content: space-between; flex-wrap: wrap; /* 一定设置允许换行，不然挤成一坨 */ &#125; .picture &#123; width: 135px; height: 135px; background: #777; margin: 10px 0; &#125;&lt;/style&gt; 1234567891011121314151617181920212223&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; logo &lt;/div&gt; &lt;div class="child clearfix" style="float: right"&gt; &lt;div class="navItem" style="float: right"&gt;导航1&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航2&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航3&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航4&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航5&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="banner"&gt;&lt;/div&gt;&lt;div class="pictures"&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;/div&gt; 缺点：但是不满8个卡片，样式会有改变。 为了改进这个缺点，使用display: flex; margin: 0 -10px; flex + 负margin 方法,不用浮动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style&gt; .parent &#123; background: #ddd; margin: 0 auto; /* 儿子居中 */ min-width: 500px; /* pc网页限制最小宽度，超过最小宽度出现滚动条 */ &#125; .child:nth-child(1) &#123; width: 80px; /* 小宽度写死 */ background: black; height: 40px; /* 假设logo宽度 */ line-height: 40px; /* 行高=高度，实现单行文本垂直居中 */ text-align: center; /* 单行文本水平居中 */ color: white; &#125; .child:nth-child(2) &#123; /* 大宽度就不写死，根据内容自适应 */ line-height: 24px; /* line-height可以控制字体的高度，24+8+8=40 左边logo和右边导航栏就对齐了*/ padding: 8px 0; &#125; .clearfix::after &#123; /* IE8支持 */ content: ''; display: block; clear: both; &#125; .clearfix &#123; zoom: 1; /* 兼容IE6 */ &#125; .navItem &#123; margin-left: 20px; &#125; .banner &#123; width: 600px; height: 300px; background: #aaa; margin: 10px auto 0; /* 定宽的元素设置margin: 0 auto;才会水平居中 */ &#125; .pictures &#123; width: 600px; /* 跟banner等宽 */ margin: 0 auto; /* 定宽的元素设置margin: 0 auto;才会水平居中 */ &#125; .middle &#123; display: flex; flex-wrap: wrap; /* 一定设置允许换行，不然挤成一坨 */ margin: 0 -10px; /* 外层的div.pictures用于定位，里面再加个div.middle用于添加负margin法 */ &#125; .picture &#123; width: 135px; /* 根据总宽度算出来的宽度 */ height: 135px; background: #777; margin: 10px 10px 0; &#125; &lt;/style&gt; 123456789101112131415161718192021222324&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; logo &lt;/div&gt; &lt;div class="child clearfix" style="float: right"&gt; &lt;div class="navItem" style="float: right"&gt;导航1&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航2&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航3&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航4&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="banner"&gt;&lt;/div&gt; &lt;div class="pictures"&gt; &lt;div class="middle"&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果如图： 再改进一下，别把卡片宽度写死，用cal()计算。 123456.picture &#123; width: 135px; /* 根据总宽度算出来的宽度 */ height: 135px; background: #777; margin: 10px 10px 0;&#125; 换成 123456.picture &#123; width: calc(25% - 20px); /* 根据浏览器自己算宽度 */ height: 135px; background: #777; margin: 10px 10px 0 10px;&#125; 因为使用了弹性布局，当卡片的总宽度未知时，也就是width: 600px;未知，使用width: calc(25% - 20px);能始终保持一行占4个卡片，缩放浏览器时卡片宽度也自动缩放。 1234.pictures &#123; width: 600px; /* 跟banner等宽 */ margin: 0 auto;&#125; 效果如图：当卡片的总宽度未知时，缩放浏览器时卡片宽度也自动缩放。 1：3布局，而且中间留有间隙空白12345678910111213141516171819202122232425262728&lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; logo &lt;/div&gt; &lt;div class="child clearfix" style="float: right"&gt; &lt;div class="navItem" style="float: right"&gt;导航1&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航2&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航3&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航4&lt;/div&gt; &lt;div class="navItem" style="float: right"&gt;导航5&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="banner"&gt;&lt;/div&gt;&lt;div class="pictures"&gt; &lt;div class="middle"&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="art clearfix"&gt; &lt;div class="aside"&gt;&lt;div class="aside-child"&gt;广告1&lt;/div&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;div class="main-child"&gt;广告2&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;style&gt; .parent &#123; background: #ddd; margin: 0 auto; /* 儿子居中 */ min-width: 500px; /* 在最外层设置pc网页最小宽度，超过最小宽度出现滚动条 */ &#125; .child:nth-child(1) &#123; width: 80px; /* 小宽度写死 */ background: black; height: 40px; /* 假设logo宽度 */ line-height: 40px; /* 行高=高度，实现单行文本垂直居中 */ text-align: center; /* 单行文本水平居中 */ color: white; &#125; .child:nth-child(2) &#123; /* 大宽度就不写死，根据内容自适应 */ line-height: 24px; /* line-height可以控制字体的高度，24+8+8=40 左边logo和右边导航栏就对齐了*/ padding: 8px 0; &#125; .clearfix::after &#123; /* IE8支持 */ content: ''; display: block; clear: both; &#125; .clearfix &#123; zoom: 1; /* 兼容IE6 */ &#125; .navItem &#123; margin-left: 20px; &#125; .banner &#123; width: 600px; height: 300px; background: #aaa; margin: 10px auto 0; /* 定宽的元素设置margin: 0 auto;才会水平居中 */ &#125; .pictures &#123; width: 600px; /* 跟banner等宽 */ margin: 0 auto; &#125; .middle &#123; display: flex; flex-wrap: wrap; /* 一定设置允许换行，不然挤成一坨 */ margin: 0 -10px; &#125; .picture &#123; width: calc(25% - 20px); height: 135px; background: #777; margin: 10px 10px 0 10px; &#125; .art &#123; width: 600px; /* 用于布局宽度 */ margin: 20px auto; &#125; .aside &#123; width: 33.3333%; /* 用于1:3的布局div */ float: left; &#125; .main &#123; width: 66.6666%; /* 用于1:3的布局div */ float: right; &#125; .aside-child &#123; margin-right: 20px; /* 这个20px是包括在第一个33.3333%里面的 */ background: #555; height: 300px; text-align: center; /* 水平居中 */ line-height: 300px; /* 单行文本设置line-height = height,就能实现里面文字垂直居中 */ &#125; .main-child &#123; background: #888; height: 300px; text-align: center; /* 水平居中 */ line-height: 300px; &#125;&lt;/style&gt; 或者换个方法使用计算属性，修改为以下代码 12345.aside &#123; width: calc(33.3333% - 20px); /* 用于1:3的布局div */ float: left; margin-right: 20px; /* 这个20px是包括总宽度里面的,因为用了左右浮动，其实可以不加 */&#125; 然后去掉在aside-child上加的margin-right 1234567.aside-child &#123; /* margin-right: 20px; 这个20px是包括在第一个33.3333%里面的 */ background: #555; height: 300px; text-align: center; /* 水平居中 */ line-height: 300px; /* 单行文本设置line-height = height,就能实现里面文字垂直居中 */ &#125; 效果和上面显示一样 现在将上面的布局做成手机布局1 加 meta:vp 不让页面缩放 1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; 2 使用media媒体查询实现手机布局，把所有的width都设置为 width: auto;，手机端不要写width flex 配合 media 就可以实现任何页面布局 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;响应式手机布局&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent clearfix"&gt; &lt;div class="child" style="float: left"&gt; logo &lt;/div&gt; &lt;div class="child clearfix"&gt; &lt;div class="navItem"&gt;导航1&lt;/div&gt; &lt;div class="navItem"&gt;导航2&lt;/div&gt; &lt;div class="navItem"&gt;导航3&lt;/div&gt; &lt;div class="navItem"&gt;导航4&lt;/div&gt; &lt;div class="navItem"&gt;导航5&lt;/div&gt; &lt;/div&gt; &lt;div class="nav"&gt;三&lt;/div&gt; &lt;/div&gt; &lt;div class="banner"&gt;&lt;/div&gt; &lt;div class="pictures"&gt; &lt;div class="middle"&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;div class="picture"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="art clearfix"&gt; &lt;div class="aside"&gt;&lt;div class="aside-child"&gt;广告1&lt;/div&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;div class="main-child"&gt;广告2&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141* &#123; margin: 0;padding: 0;box-sizing: border-box;&#125;.parent &#123; background: #ddd; margin: 0 auto; /* 儿子居中 */&#125;.child &#123; float: right;&#125;.child:nth-child(1) &#123; width: 80px; /* 小宽度写死 */ background: black; height: 40px; /* 假设logo宽度 */ line-height: 40px; /* 行高=高度，实现单行文本垂直居中 */ text-align: center; /* 单行文本水平居中 */ color: white;&#125;.child:nth-child(2) &#123; /* 大宽度就不写死，根据内容自适应 */ line-height: 24px; /* line-height可以控制字体的高度，24+8+8=40 左边logo和右边导航栏就对齐了*/ padding: 8px 0;&#125;.nav &#123; display: none; /* 默认pc看不见 */ &#125;@media (max-width: 420px) &#123; .nav &#123; display: block; /* 手机看得见 */ &#125; .parent &#123; display: flex; justify-content: space-between; &#125; .child:nth-child(2) &#123; display: none; &#125;&#125;.clearfix::after &#123; /* IE8支持 */ content: ''; display: block; clear: both;&#125;.clearfix &#123; zoom: 1; /* 兼容IE6 */&#125;.navItem &#123; margin-left: 20px; float: right;&#125;.banner &#123; width: 600px; height: 300px; background: #aaa; margin: 10px auto 0; /* 定宽的元素设置margin: 0 auto;才会水平居中 */&#125;@media (max-width: 420px) &#123; /* 媒体查询适配手机 */ .banner &#123; width: auto; &#125;&#125;.pictures &#123; width: 600px; /* 跟banner等宽 */ margin: 0 auto;&#125;@media (max-width: 420px) &#123; .pictures &#123; width: auto; overflow: hidden; /* 超过了隐藏 */ &#125;&#125;.middle &#123; display: flex; flex-wrap: wrap; /* 一定设置允许换行，不然挤成一坨 */ margin: 0 -10px;&#125;.picture &#123; width: calc(25% - 20px); height: 135px; background: #777; margin: 10px 10px 0 10px;&#125;@media (max-width: 420px) &#123; .picture &#123; width: calc(50% - 20px); &#125;&#125;.art &#123; width: 600px; /* 用于布局宽度 */ margin: 20px auto; &#125;@media (max-width: 420px) &#123; .art &#123; width: auto; display: flex; flex-direction: column; &#125;&#125;.aside &#123; width: calc(33.3333% - 20px); /* 用于1:3的布局div */ float: left; margin-right: 20px; /* 因为用了左右浮动，所以可以不加 */&#125;@media (max-width: 420px) &#123; .aside &#123; width: auto; height: auto; margin-right: 0px; &#125;&#125;.main &#123; width: 66.6666%; /* 用于1:3的布局div */ float: right;&#125;@media (max-width: 420px) &#123; .main &#123; width: auto; height: auto; &#125;&#125;.aside-child &#123; background: #555; height: 300px; text-align: center; /* 水平居中 */ line-height: 300px; /* 单行文本设置line-height = height,就能实现里面文字垂直居中 */&#125;@media (max-width: 420px) &#123; .aside-child &#123; height: auto; line-height: normal; &#125;&#125;.main-child &#123; background: #888; height: 300px; text-align: center; /* 水平居中 */ line-height: 300px;&#125;@media (max-width: 420px) &#123; .main-child &#123; height: auto; line-height: normal; &#125;&#125; 效果如图： 问如何解决banner 的拉伸问题，如果banner是图片，就很容易造成图片的拉伸 解决方法是使用background，不要使用img标签，不要使用img标签，使用div，给div加背景图片，这样是最安全的，不会出现任何问题。 123456.banner &#123; ... background: transparent url(https://i.loli.net/2019/05/03/5ccc47da7e1de.jpg) no-repeat center; background-size: cover; ....&#125; 效果如图: 链接： 如果要想实现固定比例的图片，搜索固定比例div]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS画太极]]></title>
    <url>%2F2018%2F11%2F09%2FCSS%E7%94%BB%E5%A4%AA%E6%9E%81%2F</url>
    <content type="text"><![CDATA[画太极学习 伪元素 和 position 属性 ：after或：before将它与position：absolute一起使用。这对于连接到图像，段落或其他任何内容的天赋项非常有用。例如： 1234567891011.div::after &#123; content: &quot;*&quot;; position: absolute; top: 5px; right: 35px; font-size: 85px; color: #fff;&#125;.div &#123; position: relative;&#125; 关于 伪元素和position定位的博客好文 第一次第二次，细节改进,.yinyang:before和.yinyang:before应为阴阳本体的一半。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2-CSS学练第一天]]></title>
    <url>%2F2018%2F11%2F05%2FCSS%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[css学习资源 图片网站goole wall haven 下载一些高清大图阿里的矢量图标网站 英文维基百科中文维基百科 周边工具 LESS CSS一种简化、功能更多的 CSS 语言 中文官网 英文官网 SASS一种简化、功能更多的 CSS 语言 中文官网 PostCSS一种 CSS 处理程序 【建议】先不要看周边工具，学好最朴素的 CSS，然后升级就很容易了。 CSS学习资源 Google: 关键词 MDN CSS Tricks Google: 阮一峰 css 张鑫旭的 240 多篇 CSS 博客 Codrops 炫酷 CSS 效果 CSS揭秘 CSS 2.1 中文 spec Magic of CSS 免费在线书 CSS学习建议CSS不正交及表现CSS不正交的意思就是，CSS的各个属性之间存在相互影响，也就是会自相矛盾。所以很可能你现在实现了效果，再加入一个属性以后效果就完全打乱了。 CSS容易学？背套路就能应付平时工作。 CSS是艺术，不是科学。不要尝试去理解CSS的复杂原理，满足需要就行了。 自己试（会累死的） 让别人研究，我用现成的，现在有很多这样的网站。 多实践，多总结 先学会套路：布局&amp;居中&amp;自适应&amp;媒体查询&amp;响应式&amp;能做页面就可以了。 熟练常用的，其他效果用到再google。 巧用工具CSS3 Generator 平时有时间就写博客总结以下CSS的用法。 记住几个常见的写法即可：居中{两种水平居中，三种垂直居中}、布局{两种左右结构，两种左中右结构}、一行省略、多行省略 CSS难学（不正交 + 属性多 + 性价比低）CSS 不正交，因而有些反直觉。不正交主要表现在两点： 同一元素的各属性之间互相影响 margin合并 VS border ul&gt;li VS display position: absolute VS display: inline 各元素之间互相影响 position: fixed VS transform float 影响 inline 元素 中文学习资源只看大 V 的（毕竟他们要维护形象不能瞎写），英文资源看 CSS Tricks、MDN 和 Codrops。书的话作用不大，最权威的书其实是文档。而中文学习资源毕竟是二手资源，别人的博客更是三手资源，所以还是好好学英文，直接读一手资源。 如果你想快速上手，就先写 CSS 小 demo 再学理论。如果你想一鸣惊人，就仔细看 CSS 规范文档。 CSS知识文档流是什么？文档内元素的流动方向。每个内联元素（inline）从左到右流动，每个块级元素（block）从上到下流动，每个块级元素独占一行。给元素加边框border是很好的调试方法。 说一下自己的感受，调试了一点CSS样式，工具很好用，就是调试需要耐心，往往根据浏览器显示的为准，有点玄学的感觉，所以往往需要选取容错率较高的CSS样式实现方法。CSS样式是一环套一环的，“牵一发而动全身”，可见布局很重要，CSS经验也很重要。 脱离文档流有很多种方法！方法一：设置了positopn:fixed; 的元素 就不属于原来的父元素了，父元素的宽度和高度都不包括它。而是相对屏幕固定。但是这种方法脱离文档流后，所有元素都会往左上角 叠加 起来。必须加width=100%解决，加了宽度超级容易出bug，文档超出了宽度，又得在里面加一个内标签，把padding放在里面。 宽度是由什么决定的块级元素宽度是自适应的，站满整个屏幕一行。随着屏幕宽度变化，块级元素宽度变化。 内联元素的宽度不可测。会随内联元素里的内容的宽高自动改变。 高度是由什么决定的 内联元素的高度 内联元素的高度不可测。给内联元素设置宽高会默认失效 但是你可以把内联元素设置为块级元素。其中内联元素有个奇特的地方，当一个内联是一个很长的单词的时，页面就算不够大容纳不下这个单词，默认情况下这个单词是不会分开，浏览器会把这个单词看作一个整体，英文的不可分割性原则，但是中文汉字就算是一个词语也会分开。但是可以通过设置word-break：break-all;样式强行分开。比如span的高度确定就是个复杂的问题，具体以浏览器显示为主。 块级元素的高度块级标签元素的高度：由其内部文档流元素 的高度总和 决定【背】也就是说，块级标签内部没有元素的时候 高度为0 内联块级元素 内联块级元素不会独占一行，而且元素宽和高可设定，拥有内联和块级元素的特点 方说这个是这个是历史上最大的错误，不知道从何说起？这个内联块级元素把块级元素变成内联元素以后，把独占一行的块级元素排成一行，就像导航栏的浮动效果。方说尽量用浮动float。 在不同电脑上看可能元素高度又不一样了，所以最好设置一下line-height,比如line-height=22px,这样元素载各个电脑的浏览器上就一样了。 box modelbox-sizing有两个值分别为content-box和border-box，默认是 content-boxcontent-box 盒子的宽 和 高是 content 的宽和高。border-box 盒子的宽 或 高是 content 、padding 和 border 三者宽或高的总和 开始写CSS 引入 CSS 的三/四种方式 从最小的东西开始入手 逐渐变大 学会组织 CSS（以后再说） 自己写 CSS UI 库 引入CSS样式的方法使用CSS内联样式直接给开始标签加上style属性，如&lt;body style=&quot;background-color:grey;&quot;&gt;&lt;/body&gt;，优点是样式加在哪个标签上很明显，缺点是开始标签就会变得很长，代码看上去很乱很丑 头标签&lt;head&gt;&lt;/head&gt;加入&lt;style&gt;标签引入CSS样式。如： 1234&lt;head&gt; ... &lt;style&gt;CSS样式&lt;/style&gt;&lt;/head&gt; 这样所有的样式都被我们放到&lt;style&gt;标签里面了，我们的html代码看上去更简洁了，可是当我们的样式很多的时候，style标签内容就太长了，导致head头部太长了，这样也太不好看了，为此我们引进方法3。 link标签嵌入外部CSS样式。当CSS样式太多太长的时候，我们将所有的CSS样式都放外部的.css文件里，然后再在头部&lt;head&gt;里用&lt;link&gt;标签把这个 .css 文件嵌入进来，如此一来，我们的HTML就有了CSS样式，HTML代码也很干净简洁，有规矩。这个方法会在装载页面主体部分 之前装载css文件，这样实现出来的页面从一开始就是带有样式效果的。 1234&lt;head&gt; ... &lt;link href="style.css" rel="stylesheet" type="text/css"&gt;&lt;/head&gt; 一个.css文件里嵌入另一个.css文件结果就是两个.css的样式都会应用于html文件，最终展示出来。这个效果我们可以通过开发者工具，查看浏览器发起的请求 验证。这个方法会在整个页面装载完成之后再装载css文件，对于有的浏览器来说， 在一些情况下，如果页面文件的体积比较大，则会出现先现无样式的页面，闪烁一下之后再出现设置样式的效果。从浏览者的感受来说，这是使用导入式的一个缺陷。 12/* 在style.css里 */ @import "other.css" 要学好CSS 通读CSS规范文档-17章。CSS2中文文档CSS3没有中文，英语要求高，人类根本都不读不完 让张鑫旭（国内CSS研究前端最深的）研究，我用。 CSS研究再厉害，不能变成商业价值也没有用。 所以一切够用就行。 JS才是前端核心]]></content>
      <tags>
        <tag>CSS资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word Learning]]></title>
    <url>%2F2018%2F11%2F03%2FWord-Learning%2F</url>
    <content type="text"><![CDATA[embe 嵌入 iframe 框架 omit 删掉省略 audio 声音、声卡、音频 contenteditable 内容可编辑的 Graphics 图形、图形、显卡 slide control 滑动控制 animation 动画制作 Ultimate CSS Gradient Generator 终极CSS渐变生成器 hexo deploy hexo部署 recursively 递归地 console 控制台，安慰 append 追加 canvas 画布 rectangle 长方形 parse 解析 prototype 原型 infinite 无限的 sticky 黏性的 pseudo - elements 伪元素 sibling 兄弟姐妹 nextSibling 下一个兄弟节点 coords 坐标 alias 别名 compressed压缩的 trigger 触发 layout 布局 axis 轴线 column 按纵队排列 row 按行排列 stretch 延伸 伸展 rotate 旋转 skew 歪的 斜的 slides 轮播 viewport 视口 negative margin负边距 assign 分配 align 排队 detach 分离、拆开 bind 约束，装订 asynchronous 异步的 preview预览 Indents selected lines 缩进选中行]]></content>
  </entry>
  <entry>
    <title><![CDATA[server了解]]></title>
    <url>%2F2018%2F10%2F31%2Fserver%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTTP是控制如何书写内容的协议,规定了请求和响应的格式（四个内容）。TCP是控制如何传输的协议。IP是控制如何联网的协议。TCP可靠,会面向连接。可靠是指我发一个请求，成功与否我是知道的，而UDP是不知道的。以上解决面试。 外网、内网、本地IP、0.0.0.0 必须提供IP和端口号。 服务器三个特点： 有网、CPU要好、内存要高。没有显卡和显示器。服务器简单说就是电脑，但是它比电脑要更稳定。bash脚本和node.js脚本都提供HTTP服务 node.js不是这节课的重点,理解服务器才是重点。理解好服务器才是一个好的前端，之前讲了六节课,就是为了讲服务器。装gitbash是为了学命令行，学命令行是为了知道什么是脚本(script)。学脚本就是为了让你学node.js，学node.js就是为了今天的服务器(server)。 学习server.js是课上的一个用 node.js 写的一个服务器 视频里还有版本三和版本四的代码，版本三的代码是指定当path == ‘/index’，响应一个标准的html,但是只能看到网页的源代码，也就是实质上服务器给我们的响应是字符串文本。而当我们加了response.setHeader(‘Content-Type’,’text/html’)后，用浏览器再次访问http://localhost:8888/index 时，就得到的响应是一个网页。内容就只有html主体的内容。另外，如果body里还有中文的话，可能会出先乱码，原因就是服务器和浏览器使用不同的字符集，所以我们的server.js里面还要加入字符集的设置，response.setHeader(‘Content-Type’,’text/html;charset=utf-8’) 。也就是要告诉浏览器 服务器使用的是什么字符集，然后浏览器会使用和服务器一样的字符集去解析响应。 再次强调后缀名在命令行里面是没有用。 然后就进一步修改代码，访问/index /style /script。进一步设置当浏览器访问这些时服务器（server）分别响应什么内容给浏览器。就是今天任务的题目了。 通过这个过程我们应该学到浏览器是如何去解析服务器发回来的响应的，一步一步去满足你的请求。比如发现这个网页还需要图片就再次像服务器发起请求，依次类推。看方方任务7最后的总结视频，最后10分钟，好好听。2018.10.31暂时到这，第七课要整理笔记]]></content>
  </entry>
  <entry>
    <title><![CDATA[4Git操作与GitHub仓库]]></title>
    <url>%2F2018%2F10%2F29%2Fgit%E6%93%8D%E4%BD%9C%E4%B8%8Egithub%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[以下内容要求读者有简单的命令行基础。 配置 GitHub 进入 https://github.com/settings/keys 如果页面里已经有一些 key，就点「delete」按钮把这些 key 全删掉。如果没有，就往下看。 点击 「New SSH key」，你需要输入 Title 和 Key，但是你现在没有 key，往下看 打开 Git Bash 复制并运行 rm -rf ~/.ssh/* 把你本地电脑现有的 ssh key都删掉，这句命令行如果你多打一个空格，可能就要重装系统了，建议复制运行。 运行 ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱&quot;，注意填写你的邮箱！ 按回车三次(你会看到提示的，照做就对了，回车一共按三次) 运行 cat ~/.ssh/id_rsa.pub，得到一串东西，这就是ssh key,完整的复制这个ssh key。 回到上面第 3 步的页面，在 Title 输入「我的第一个 key」 在 Key 里粘贴刚刚你复制的ssh key 点击 Add SSH key 回到 Git Bash 运行 ssh -T git@github.com，你可能会看到下面的提示，回答YES！ 然后如果你看到 Permission denied (publickey). 就说明你失败了，请回到第 1 步重来，是的，回到第 1 步重来；如果你看到 Hi liaolinyan2018! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 就说明你成功了！ 总结：以上操作就是添加了一个SSH key，你想了解原理就看这篇 文章 一台电脑只需要一个 SSH key 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题 如果你新买了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上 如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key 我就是因为系统崩了，把上面又做了一边 配置 git12345git config --global user.name 你的英文名 #此英文名不需要跟GitHub账号保持一致git config --global user.email 你的邮箱 #此邮箱不需要跟GitHub账号保持一致git config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor &quot;vim&quot; 五句话，依次在Git Bash命令行中运行（其中前两句要把中文改成对应的内容）。一定要执行这五行！！！一定要执行这五行！！！一定要执行这五行！！！ 使用 git使用 git 有三种方式，请按照你的需求选择 只在本地电脑上新建并使用.git仓库 将本地.git仓库上传到GitHub 下载 GitHub 上的.git仓库到本地电脑 1 只在本地使用1.1 初始化 创建目录作为我们的项目目录：mkdir git-demo-1（记住以后开始任何项目之前都要新建一个自己目录作为项目目录） 进入目录 cd git-demo-1 git init，这句命令会在 git-demo-1里创建一个 .git仓库,这时.git仓库是空仓库,但是它的结构很复杂。 ls -la 你就会看到 .git目录，它就是一个「仓库」(repo)，不要点进去看。 在 git-demo-1目录里面添加任意文件，假设我们添加了3个文件 运行git status -sb 可以看到文件前面有 ??号,这个 ??表示 git 一脸懵逼，不知道你要怎么对待这些变动。 使用指令git add 将文件变动添加到「暂存区」 你可以一个一个地 add git add index.html git add style.css git add main.js 你也可以一次性 add。git add . 意思是把当前目录（.表示当前目录）里面的变动都加到「暂存区」 再次运行 git status -sb。可以看到 ??变成了A。A的意思就是添加，也就是说你告诉 git，这些文件我要加到仓库里 使用git commit . -m &quot;提交/改动信息&quot;将你 add过的内容「正式提交」到本地仓库（.git就是本地仓库），并添加一些注释信息，方便日后查阅。git commit 将暂存区变动提交到本地仓库。 你可以一个一个地 commit git commit index.html -m &#39;添加index.html&#39; git commit style.css -m &quot;添加style.css&quot; git commit main.js -m &quot;添加main.js&quot; 你也可以一次性 commit 。 git commit . -m &quot;添加了几个文件&quot; 第三次运行 git status -sb，发现没有文件变动了，这是因为文件的变动已经记录在本地的.git仓库里了。 这时你使用 git log就可以看到历史上的变动： 以上就是 git init / git add ./ git commit . -m &quot;提交信息&quot; 的一次完整过程。 1.2 文件变动如果我想继续改文件，应该怎么做呢？ start style.css 会使用默认的编辑器打开style.css（macOS 上对应的命令是 open css/style.css） 然后我们在 css/style.css 里写入 body {background: red}，保存退出 运行git status -sb。发现提示中有一个 M。这个 M 的意思就是 Modified，表示这个文件被修改了。 此时你如果想让改动保存到仓库里，你需要先 git add style.css 或者也可以 git add .注意，由于这个style.css 以前被我们 add 过，所以此处的git add操作可以省略，但建议使用 git 的前一个月，不要省略 git add。换句话说，每一次改动，都要经过 git add和 git commit两个命令，才能被添加到 .git 本地仓库里。 再次运行 git status -sb 发现 M 有红色变成了绿色，红色和绿色有啥区别呢？别管它们的区别，记住我说的，先 add，再 commit，等你熟练之后再去理解区别。 运行 git commit -m &quot;更新style.css&quot;，这个改动就被提交到.git 本地仓库了。再说一次，不要去.git目录里面，那里的东西你一无所知。 第3次运行 git status -sb，会发现没有变更了，这说明所有变动都被本地仓库记录在案了。 这里来解释一下 git status -sb 是什么意思：git status是用来显示当前的文件状态的，哪个文件变动了，方便你进行 git add 操作。-sb 选项的意思就是，-s 的意思是显示总结（summary)，-b的意思是显示分支（branch），所以 -sb的意思是显示总结和分支。 1.3 总结至此，我们来总结一下用到的命令 git init，初始化本地电脑 .git仓库 git status -sb，显示当前所有文件的状态 git add 文件路径或git add .，用来将变动加到暂存区 git commit -m &quot;信息&quot;，用来正式提交变动，提交至本地电脑.git仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m &#39;xxx&#39;两个命令即可。先 add 再commit，行了，你学会git了。 git log查看变更历史 其实最常用的就是git init /git add/git commit 2 将本地仓库上传到 GitHub​ 如何将刚刚我们这个 git-demo-1 上传到 GitHub 呢？接着往下做吧~ 在 GitHub 上新建一个空仓库，名称随意，建议跟本地目录名一致，也叫做 git-demo-1。 按照截图所示，除了仓库名，其他的什么都别改，其他的什么都别改，这样你才能创建一个空仓库 点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图 看上图，点击 SSH 按钮，点击 SSH 按钮，点击 SSH 按钮。如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用 HTTPS 地址，因为 HTTPS 地址使用起来特别麻烦，每次都要输入密码，而 SSH 不用输入用户名密码。为什么 SSH 不用密码呢，因为我们已经上传了 SSH public key，这把钥匙可以打开很多仓库。 由于我们已经有本地仓库了，所以看图，图中下面半部分就是你需要的命令，我们一行行拷贝到Git Bash执行。 刷新当前页面，你的仓库就上传到 GitHub 了！是不是特别简单呢~ 3 直接在 GitHub 创建一个仓库，然后下载到本地上面两步讲了：1在本地创建.git仓库 2将本地仓库上传到 GitHub。其实这两步通常一起用，因为我在本地写好代码后一定会上传的GitHub上进行代码管理的。 这里讲第3种用法，那就是直接在 GitHub 创建一个仓库，然后下载到本地。这通常用于你git clone别人GitHub上的项目代码仓库，或者你不小心把自己本地的项目代码仓库删掉以后，把自己GitHub的远程仓库git clone到本地电脑，然后你又可以愉快地使用它们了。 在GitHub 上新建一个仓库 git-demo-2，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下： 这样一来，这个仓库就会自动拥有三个文件： 这三个文件的作用请自行了解：.gitignore 的作用、README.md 的作用 以及 LISENCE 的作用 好了，现在远程仓库已经创建好了，怎么下载到我们的本地（也就是我们的电脑上）呢？ 答案是使用 git clone 命令 点击页面中唯一的绿色按钮「Clone or download」,会看到一个弹出层，请确保弹出层里的地址是 SSH 地址，也就是 git@github.com 开头的地址，如果不是，就点击 Use SSH 按钮，就点击 Use SSH 按钮，就点击 Use SSH 按钮。然后复制这个地址。 打开 Git Bash，你找一个好地方新建一个目录作为我们的项目目录，进入这个目录（比如我的cd frontend），进入目录，进入目录。 运行 git clone 你刚才得到的以git@github.com开头的地址，运行完了你就会发现，你刚建的目录下多出一个 git-demo-2 目录。 进入这个多出来的目录。（cd git-demo-2） 运行 ls -la 你会看到，远程目录的所有文件都在这里出现了，另外你还看到了 .git 本地仓库。这时你就可以添加（touch）文件，git add，git commit了,git push。 10.我们再回顾一遍已经学到的命令： git clone [git@github.com](mailto:git@github.com):xxxx，下载仓库 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m &quot;信息&quot;，用来正式提交变动至本地 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史 如何上传更新当你的本地仓库和GitHub上的远程仓库绑定后，你在本地仓库有任何变动，只需按照以下顺序就能上传： git add 文件路径 git commit -m &quot;提交/变动信息&quot; git pull 将GitHub远程仓库上的变动拉取到本地，实现本地仓库和远程仓库同步。 git push 将本地仓库的更新上传到远程仓库 下面是例子 123456cd git-demo-1touch index2.htmlgit add index2.htmlgit commit -m &quot;新建 index2.html&quot;git pullgit push 然后你去 git-demo-1 的 GitHub 页面，就能看到 index2.html 出现在里面了。 .gitignore在项目目录创建 .gitignore 文件就可以指定「哪些文件不上传到远程仓库」，比如 .gitignroe 123//写在.gitignore文件里/node_modules//.vscode/ 这样就可以避免 node_modules/ 和 .vscode/ 目录被上传到 github 了。 记住一句话：永远都不要上传 node_modules 到 github。如果你想防止自己手贱上传 node_modules 到 github ，可以： 在项目根目录touch .gitignore 在 .gitignore 里添加一行 /node_modules/ git add .gitignore; git commit -m &#39;ignore&#39; 其他还有一些有用的命令 git remote add origin git@github.com:xxxxxxx.git 将本地仓库与远程仓库关联 git remote set-url origin git@github.com:xxxxx.git 上一步手抖了，可以用这个命令来挽回 git branch 新建分支 git merge 合并分支 git stash 通灵术 git stash pop 反转通灵术 git revert 后悔了 git reset 另一种后悔了 git diff 查看详细变化 如果你发现 git 下载速度很慢你可以看这篇教程 https://jscode.me/t/topic/789 资源 常用 Git 命令清单 读懂 diff - 阮一峰 搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门 Git 菜鸟教程 廖雪峰的 Git 教程]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行入门]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[以下内容为学习笔记，供复习参考使用 为什么要学命令行123456789101. 命令行是啥 先有的命令行，后有的图形界面。学习命令行就是背单词。2. 哪些系统提供了命令行 1. Windows 的命令提示符和 Git Bash 是命令行 2. Linux（如 Ubuntu) 的终端也是命令行 3. Unix（如 macOS）的终端也是命令行2. 为什么要学 - 因为现代的前端工具，都没有提供图形界面，只有命令行界面，所以从实用角度出发，前端必须学命令行 - 包括 Gulp、Webpack、SASS、Node.js、Vue、React、Angular - 你不学命令行还怎么混？ 认识 ~ / . .. $~ 用户目录/ 整个硬盘 （在linux里面没有b/c/d盘的概念，就是一个盘）. 一个点表示 当前目录.. 表示副目录$ 提示你可以输入命令,没有实际意义 绝对路径与相对路径的区别路径就是文件的地址，绝对路径就是给出直接的地址，相对路径至少要找两次，以/开头的就是绝对路径 常用命令1234561. 与文件相关命令2. 与网络相关命令 1. curl 2. wget3. 与 git 相关命令4. 与 hexo 相关命令 与文件相关命令ls命令语法: ls 选项解释:ls是list的缩写,功能是List directory contents,罗列出当前目录下的内容。根据指定不同的选项对列出的信息有所侧重。所以必须熟记命令的常用选项。常用选项: ls -a :显示当前目录下的所有文件,包括隐藏文件（即以.开头的文件） ls -l :显示当前目录下所有未隐藏文件的所有信息 ls -la :显示当前目录下的所有文件（包括隐藏文件）的所有信息其他选项：其他还有 -ls -lh -ltr 本文后面会介绍方法自己去查。学习建议：自己找个熟悉的文件夹依次敲入 ls -a ls -l ls -la 等,根据命令行反馈回来的信息理解对比一下。 cat命令解释: cat功能是concatenate files and print on the standard output,连接文件和标准打印输出文件内容。常用来查看文件内容,直接就在命令行从文件第一行开始显示。常见用法: cat file:从文件第一行打印输出文件所有内容 cat file1 file2 &gt; target_file:连接多个文件内容到指定目标文件,目标文件就拥有了这几个文件的内容。 cat file1 file2 &gt;&gt; target_file:追加多个文件的内容到指定目标文件,在目标文件原有内容后新增内容。 cat -n file:从文件第一行打印输出文件所有内容,且每一行都有标号（空行也有标号） mv命令语法: mv 源文件 目标文件解释: mv是move的缩写,功能是Move or rename files and directories,移动或重命名文件。常用举例: 文件重命名 1mv 1.txt 2.txt 上面命令将 1.txt 重命名为 2.txt ，文件内容不变 mkdir命令语法: mkdir 文件夹名解释: 修改文件夹创建时间或者在当前目录下创建一个新的文件夹常用举例: mkdir demo-6 创建一个文件夹demo-6 mkdir -p &quot;demo-1/demo-2/demo-3/demo-4&quot; 创建父子关系的文件夹demo-1/demo-2/demo-3/demo-4 mkdir demo 2 创建两个文件夹 demo 和 2 touch命令语法: touch 文件名解释: 修改文件创建时间或者在当前目录下创建一个新的文件常用举例: touch 1.txt :touch了一个存在的文件1.txt，修改了文件建立时间，但文件内容不变 touch 2.txt :在当前目录下新建了一个文件2.txt echo命令语法: echo &#39;&#39;conten&#39;&#39; &gt; 文件名解释: 回声常用举例: echo &#39;&#39;1&#39;&#39; &gt; 1.txt 新创建一个文件1,txt，并把1写入1.txt。执行两次会覆盖原来的内容。 echo &#39;&#39;1&#39;&#39; &gt; ! 2.txt windows不能用 echo &#39;&#39;1&#39;&#39; &gt;&gt; 1.txt 给文件1.txt追加内容1，并不覆盖原来的内容 touch 3.txt 也是创建文件3.txt,但是不能指定内容。再touch 3.txt 一次，其实touch就是改变文件的更新时间用的，再touch一次文件内容不会变 rm命令语法: rm 文件夹名解释: 修改文件创建时间或者在当前目录下创建一个新的文件常用举例: rm –f 文件名 删除文件路径，-f表示强制删除 rm –r 文件夹名 删除整个文件夹，-r 表示递归的删除· rm –rf 文件夹名 强制删除整个文件夹，连文件夹的子文件夹也删除，-f 是强制删除的意思,所以删除目录用-rf df –kh 磁盘占用 du –sh 当前目录大小(s 是总结 h 是人类，给人类看的） du –h 各文件大小 使用 explainshell.com 这个网站Linux有很多命令,没有必要每个都记,当我们看到不认识的指令就可以通过下面这个网站查询指令的意思和用法。使用explainshell.com这个网站，该网站是一个帮助程序员解释命令行的网站，它会分析命令的帮助文档，然后根据你想查询的命令参数来抽取对应的解释，然后简洁易懂地显示出来。 命令行释义:https://explainshell.com/explain?cmd=ls+-lrt 快去试一下吧！ 安装查看命令的常用选项：https://github.com/tldr-pages/tldr#tldr 如何学习还没有掌握的命令Google: Linux 查看文件内容 快捷键 ↑ ↓ 上一命令 / 下一命令 !! 上一命令占位符 Tab 自动补全路径 Alt+. 上一命令的最后一个参数 &amp;&amp; 前面的执行成功了，再执行后面的 || 前面的执行失败了，就执行后面的 ; 前面执行完了，不管成功失败，就执行后面的 &gt; 重定向 | 管道 vim操作注意 每完成一次vim操作，都要记得按下 esc回到正常模式，再执行下一个vim操作。 删除的是光标右边的字符 如何退出 vim 不保存强制退出：按 esc确保你在正常模式，然后按下 :q! 回车 保存后退出：按esc确保你在正常模式，然后按下:wq回车 如何学习 vimvim 被誉为 编辑器之神。 如果你想要入门vim，下面是三个教程： 在命令行输入 vimtutor ，即可查看官方自带的中文教程。很详细，看完它。 简明 VIM 练级攻略 一个 vim 游戏 与网络相关命令curl命令 举例：curl -L [https://www.baidu.com](https://www.baidu.com/) &gt; baidu.html wget命令 举例：wget -p -H -e robots=off [https://www.baidu.com](https://www.baidu.com/) (Windows 不支持 wget) 与 Git相关命令我们学Git操作就是为了使用GitHub仓库来管理我们的源代码。 我的博客：git操作与GitHub仓库 与 hexo 相关命令Hexo 使用示例 ~/.bashrc 的用途121. 预先执行命令2. bash alias]]></content>
  </entry>
  <entry>
    <title><![CDATA[4错题汇总]]></title>
    <url>%2F2018%2F10%2F28%2F%E9%94%99%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[在命令行里书写命令时，大小写无所谓，比如 cd ..和 CD .. 没区别。 答：× 命令行如何进入上级目录。 答：cd .. 或cd ../ 命令行如何进入当前目录中的a目录。 答：cd a或cd ./a 目前我在/a/b目录，输入 cd /c/ 我会进入哪个目录？ 答： /c/ 命令行如何在当前目录创建一个目录 xxx？答： mkdir xxx mkdir ./xxx mkdir -p &quot;xxx&quot; 目前我在/a/，我想创建 /a/b/c/d/e/目录，用一个 mkdir命令如何实现？答：mkdir -p /a/b/c/d/e/ 如何删除目录 /a/xxx/ ? 答：rm -rf /a/xxx/ 目前我在 /tmp/目录，运行 git clone git@github.com:FrankFang/nodejs-test.git,请问 /tmp/ 目录里会多出一个什么目录？ 答：nodejs-test 将 xxx 文件变动加入 git 暂存区的命令是什么？ 答：git add xxx 将 xxx文件变动提交到 git 本地仓库的命令是什么？ 答:git commit xxx git push 之前最好 git pull 一下? 答：√ , 为了将远程仓库拉到本地仓库，使得远程仓库和本地仓库保持相同。 git 的默认远程仓库名叫做什么？ 答：origin git 的默认分支叫做什么？ 答：master git课外资料： http://www.runoob.com/git/git-tutorial.html 超级容易错的-教程里配置git的五大步骤： git config --global user.name liaolinyan2018 git config --global user.email linyanliao@126.com git config --global core.quotepath false git config --global core.editor &quot;vim&quot; git config --global push.default simple 说明：前两步是修改过的结果，每个人都不一样]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速搭建博客]]></title>
    <url>%2F2018%2F10%2F28%2F%E7%94%A8hexo%E5%92%8Cgithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[用Hexo+GitHub快速搭建博客 进入一个安全的目录,如 cd frontend。 在 GitHub 上新建一个空 repo（仓库），repo 名称是「你的用户名.github.io」（注意仓库名称是你的GitHub用户名，不是你的电脑用户名） 比如我是： 1liaolinyan2018.github.io 注意在frontend这个目录下，复制命令npm install -g hexo-cli到Git Bash，安装 Hexo 注意在frontend这个目录下，hexo init hexo cd hexo hexo new 开博大吉,你会看到一个 md 文件的路径 start xxx.md，或者直接从文件夹下右键打开，编辑这个 md 文件。（Ubuntu 系统用 xdg-open xxx.md 命令） start _config.yml，编辑网站配置 把第 6 行的 title 改成你想要的名字 把第 9 行的 author 改成你的大名 把最后一行的 type 改成 type: git 在最后一行后面新增一行，左边与 type 平齐，加上一行 repo: 仓库地址 。（请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址以 git@github.com: 开头） 第 4 步的repo:后面有个空格，不要眼瞎。 npm install hexo-deployer-git --save，安装 git 部署插件 hexo deploy 进入「你的用户名.github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接 用浏览器访问「预览链接/index.html」就应该看到了你的博客！（GitHub Pages 存在延迟，如果没看到，过三分钟再刷新看看） 第二篇博客 hexo new 第二篇博客 复制显示的路径，使用 start 路径 打开它，或者直接打开文件夹右键打开它，然后编辑它，写你的博客。 hexo generate 简写hexo g hexo deploy 简写hexo d 去看你的博客，应该能看到第二篇博客了 换主题 博客主题合集 随便找一个主题，进入主题的 GitHub 首页。 复制它的 SSH 地址或 HTTPS 地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git cd themes git clone git@github.com:iissnan/hexo-theme-next.git cd .. 将 _config.yml 的第 75 行改为 theme: hexo-theme-next，保存 hexo generate hexo deploy 等一分钟，然后刷新你的博客页面，你会看到一个新的外观。如果不喜欢这个主题，就回到第 1 步，重选一个主题。 上传源代码注意「你的用户名.github.io」上保存的只是你的博客，并没有保存「生成博客的程序代码」，你需要再创建一个名为 blog-generator 的空仓库，用来保存 myBlog 里面的「生成博客的程序代码」。 在 GitHub 创建 blog-generator 空仓库 按照截图中的命令执行即可，记住，别 TMD 用 HTTPS 地址。 这样一来，你的博客发布在了「你的用户名.github.io」而你的「生成博客的程序代码」发布在了 blog-generator。所有数据万无一失，你就不会因为误删 myBlog 目录而痛哭了。 以后每次 hexo deploy 完之后，博客就会更新；然后你还要要 add / commit /push 一下「生成博客的程序代码」，以防万一。 这个 blog-generator 就是用来生成博客的程序，而「你的用户名.github.io」仓库就是你的博客页面。 总结：平时搭建博客步骤共五步骤，其中三步必须 hexo new &quot;博客文章名&quot; hexo会帮我们在/g/frontend/hexo/source/_posts目录下生成博客文章名.md文件，这篇博客标题就是博客文章名 start 博客路径 注意博客路径要写完整,上一步有提示。用Markdown编辑器打开这个博客文件，编辑博客内容 部署到github之前打开站点配置文件_config.yml进行修改配置，不熟悉最好google找篇教程。这步部署一次以后，以后有需要再改，也就是说并不是你每次写完博客都要做这步。以下三步是部署到github。 hexo clean hexo g 全称hexo generate,执行之后,hexo就会在/hexo/public文件夹下生成相关html文件，这些文件将来都是要提交到github上一个叫 [你的用户名.github.io]的仓库上去的 hexo d 全称hexo deploy,执行之后,就部署到github了。 使用github pages服务搭建博客的好处 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 资源hexo操作讲得超级详细。点进去看吧。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
